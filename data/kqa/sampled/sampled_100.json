[
  {
    "graphq_ir": "what is the qualifier <Q> determination method </Q> of <ES> <C> national association football team </C> that <R> country </R> forward to <E> Cameroon </E> </ES> whose <A> ranking </A> is <V> 60 </V>",
    "kopl": "Find(Cameroon).Relate(country,backward).FilterConcept(national association football team).QueryAttrQualifier(ranking,60,determination method)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"national association football team\" . ?e <country> ?e_1 . ?e_1 <pred:name> \"Cameroon\" .  ?e <ranking> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"60\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <ranking> ; <pred:fact_t> ?pv ] <determination_method> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Cameroon\"\nMATCH (n1:national_association_football_team)<-[r1:country]-(n2) WHERE n1.ranking =  60 \nRETURN r1.determination_method",
    "question": "What is the determination method of 60, the ranking of the national association football team whose country is Cameroon?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"national association football team\"}) match (e)-[:country]->(e_1:Resource{name:\"Cameroon\"}) match (e)-[:ranking]->(pv:Resource{unit:\"1\",value:60.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"ranking\"}),(tmp)-[:determination_method]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Cameroon"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "national association football team"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "ranking",
          "60",
          "determination method"
        ]
      }
    ],
    "sample_id": "train_35764",
    "answer": "FIFA World Rankings"
  },
  {
    "graphq_ir": "what is the attribute <A> start time </A> of <E> 1980 Winter Olympics </E>",
    "kopl": "Find(1980 Winter Olympics).QueryAttr(start time)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"1980 Winter Olympics\" . ?e <start_time> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.1980_Winter_Olympics ( string start_time ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"1980 Winter Olympics\"\nRETURN n1.start_time",
    "question": "What is the start time for the 1980 Winter Olympics?",
    "cypher_match": "match (e:Resource{name:\"1980 Winter Olympics\"})-[:start_time]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "1980 Winter Olympics"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "start time"
        ]
      }
    ],
    "sample_id": "train_20362",
    "answer": "1980-02-14"
  },
  {
    "graphq_ir": "what is the relation from <E> FC Levadia Tallinn </E> to <E> green </E>",
    "kopl": "Find(FC Levadia Tallinn).Find(green).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"FC Levadia Tallinn\" . ?e_2 <pred:name> \"green\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"FC Levadia Tallinn\"\nMATCH (n2) WHERE n2.name = \"green\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between FC Levadia Tallinn and green?",
    "cypher_match": "match (e_1:Resource{name:\"FC Levadia Tallinn\"})-[p]->(e_2:Resource{name:\"green\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "FC Levadia Tallinn"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "green"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_32752",
    "answer": "official color"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <E> Til Schweiger </E>",
    "kopl": "Find(Til Schweiger).QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Til Schweiger\" . ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Til_Schweiger ( string ISNI ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Til Schweiger\"\nRETURN n1.ISNI",
    "question": "Which ISNI code belongs to Til Schweiger?",
    "cypher_match": "match (e:Resource{name:\"Til Schweiger\"})-[:ISNI]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Til Schweiger"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_43105",
    "answer": "0000 0001 1497 4293"
  },
  {
    "graphq_ir": "what is <ES> <C> visual artwork </C> that <R> followed by </R> backward to <ES> <C> film </C> whose <A> official website </A> is text <V> http://web.archive.org/web/20061116073244/http://saw3.com/ </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(official website,http://web.archive.org/web/20061116073244/http://saw3.com/).FilterConcept(film).Relate(followed by,forward).FilterConcept(visual artwork).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e_1 <followed_by> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"film\" . ?e_1 <official_website> ?pv . ?pv <pred:value> \"http://web.archive.org/web/20061116073244/http://saw3.com/\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.visual_artwork ) ( string ! type ) ) ( call SW.reverse ( string followed_by ) ) ) )",
    "cypher": "MATCH (n2:film) WHERE n2.official_website = \"http://web.archive.org/web/20061116073244/http://saw3.com/\"\nMATCH (n1:visual_artwork)-[r1:followed_by]->(n2)\nRETURN n1.name",
    "question": "Which movie succeeds the movie whose official website is http://web.archive.org/web/20061116073244/http://saw3.com/?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e_1)-[:followed_by]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"film\"}) match (e_1)-[:official_website]->(pv:Resource{value:\"http://web.archive.org/web/20061116073244/http://saw3.com/\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://web.archive.org/web/20061116073244/http://saw3.com/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "followed by",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_49504",
    "answer": "Saw IV"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> whose <A> name in native language </A> is text <V> Richard C. Clark </V> </ES> <A> ISNI </A> is text <V> 0000 0001 0707 9354 </V>",
    "kopl": "FindAll().FilterStr(name in native language,Richard C. Clark).FilterConcept(human).QueryAttr(ISNI).VerifyStr(0000 0001 0707 9354)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <name_in_native_language> ?pv_1 . ?pv_1 <pred:value> \"Richard C. Clark\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 0707 9354\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:human) WHERE (n1.name_in_native_language = \"Richard C. Clark\" AND n1.ISNI = \"0000 0001 0707 9354\")\nRETURN isEmpty(n1)",
    "question": "Is 0000 0001 0707 9354 the ISNI of the person whose native language name is Richard C. Clark?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:name_in_native_language]->(pv_1:Resource{value:\"Richard C. Clark\"}) match (e)-[:ISNI]->(pv:Resource) return pv.value = \"0000 0001 0707 9354\"",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "name in native language",
          "Richard C. Clark"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "ISNI"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "0000 0001 0707 9354"
        ]
      }
    ],
    "sample_id": "train_41800",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Aude </E> whose <A> ISNI </A> is text <V> 0000 0000 7408 0673 </V> </ES> to <E> Montreal </E>",
    "kopl": "Find(Aude).FilterStr(ISNI,0000 0000 7408 0673).Find(Montreal).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Aude\" . ?e_1 <ISNI> ?pv . ?pv <pred:value> \"0000 0000 7408 0673\" . ?e_2 <pred:name> \"Montreal\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Aude\"\nMATCH (n1) WHERE n1.ISNI = \"0000 0000 7408 0673\"\nMATCH (n2) WHERE n2.name = \"Montreal\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "Aude, designated by ISNI 0000 0000 7408 0673, has what connection to Montreal?",
    "cypher_match": "match (e_1:Resource{name:\"Aude\"})-[:ISNI]->(pv:Resource{value:\"0000 0000 7408 0673\"}) match (e_1:Resource{name:\"Aude\"})-[p]->(e_2:Resource{name:\"Montreal\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Aude"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0000 7408 0673"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Montreal"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_9662",
    "answer": "place of birth"
  },
  {
    "graphq_ir": "which one has the smallest <A> duration </A> among <ES> <E> Lost Highway </E> or <E> Legends of the Fall </E> </ES>",
    "kopl": "Find(Lost Highway).Find(Legends of the Fall).Or().Select(duration,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Lost Highway\" .  } UNION { ?e <pred:name> \"Legends of the Fall\" .  } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Lost_Highway en.Legends_of_the_Fall ) ( string min ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Lost Highway\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Legends of the Fall\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Which movie cost less to make, Lost Highway or Legends of the Fall?",
    "cypher_match": "call { match (e:Resource{name:\"Lost Highway\"}) return e union match (e:Resource{name:\"Legends of the Fall\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Lost Highway"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Legends of the Fall"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "duration",
          "less"
        ]
      }
    ],
    "sample_id": "train_13135",
    "answer": "Legends of the Fall"
  },
  {
    "graphq_ir": "what is the relation from <E> Jermaine Easter </E> to <E> Wolverhampton Wanderers F.C. </E>",
    "kopl": "Find(Jermaine Easter).Find(Wolverhampton Wanderers F.C.).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Jermaine Easter\" . ?e_2 <pred:name> \"Wolverhampton Wanderers F.C.\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Jermaine Easter\"\nMATCH (n2) WHERE n2.name = \"Wolverhampton Wanderers F.C.\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between Jermaine Easter and Wolverhampton Wanderers F.C.?",
    "cypher_match": "match (e_1:Resource{name:\"Jermaine Easter\"})-[p]->(e_2:Resource{name:\"Wolverhampton Wanderers F.C.\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jermaine Easter"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Wolverhampton Wanderers F.C."
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_91808",
    "answer": "member of sports team"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Victoria </E> whose <A> publication date </A> is date <V> 2015-06-11 </V> </ES> to <E> German </E>",
    "kopl": "Find(Victoria).FilterDate(publication date,2015-06-11,=).Find(German).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Victoria\" . ?e_1 <publication_date> ?pv . ?pv <pred:date> \"2015-06-11\"^^xsd:date . ?e_2 <pred:name> \"German\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Victoria\"\nMATCH (n1) WHERE n1.publication_date =  2015-06-11 \nMATCH (n2) WHERE n2.name = \"German\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is the Victoria published on 2015-06-11 related to German?",
    "cypher_match": "match (e_1:Resource{name:\"Victoria\"})-[:publication_date]->(pv:Resource{date:Date(\"2015-06-11\")}) match (e_1:Resource{name:\"Victoria\"})-[p]->(e_2:Resource{name:\"German\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Victoria"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "publication date",
          "2015-06-11",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "German"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_61285",
    "answer": "original language of film or TV show"
  },
  {
    "graphq_ir": "what is the relation from <E> Delft </E> to <E> The Hague </E>",
    "kopl": "Find(Delft).Find(The Hague).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Delft\" . ?e_2 <pred:name> \"The Hague\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Delft\"\nMATCH (n2) WHERE n2.name = \"The Hague\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between Delft and The Hague?",
    "cypher_match": "match (e_1:Resource{name:\"Delft\"})-[p]->(e_2:Resource{name:\"The Hague\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Delft"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Hague"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_58240",
    "answer": "shares border with"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> martial arts </C> that <R> sport </R> backward to <E> Johnny Yong Bosch </E> </ES> and <ES> <C> martial arts </C> that <R> country </R> forward to <E> Japan </E> </ES> </ES>",
    "kopl": "Find(Johnny Yong Bosch).Relate(sport,forward).FilterConcept(martial arts).Find(Japan).Relate(country,backward).FilterConcept(martial arts).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"martial arts\" . ?e_1 <sport> ?e . ?e_1 <pred:name> \"Johnny Yong Bosch\" .  ?e <country> ?e_2 . ?e_2 <pred:name> \"Japan\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.and ( call SW.filter ( getProperty ( singleton en.martial_arts ) ( string ! type ) ) ( call SW.reverse ( string sport ) ) ) ( call SW.filter ( getProperty ( singleton en.martial_arts ) ( string ! type ) ) ( string country ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Johnny Yong Bosch\"\nMATCH (n3:martial_arts)-[r1:sport]->(n2)\nMATCH (n2) WHERE n2.name = \"Japan\"\nMATCH (n3:martial_arts)<-[r1:country]-(n2)\nRETURN n3.name",
    "question": "Which martial arts has the sports team of Johnny Yong Bosch and the country of Japan?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"martial arts\"}) match (e)-[:country]->(e_2:Resource{name:\"Japan\"}) match (e_1:Resource{name:\"Johnny Yong Bosch\"})-[:sport]->(e) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Johnny Yong Bosch"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "sport",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "martial arts"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Japan"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "martial arts"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_84186",
    "answer": "judo"
  },
  {
    "graphq_ir": "whether <ES> <C> legislative term </C> that <R> follows </R> backward to <E> 19th United States Congress </E> </ES> <A> start time </A> is not year <V> 1990 </V>",
    "kopl": "Find(19th United States Congress).Relate(follows,forward).FilterConcept(legislative term).QueryAttr(start time).VerifyYear(1990,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"legislative term\" . ?e_1 <follows> ?e . ?e_1 <pred:name> \"19th United States Congress\" .  ?e <start_time> ?pv . ?pv <pred:year> ?v . FILTER ( ?v != 1990 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"19th United States Congress\"\nMATCH (n1:legislative_term)-[r1:follows]->(n2) WHERE n1.start_time <>  1990 \nRETURN isEmpty(n1)",
    "question": "Did a legislative term, that is followed by 19th United States Congress, begin in a year other than 1990 ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"legislative term\"}) match (e)-[:start_time]->(pv) match (e_1:Resource{name:\"19th United States Congress\"})-[:follows]->(e) return pv.year <> 1990",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "19th United States Congress"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "follows",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "legislative term"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "start time"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1990",
          "!="
        ]
      }
    ],
    "sample_id": "train_81046",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the relation from <E> Anchorage </E> to <ES> <E> Darwin </E> whose <A> inception </A> is year <V> 1869 </V> </ES>",
    "kopl": "Find(Anchorage).Find(Darwin).FilterYear(inception,1869,=).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Anchorage\" . ?e_2 <pred:name> \"Darwin\" . ?e_2 <inception> ?pv . ?pv <pred:year> 1869 . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Anchorage\"\nMATCH (n2) WHERE n2.name = \"Darwin\"\nMATCH (n2) WHERE n2.inception =  1869 \nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is Anchorage related to Darwin, founded in 1869?",
    "cypher_match": "match (e_2:Resource{name:\"Darwin\"})-[:inception]->(pv:Resource{year:1869}) match (e_1:Resource{name:\"Anchorage\"})-[p]->(e_2:Resource{name:\"Darwin\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Anchorage"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Darwin"
        ]
      },
      {
        "function": "FilterYear",
        "dependencies": [
          1
        ],
        "inputs": [
          "inception",
          "1869",
          "="
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_76714",
    "answer": "twinned administrative body"
  },
  {
    "graphq_ir": "what is the relation from <E> The Rolling Stones </E> to <E> protopunk </E>",
    "kopl": "Find(The Rolling Stones).Find(protopunk).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"The Rolling Stones\" . ?e_2 <pred:name> \"protopunk\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"The Rolling Stones\"\nMATCH (n2) WHERE n2.name = \"protopunk\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How are The Rolling Stones related to protopunk?",
    "cypher_match": "match (e_1:Resource{name:\"The Rolling Stones\"})-[p]->(e_2:Resource{name:\"protopunk\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Rolling Stones"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "protopunk"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_65636",
    "answer": "genre"
  },
  {
    "graphq_ir": "what is the qualifier <Q> nominee </Q> of <E> Blade Runner </E> that <R> nominated for </R> to <E> BAFTA Award for Best Editing </E>",
    "kopl": "Find(Blade Runner).Find(BAFTA Award for Best Editing).QueryRelationQualifier(nominated for,nominee)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Blade Runner\" . ?e_2 <pred:name> \"BAFTA Award for Best Editing\" . ?e_1 <nominated_for> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_2 ] <nominee> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Blade Runner\"\nMATCH (n2) WHERE n2.name = \"BAFTA Award for Best Editing\"\nMATCH (n1)-[r1:nominated_for]->(n2)\nRETURN r1.nominee",
    "question": "Who is the nominee connected to the nomination of the film Blade Runner for a BAFTA Award for Best Editing?",
    "cypher_match": "match (e_1:Resource{name:\"Blade Runner\"})-[:nominated_for]->(e_2:Resource{name:\"BAFTA Award for Best Editing\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:nominee]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Blade Runner"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "BAFTA Award for Best Editing"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "nominated for",
          "nominee"
        ]
      }
    ],
    "sample_id": "train_81282",
    "answer": "Terry Rawlings"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <E> Monroe County </E> whose <A> FIPS 6-4 (US counties) </A> is text <V> 18105 </V> </ES> whose <A> population </A> is <V> 140305 </V>",
    "kopl": "Find(Monroe County).FilterStr(FIPS 6-4 (US counties),18105).QueryAttrQualifier(population,140305,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Monroe County\" . ?e <FIPS_6-4_(US_counties)> ?pv_1 . ?pv_1 <pred:value> \"18105\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"140305\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Monroe County\" AND n1.population =  140305 )\nMATCH (n1) WHERE n1.FIPS_6-4_(US_counties) = \"18105\"\nRETURN .point_in_time",
    "question": "When did Monroe County (the one whose FIPS 6-4 (US counties) is 18105) have a population of 140305?",
    "cypher_match": "match (e:Resource{name:\"Monroe County\"})-[:`FIPS_6-4_(US_counties)`]->(pv_1:Resource{value:\"18105\"}) match (e:Resource{name:\"Monroe County\"})-[:population]->(pv:Resource{unit:\"1\",value:140305.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Monroe County"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "FIPS 6-4 (US counties)",
          "18105"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          1
        ],
        "inputs": [
          "population",
          "140305",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_4974",
    "answer": "2011-07-01"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <ES> <E> Shelby County </E> whose <A> population </A> is number <V> 42274 </V> </ES> or <ES> <E> Linn County </E> whose <A> population </A> is number <V> 211226 </V> </ES> </ES>",
    "kopl": "Find(Shelby County).FilterNum(population,42274,=).Find(Linn County).FilterNum(population,211226,=).Or().Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Shelby County\" . ?e <population> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> \"42274\"^^xsd:double . } UNION { ?e <pred:name> \"Linn County\" . ?e <population> ?pv_2 . ?pv_2 <pred:unit> \"1\" . ?pv_2 <pred:value> \"211226\"^^xsd:double . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Shelby_County ( string population ) ( string = ) ( number 42274 ) ) ( call SW.filter en.Linn_County ( string population ) ( string = ) ( number 211226 ) ) ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Shelby County\"\nMATCH (n1) WHERE n1.population =  42274 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Linn County\"\nMATCH (n1) WHERE n1.population =  211226 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which area is smaller, Shelby County (the one whose population is 42274) or Linn County (the one whose population is 211226)?",
    "cypher_match": "call { match (e:Resource{name:\"Shelby County\"})-[:population]->(pv_1:Resource{unit:\"1\",value:42274.0}) return e union match (e:Resource{name:\"Linn County\"})-[:population]->(pv_2:Resource{unit:\"1\",value:211226.0}) return e } match (e)-[:area]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Shelby County"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "42274",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Linn County"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          2
        ],
        "inputs": [
          "population",
          "211226",
          "="
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          3
        ],
        "inputs": [
          "area",
          "less"
        ]
      }
    ],
    "sample_id": "train_11269",
    "answer": "Shelby County"
  },
  {
    "graphq_ir": "how many <ES> <C> literary award </C> that <R> award received </R> backward to <E> Larry Niven </E> </ES>",
    "kopl": "Find(Larry Niven).Relate(award received,forward).FilterConcept(literary award).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"literary award\" . ?e_1 <award_received> ?e . ?e_1 <pred:name> \"Larry Niven\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.literary_award ) ( string ! type ) ) ( call SW.reverse ( string award_received ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Larry Niven\"\nMATCH (n1:literary_award)-[r1:award_received]->(n2)\nRETURN count(n1)",
    "question": "How many literary awards has Larry Niven been given?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"literary award\"}) match (e_1:Resource{name:\"Larry Niven\"})-[:award_received]->(e) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Larry Niven"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "literary award"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_793",
    "answer": "5"
  },
  {
    "graphq_ir": "what is the attribute <A> Twitter username </A> of <E> New York Islanders </E>",
    "kopl": "Find(New York Islanders).QueryAttr(Twitter username)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"New York Islanders\" . ?e <Twitter_username> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.New_York_Islanders ( string Twitter_username ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"New York Islanders\"\nRETURN n1.Twitter_username",
    "question": "What Twitter handle belongs to the New York Islanders?",
    "cypher_match": "match (e:Resource{name:\"New York Islanders\"})-[:Twitter_username]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "New York Islanders"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Twitter username"
        ]
      }
    ],
    "sample_id": "train_2830",
    "answer": "NYIslanders"
  },
  {
    "graphq_ir": "which one has the smallest <A> number of episodes </A> among <ES> <E> Thirtysomething </E> or <E> Brothers & Sisters </E> </ES>",
    "kopl": "Find(Thirtysomething).Find(Brothers & Sisters).Or().Select(number of episodes,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Thirtysomething\" .  } UNION { ?e <pred:name> \"Brothers & Sisters\" .  } ?e <number_of_episodes> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Thirtysomething en.Brothers_&_Sisters ) ( string min ) ( string number_of_episodes ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Thirtysomething\"\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Brothers & Sisters\"\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nLIMIT 1",
    "question": "Which one has less number of episodes between Thirtysomething and Brothers & Sisters?",
    "cypher_match": "call { match (e:Resource{name:\"Thirtysomething\"}) return e union match (e:Resource{name:\"Brothers & Sisters\"}) return e } match (e)-[:number_of_episodes]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Thirtysomething"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Brothers & Sisters"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "number of episodes",
          "less"
        ]
      }
    ],
    "sample_id": "train_16939",
    "answer": "Thirtysomething"
  },
  {
    "graphq_ir": "what is the qualifier <Q> number of subscribers </Q> of <E> Sichuan </E> whose <A> subreddit </A> is <V> sichuan </V>",
    "kopl": "Find(Sichuan).QueryAttrQualifier(subreddit,sichuan,number of subscribers)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Sichuan\" . ?e <subreddit> ?pv . ?pv <pred:value> \"sichuan\" . [ <pred:fact_h> ?e ; <pred:fact_r> <subreddit> ; <pred:fact_t> ?pv ] <number_of_subscribers> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Sichuan\" AND n1.subreddit =  sichuan )\nRETURN .number_of_subscribers",
    "question": "How many subscribers does Sichuan have on its subreddit sichuan?",
    "cypher_match": "match (e:Resource{name:\"Sichuan\"})-[:subreddit]->(pv:Resource{value:\"sichuan\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"subreddit\"}),(tmp)-[:number_of_subscribers]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sichuan"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          0
        ],
        "inputs": [
          "subreddit",
          "sichuan",
          "number of subscribers"
        ]
      }
    ],
    "sample_id": "train_55165",
    "answer": "17"
  },
  {
    "graphq_ir": "what is <ES> <C> film festival edition </C> that <R> follows </R> forward to <E> 2010 Sundance Film Festival </E> </ES>",
    "kopl": "Find(2010 Sundance Film Festival).Relate(follows,backward).FilterConcept(film festival edition).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film festival edition\" . ?e <follows> ?e_1 . ?e_1 <pred:name> \"2010 Sundance Film Festival\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.film_festival_edition ) ( string ! type ) ) ( string follows ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"2010 Sundance Film Festival\"\nMATCH (n1:film_festival_edition)<-[r1:follows]-(n2)\nRETURN n1.name",
    "question": "What number was the edition of the Sundance Film Festival after 2010?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film festival edition\"}) match (e)-[:follows]->(e_1:Resource{name:\"2010 Sundance Film Festival\"}) return distinct e",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "2010 Sundance Film Festival"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "follows",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film festival edition"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_61044",
    "answer": "2011 Sundance Film Festival"
  },
  {
    "graphq_ir": "what is the relation from <E> National Society of Film Critics Award for Best Actress </E> to <E> Elisabeth Shue </E>",
    "kopl": "Find(National Society of Film Critics Award for Best Actress).Find(Elisabeth Shue).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"National Society of Film Critics Award for Best Actress\" . ?e_2 <pred:name> \"Elisabeth Shue\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"National Society of Film Critics Award for Best Actress\"\nMATCH (n2) WHERE n2.name = \"Elisabeth Shue\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between National Society of Film Critics Award for Best Actress to Elisabeth Shue?",
    "cypher_match": "match (e_1:Resource{name:\"National Society of Film Critics Award for Best Actress\"})-[p]->(e_2:Resource{name:\"Elisabeth Shue\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "National Society of Film Critics Award for Best Actress"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Elisabeth Shue"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_88825",
    "answer": "winner"
  },
  {
    "graphq_ir": "what is the relation from <E> Aidan Gillen </E> to <E> Dublin </E>",
    "kopl": "Find(Aidan Gillen).Find(Dublin).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Aidan Gillen\" . ?e_2 <pred:name> \"Dublin\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Aidan Gillen\"\nMATCH (n2) WHERE n2.name = \"Dublin\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Aidan Gillen to Dublin?",
    "cypher_match": "match (e_1:Resource{name:\"Aidan Gillen\"})-[p]->(e_2:Resource{name:\"Dublin\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Aidan Gillen"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dublin"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_76947",
    "answer": "place of birth"
  },
  {
    "graphq_ir": "which one has the largest <A> number of episodes </A> among <ES> <C> comedy </C> that <R> genre </R> forward to <E> situation comedy </E> </ES>",
    "kopl": "Find(situation comedy).Relate(genre,backward).FilterConcept(comedy).Select(number of episodes,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"comedy\" . ?e <genre> ?e_1 . ?e_1 <pred:name> \"situation comedy\" .  ?e <number_of_episodes> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.comedy ) ( string ! type ) ) ( string genre ) ) ( string max ) ( string number_of_episodes ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"situation comedy\"\nMATCH (n1:comedy)<-[r1:genre]-(n2)\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nLIMIT 1",
    "question": "Of all the comedies in the situation comedy genre, which was the most episodes?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"comedy\"}) match (e)-[:genre]->(e_1:Resource{name:\"situation comedy\"}) match (e)-[:number_of_episodes]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "situation comedy"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "genre",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "comedy"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "number of episodes",
          "largest"
        ]
      }
    ],
    "sample_id": "train_3112",
    "answer": "The Golden Girls"
  },
  {
    "graphq_ir": "which one has the smallest <A> height </A> among <ES> <ES> <E> Stephen Graham </E> whose <A> mass </A> is number <V> 98 kilogram </V> </ES> or <E> Jermaine Easter </E> </ES>",
    "kopl": "Find(Stephen Graham).FilterNum(mass,98 kilogram,=).Find(Jermaine Easter).Or().Select(height,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Stephen Graham\" . ?e <mass> ?pv_1 . ?pv_1 <pred:unit> \"kilogram\" . ?pv_1 <pred:value> \"98\"^^xsd:double . } UNION { ?e <pred:name> \"Jermaine Easter\" . } ?e <height> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Stephen_Graham ( string mass ) ( string = ) ( number 98 kilogram ) ) en.Jermaine_Easter ) ( string min ) ( string height ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Stephen Graham\"\nMATCH (n1) WHERE n1.mass =  98 kilogram \nRETURN n1.name AS name\nORDER BY n1.height DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Jermaine Easter\"\nRETURN n1.name AS name\nORDER BY n1.height DESC\nLIMIT 1",
    "question": "Who is shorter, Stephen Graham (the one whose mass is 98 kilogram) or Jermaine Easter?",
    "cypher_match": "call { match (e:Resource{name:\"Stephen Graham\"})-[:mass]->(pv_1:Resource{unit:\"kilogram\",value:98.0}) return e union match (e:Resource{name:\"Jermaine Easter\"}) return e } match (e)-[:height]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Stephen Graham"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "mass",
          "98 kilogram",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jermaine Easter"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "height",
          "less"
        ]
      }
    ],
    "sample_id": "train_82193",
    "answer": "Jermaine Easter"
  },
  {
    "graphq_ir": "what is the attribute <A> IPTC Newscode </A> of <E> mountain biking </E>",
    "kopl": "Find(mountain biking).QueryAttr(IPTC Newscode)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"mountain biking\" . ?e <IPTC_Newscode> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.mountain_biking ( string IPTC_Newscode ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"mountain biking\"\nRETURN n1.IPTC_Newscode",
    "question": "What is the IPTC Newscode for mountainbiking?",
    "cypher_match": "match (e:Resource{name:\"mountain biking\"})-[:IPTC_Newscode]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "mountain biking"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "IPTC Newscode"
        ]
      }
    ],
    "sample_id": "train_16272",
    "answer": "mediatopic/20000903"
  },
  {
    "graphq_ir": "what is the qualifier <Q> number of subscribers </Q> of <ES> <C> human </C> whose <A> birth name </A> is text <V> Richard Melville Hall </V> </ES> whose <A> Twitter username </A> is <V> thelittleidiot </V>",
    "kopl": "FindAll().FilterStr(birth name,Richard Melville Hall).FilterConcept(human).QueryAttrQualifier(Twitter username,thelittleidiot,number of subscribers)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <birth_name> ?pv_1 . ?pv_1 <pred:value> \"Richard Melville Hall\" . ?e <Twitter_username> ?pv . ?pv <pred:value> \"thelittleidiot\" . [ <pred:fact_h> ?e ; <pred:fact_r> <Twitter_username> ; <pred:fact_t> ?pv ] <number_of_subscribers> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:human) WHERE (n1.birth_name = \"Richard Melville Hall\" AND n1.Twitter_username =  thelittleidiot )\nRETURN .number_of_subscribers",
    "question": "How many subscribe to thelittleidiot, the Twitter handle of the person born as Richard Melville Hall?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:birth_name]->(pv_1:Resource{value:\"Richard Melville Hall\"}) match (e)-[:Twitter_username]->(pv:Resource{value:\"thelittleidiot\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"Twitter_username\"}),(tmp)-[:number_of_subscribers]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "birth name",
          "Richard Melville Hall"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "Twitter username",
          "thelittleidiot",
          "number of subscribers"
        ]
      }
    ],
    "sample_id": "train_83443",
    "answer": "1349252"
  },
  {
    "graphq_ir": "what is the qualifier <Q> character role </Q> of <ES> <E> Harry Potter and the Chamber of Secrets </E> whose <A> publication date </A> is date <V> 2002-11-14 </V> </ES> that <R> cast member </R> to <E> Toby Jones </E>",
    "kopl": "Find(Harry Potter and the Chamber of Secrets).FilterDate(publication date,2002-11-14,=).Find(Toby Jones).QueryRelationQualifier(cast member,character role)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Harry Potter and the Chamber of Secrets\" . ?e_1 <publication_date> ?pv . ?pv <pred:date> \"2002-11-14\"^^xsd:date . ?e_2 <pred:name> \"Toby Jones\" . ?e_1 <cast_member> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <cast_member> ; <pred:fact_t> ?e_2 ] <character_role> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Harry Potter and the Chamber of Secrets\"\nMATCH (n1) WHERE n1.publication_date =  2002-11-14 \nMATCH (n2) WHERE n2.name = \"Toby Jones\"\nMATCH (n1)-[r1:cast_member]->(n2)\nRETURN r1.character_role",
    "question": "What is cast-mate Toby Jones' role on Harry Potter and the Chamber of Secrets, released on 2002-11-14?",
    "cypher_match": "match (e_1:Resource{name:\"Harry Potter and the Chamber of Secrets\"})-[:publication_date]->(pv:Resource{date:Date(\"2002-11-14\")}) match (e_1:Resource{name:\"Harry Potter and the Chamber of Secrets\"})-[:cast_member]->(e_2:Resource{name:\"Toby Jones\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"cast_member\"}),(tmp)-[:character_role]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Harry Potter and the Chamber of Secrets"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "publication date",
          "2002-11-14",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Toby Jones"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "cast member",
          "character role"
        ]
      }
    ],
    "sample_id": "train_81357",
    "answer": "Dobby"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Law & Order </E> (<ES> ones that <R> nominated for </R> forward to <E> Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series </E> </ES>) </ES> to <E> police procedural </E>",
    "kopl": "Find(Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series).Relate(nominated for,backward).Find(Law & Order).And().Find(police procedural).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Law & Order\" . ?e_1 <nominated_for> ?e_3 . ?e_3 <pred:name> \"Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series\" . ?e_2 <pred:name> \"police procedural\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Law & Order\"\nMATCH (n2) WHERE n2.name = \"Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series\"\nMATCH (n3)<-[r1:nominated_for]-(n2)\nMATCH (n4) WHERE n4.name = \"police procedural\"\nMATCH (n3)-[r2]->(n4)\nRETURN r2.label",
    "question": "What is the connection between Law & Order, nominated for a Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series, and police procedurals?",
    "cypher_match": "match (e_1:Resource{name:\"Law & Order\"})-[:nominated_for]->(e_3:Resource{name:\"Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series\"}) match (e_1:Resource{name:\"Law & Order\"})-[p]->(e_2:Resource{name:\"police procedural\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Law & Order"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "police procedural"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_34245",
    "answer": "genre"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> county of North Carolina </C> that <R> named after </R> forward to <ES> <E> James Madison </E> (<ES> ones that <R> member of political party </R> forward to <E> Democratic-Republican Party </E> </ES>) </ES> </ES> whose <A> population </A> is <V> 21022 </V>",
    "kopl": "Find(Democratic-Republican Party).Relate(member of political party,backward).Find(James Madison).And().Relate(named after,backward).FilterConcept(county of North Carolina).QueryAttrQualifier(population,21022,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of North Carolina\" . ?e <named_after> ?e_1 . ?e_1 <pred:name> \"James Madison\" . ?e_1 <member_of_political_party> ?e_2 . ?e_2 <pred:name> \"Democratic-Republican Party\" .  ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"21022\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"James Madison\"\nMATCH (n3) WHERE n3.name = \"Democratic-Republican Party\"\nMATCH (n4)<-[r2:member_of_political_party]-(n3)\nMATCH (n1:county_of_North_Carolina)<-[r1:named_after]-(n4) WHERE n1.population =  21022 \nRETURN r1.point_in_time",
    "question": "When did a county of North Carolina, named after James Madison (the one that is the member of political party Democratic-Republican Party), reach the population of 21,022 people ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"county of North Carolina\"}) match (e)-[:named_after]->(e_1:Resource{name:\"James Madison\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:21022.0}) match (e_1:Resource{name:\"James Madison\"})-[:member_of_political_party]->(e_2:Resource{name:\"Democratic-Republican Party\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Democratic-Republican Party"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "member of political party",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "James Madison"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "named after",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "county of North Carolina"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          5
        ],
        "inputs": [
          "population",
          "21022",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_17604",
    "answer": "2013-07-01"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> bowed string instrument </C> whose <A> Hornbostel-Sachs classification </A> is text <V> 321.322-71 </V> </ES> or <ES> <C> bowed string instrument </C> that <R> instrument </R> backward to <E> John Hartford </E> </ES> </ES>",
    "kopl": "FindAll().FilterStr(Hornbostel-Sachs classification,321.322-71).FilterConcept(bowed string instrument).Find(John Hartford).Relate(instrument,forward).FilterConcept(bowed string instrument).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"bowed string instrument\" .  { ?e <Hornbostel-Sachs_classification> ?pv . ?pv <pred:value> \"321.322-71\" .  } UNION { ?e_1 <instrument> ?e . ?e_1 <pred:name> \"John Hartford\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.bowed_string_instrument ) ( string ! type ) ) ( string Hornbostel-Sachs_classification ) ( string = ) ( string 321.322-71 ) ) ( call SW.filter ( getProperty ( singleton en.bowed_string_instrument ) ( string ! type ) ) ( call SW.reverse ( string instrument ) ) ) ) ) )",
    "cypher": "MATCH (n1:bowed_string_instrument) WHERE n1.Hornbostel-Sachs_classification = \"321.322-71\"\nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"John Hartford\"\nMATCH (n1:bowed_string_instrument)-[r1:instrument]->(n2)\nRETURN count(n1)",
    "question": "How many bowed string instruments do we know Hornbostel-Sachs classification is 321.322-71 or that are the instrument used by John Hartford?",
    "cypher_match": "call { match (e)-[:`Hornbostel-Sachs_classification`]->(pv:Resource{value:\"321.322-71\"}) return e union match (e_1:Resource{name:\"John Hartford\"})-[:instrument]->(e) return e } match (e)-[:instance_of]->(c:Resource{name:\"bowed string instrument\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Hornbostel-Sachs classification",
          "321.322-71"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "bowed string instrument"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "John Hartford"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "instrument",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "bowed string instrument"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_81502",
    "answer": "4"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0000 6310 5556 </V> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0000 6310 5556).FilterConcept(human).QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv_1 . ?pv_1 <pred:value> \"0000 0000 6310 5556\" . ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0000 6310 5556 ) ) ( string official_website ) ) )",
    "cypher": "MATCH (n1:human) WHERE n1.ISNI = \"0000 0000 6310 5556\"\nRETURN n1.official_website",
    "question": "What is the official website of the person with ISNI 0000 0000 6310 5556?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv_1:Resource{value:\"0000 0000 6310 5556\"}) match (e)-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0000 6310 5556"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_70544",
    "answer": "http://www.gwenstefani.com"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <ES> <C> association football club </C> whose <A> Twitter username </A> is text <V> FGRFC_Official </V> </ES>",
    "kopl": "FindAll().FilterStr(Twitter username,FGRFC_Official).FilterConcept(association football club).QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"association football club\" . ?e <Twitter_username> ?pv_1 . ?pv_1 <pred:value> \"FGRFC_Official\" . ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.association_football_club ) ( string ! type ) ) ( string Twitter_username ) ( string = ) ( string FGRFC_Official ) ) ( string official_website ) ) )",
    "cypher": "MATCH (n1:association_football_club) WHERE n1.Twitter_username = \"FGRFC_Official\"\nRETURN n1.official_website",
    "question": "Regarding the association football club that have the Twitter username of FGRFC_Official tell me its official website",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"association football club\"}) match (e)-[:Twitter_username]->(pv_1:Resource{value:\"FGRFC_Official\"}) match (e)-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Twitter username",
          "FGRFC_Official"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "association football club"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_60928",
    "answer": "https://www.fgr.co.uk/"
  },
  {
    "graphq_ir": "what is the qualifier <Q> language of work or name </Q> of <ES> <C> television channel </C> whose <A> inception </A> is year <V> 2008 </V> </ES> whose <A> official website </A> is <V> http://www.metvnetwork.com </V>",
    "kopl": "FindAll().FilterYear(inception,2008,=).FilterConcept(television channel).QueryAttrQualifier(official website,http://www.metvnetwork.com,language of work or name)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"television channel\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> 2008 . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.metvnetwork.com\" . [ <pred:fact_h> ?e ; <pred:fact_r> <official_website> ; <pred:fact_t> ?pv ] <language_of_work_or_name> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:television_channel) WHERE (n1.inception =  2008  AND n1.official_website =  http://www.metvnetwork.com )\nRETURN .language_of_work_or_name",
    "question": "For the television channel whose inception time is in 2008, what is the language associated with this creative work for its official website of http://www.metvnetwork.com?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"television channel\"}) match (e)-[:inception]->(pv_1:Resource{year:2008}) match (e)-[:official_website]->(pv:Resource{value:\"http://www.metvnetwork.com\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"official_website\"}),(tmp)-[:language_of_work_or_name]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "inception",
          "2008",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "television channel"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website",
          "http://www.metvnetwork.com",
          "language of work or name"
        ]
      }
    ],
    "sample_id": "train_27934",
    "answer": "English"
  },
  {
    "graphq_ir": "what is the relation from <E> 16 Blocks </E> to <E> Klaus Badelt </E>",
    "kopl": "Find(16 Blocks).Find(Klaus Badelt).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"16 Blocks\" . ?e_2 <pred:name> \"Klaus Badelt\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"16 Blocks\"\nMATCH (n2) WHERE n2.name = \"Klaus Badelt\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is 16 Blocks related to Klaus Badelt?",
    "cypher_match": "match (e_1:Resource{name:\"16 Blocks\"})-[p]->(e_2:Resource{name:\"Klaus Badelt\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "16 Blocks"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Klaus Badelt"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_48486",
    "answer": "composer"
  },
  {
    "graphq_ir": "which one has the largest <A> number of children </A> among <ES> <ES> <E> Mark Williams </E> (<ES> ones that <R> winner </R> backward to <E> Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture </E> </ES>) </ES> or <ES> <E> Jon Favreau </E> (<ES> ones that <R> occupation </R> forward to <E> screenwriter </E> </ES>) </ES> </ES>",
    "kopl": "Find(Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture).Relate(winner,forward).Find(Mark Williams).And().Find(screenwriter).Relate(occupation,backward).Find(Jon Favreau).And().Or().Select(number of children,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Mark Williams\" . ?e_1 <winner> ?e . ?e_1 <pred:name> \"Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture\" .   } UNION { ?e <pred:name> \"Jon Favreau\" . ?e <occupation> ?e_2 . ?e_2 <pred:name> \"screenwriter\" .  } ?e <number_of_children> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.Mark_Williams ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string winner ) ) ( string = ) en.Screen_Actors_Guild_Award_for_Outstanding_Performance_by_a_Cast_in_a_Motion_Picture ) ) ) ( call SW.and en.Jon_Favreau ( lambda s ( call SW.filter ( var s ) ( string occupation ) ( string = ) en.screenwriter ) ) ) ) ( string max ) ( string number_of_children ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Mark Williams\"\nMATCH (n2) WHERE n2.name = \"Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture\"\nMATCH (n3)-[r1:winner]->(n2)\nRETURN n3.name AS name\nORDER BY n3.number_of_children DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Jon Favreau\"\nMATCH (n2) WHERE n2.name = \"screenwriter\"\nMATCH (n3)<-[r1:occupation]-(n2)\nRETURN n3.name AS name\nORDER BY n3.number_of_children DESC\nLIMIT 1",
    "question": "Who has more children, Mark Williams (the one that wins Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture) or Jon Favreau (the one that has the occupation of screenwriter)?",
    "cypher_match": "call { match (e_1:Resource{name:\"Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture\"})-[:winner]->(e:Resource{name:\"Mark Williams\"}) return e union match (e:Resource{name:\"Jon Favreau\"})-[:occupation]->(e_2:Resource{name:\"screenwriter\"}) return e } match (e)-[:number_of_children]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "winner",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Mark Williams"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "screenwriter"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          4
        ],
        "inputs": [
          "occupation",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jon Favreau"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          5,
          6
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          7
        ],
        "inputs": [
          "number of children",
          "greater"
        ]
      }
    ],
    "sample_id": "train_79231",
    "answer": "Jon Favreau"
  },
  {
    "graphq_ir": "what is the qualifier <Q> number of matches played/races/starts </Q> of <E> Chris Nurse </E> that <R> member of sports team </R> to <E> Fort Lauderdale Strikers </E>",
    "kopl": "Find(Chris Nurse).Find(Fort Lauderdale Strikers).QueryRelationQualifier(member of sports team,number of matches played/races/starts)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Chris Nurse\" . ?e_2 <pred:name> \"Fort Lauderdale Strikers\" . ?e_1 <member_of_sports_team> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <member_of_sports_team> ; <pred:fact_t> ?e_2 ] <number_of_matches_played/races/starts> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Chris Nurse\"\nMATCH (n2) WHERE n2.name = \"Fort Lauderdale Strikers\"\nMATCH (n1)-[r1:member_of_sports_team]->(n2)\nRETURN r1.number_of_matches_played/races/starts",
    "question": "Chris Nurse had how many match appearances as a member of the Fort Lauderdale Strikers?",
    "cypher_match": "match (e_1:Resource{name:\"Chris Nurse\"})-[:member_of_sports_team]->(e_2:Resource{name:\"Fort Lauderdale Strikers\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"member_of_sports_team\"}),(tmp)-[:`number_of_matches_played/races/starts`]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Chris Nurse"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Fort Lauderdale Strikers"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "member of sports team",
          "number of matches played/races/starts"
        ]
      }
    ],
    "sample_id": "train_64111",
    "answer": "16"
  },
  {
    "graphq_ir": "what is the qualifier <Q> place of publication </Q> of <ES> <C> visual artwork </C> whose <A> official website </A> is text <V> https://www.warnerbros.com/matrix </V> </ES> whose <A> publication date </A> is <V> 1999-07-14 </V>",
    "kopl": "FindAll().FilterStr(official website,https://www.warnerbros.com/matrix).FilterConcept(visual artwork).QueryAttrQualifier(publication date,1999-07-14,place of publication)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <official_website> ?pv_1 . ?pv_1 <pred:value> \"https://www.warnerbros.com/matrix\" . ?e <publication_date> ?pv . ?pv <pred:date> \"1999-07-14\"^^xsd:date . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:visual_artwork) WHERE (n1.official_website = \"https://www.warnerbros.com/matrix\" AND n1.publication_date =  1999-07-14 )\nRETURN .place_of_publication",
    "question": "Where was the visual artwork with official website as https://www.warnerbros.com/matrix, published on 1999-07-14",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:official_website]->(pv_1:Resource{value:\"https://www.warnerbros.com/matrix\"}) match (e)-[:publication_date]->(pv:Resource{date:Date(\"1999-07-14\")}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "https://www.warnerbros.com/matrix"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "publication date",
          "1999-07-14",
          "place of publication"
        ]
      }
    ],
    "sample_id": "train_17101",
    "answer": "Sweden"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> cast member </R> backward to <ES> <E> Some Like It Hot </E> (<ES> ones that <R> distributor </R> forward to <E> Paramount Pictures </E> </ES>) </ES> </ES> <A> CANTIC-ID </A> is text <V> a11051796 </V>",
    "kopl": "Find(Paramount Pictures).Relate(distributor,backward).Find(Some Like It Hot).And().Relate(cast member,forward).FilterConcept(human).QueryAttr(CANTIC-ID).VerifyStr(a11051796)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e_1 <cast_member> ?e . ?e_1 <pred:name> \"Some Like It Hot\" . ?e_1 <distributor> ?e_2 . ?e_2 <pred:name> \"Paramount Pictures\" .  ?e <CANTIC-ID> ?pv . ?pv <pred:value> \"a11051796\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"Some Like It Hot\"\nMATCH (n3) WHERE n3.name = \"Paramount Pictures\"\nMATCH (n4)<-[r2:distributor]-(n3)\nMATCH (n1:human)-[r1:cast_member]->(n4) WHERE n1.CANTIC-ID = \"a11051796\"\nRETURN isEmpty(n1)",
    "question": "Does the person who is a cast member of Some Like It Hot (the one whose distributor is Paramount Pictures), have a CANTIC-ID equal to a11051796?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:`CANTIC-ID`]->(pv:Resource) match (e_1:Resource{name:\"Some Like It Hot\"})-[:cast_member]->(e) match (e_1:Resource{name:\"Some Like It Hot\"})-[:distributor]->(e_2:Resource{name:\"Paramount Pictures\"}) return pv.value = \"a11051796\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Paramount Pictures"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "distributor",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Some Like It Hot"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "cast member",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          5
        ],
        "inputs": [
          "CANTIC-ID"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          6
        ],
        "inputs": [
          "a11051796"
        ]
      }
    ],
    "sample_id": "train_82950",
    "answer": "yes"
  },
  {
    "graphq_ir": "which one has the smallest <A> duration </A> among <ES> <ES> <E> Speed </E> (<ES> ones that <R> award received </R> forward to <E> Academy Award for Best Sound Mixing </E> </ES>) </ES> or <ES> <E> Star Wars: The Clone Wars </E> (<ES> ones that <R> production company </R> forward to <E> Warner Bros. </E> </ES>) </ES> </ES>",
    "kopl": "Find(Academy Award for Best Sound Mixing).Relate(award received,backward).Find(Speed).And().Find(Warner Bros.).Relate(production company,backward).Find(Star Wars: The Clone Wars).And().Or().Select(duration,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Speed\" . ?e <award_received> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Sound Mixing\" .   } UNION { ?e <pred:name> \"Star Wars: The Clone Wars\" . ?e <production_company> ?e_2 . ?e_2 <pred:name> \"Warner Bros.\" .  } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.Speed ( lambda s ( call SW.filter ( var s ) ( string award_received ) ( string = ) en.Academy_Award_for_Best_Sound_Mixing ) ) ) ( call SW.and en.Star_Wars:_The_Clone_Wars ( lambda s ( call SW.filter ( var s ) ( string production_company ) ( string = ) en.Warner_Bros. ) ) ) ) ( string min ) ( string duration ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Speed\"\nMATCH (n2) WHERE n2.name = \"Academy Award for Best Sound Mixing\"\nMATCH (n3)<-[r1:award_received]-(n2)\nRETURN n3.name AS name\nORDER BY n3.duration DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Star Wars: The Clone Wars\"\nMATCH (n2) WHERE n2.name = \"Warner Bros.\"\nMATCH (n3)<-[r1:production_company]-(n2)\nRETURN n3.name AS name\nORDER BY n3.duration DESC\nLIMIT 1",
    "question": "Which movie is shorter, Speed (the one that received Academy Award for Best Sound Mixing) or Star Wars: The Clone Wars (the one whose production company is Warner Bros.)?",
    "cypher_match": "call { match (e:Resource{name:\"Speed\"})-[:award_received]->(e_1:Resource{name:\"Academy Award for Best Sound Mixing\"}) return e union match (e:Resource{name:\"Star Wars: The Clone Wars\"})-[:production_company]->(e_2:Resource{name:\"Warner Bros.\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Sound Mixing"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Speed"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Warner Bros."
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          4
        ],
        "inputs": [
          "production company",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Star Wars: The Clone Wars"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          5,
          6
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          7
        ],
        "inputs": [
          "duration",
          "less"
        ]
      }
    ],
    "sample_id": "train_62671",
    "answer": "Star Wars: The Clone Wars"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <C> county of New York </C> whose <A> inception </A> larger than year <V> 1791 </V> </ES>",
    "kopl": "FindAll().FilterYear(inception,1791,>).FilterConcept(county of New York).Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of New York\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> ?v_1 . FILTER ( ?v_1 > 1791 ) . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.county_of_New_York ) ( string ! type ) ) ( string inception ) ( string > ) ( year 1791 ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1:county_of_New_York) WHERE n1.inception >  1791 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Tell me the one with the biggest area within the New York county that has an inception time after 1791.",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"county of New York\"}) match (e)-[:inception]->(pv_1) match (e)-[:area]->(pv) where pv_1.year > 1791 return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "inception",
          "1791",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "county of New York"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "largest"
        ]
      }
    ],
    "sample_id": "train_75902",
    "answer": "St. Lawrence County"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> miniseries </C> that <R> after a work by </R> forward to <E> Charles Dickens </E> </ES> or <ES> <C> miniseries </C> that <R> main subject </R> forward to <E> World War II </E> </ES> </ES>",
    "kopl": "Find(Charles Dickens).Relate(after a work by,backward).FilterConcept(miniseries).Find(World War II).Relate(main subject,backward).FilterConcept(miniseries).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"miniseries\" .  { ?e <after_a_work_by> ?e_1 . ?e_1 <pred:name> \"Charles Dickens\" .  } UNION { ?e <main_subject> ?e_1 . ?e_1 <pred:name> \"World War II\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.miniseries ) ( string ! type ) ) ( string after_a_work_by ) ) ( call SW.filter ( getProperty ( singleton en.miniseries ) ( string ! type ) ) ( string main_subject ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Charles Dickens\"\nMATCH (n1:miniseries)<-[r1:after_a_work_by]-(n2)\nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"World War II\"\nMATCH (n1:miniseries)<-[r1:main_subject]-(n2)\nRETURN count(n1)",
    "question": "How many miniseries are written by Charles Dickens or mainly depict World War II?",
    "cypher_match": "call { match (e)-[:after_a_work_by]->(e_1:Resource{name:\"Charles Dickens\"}) return e union match (e)-[:main_subject]->(e_1:Resource{name:\"World War II\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"miniseries\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Charles Dickens"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "after a work by",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "miniseries"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "World War II"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "main subject",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "miniseries"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_20884",
    "answer": "6"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> religion </C> whose <A> Universal Decimal Classification </A> is text <V> 141.45 </V> </ES> or <ES> <C> religion </C> whose <A> ISNI </A> is text <V> 0000 0004 0508 6616 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(Universal Decimal Classification,141.45).FilterConcept(religion).FindAll().FilterStr(ISNI,0000 0004 0508 6616).FilterConcept(religion).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"religion\" .  { ?e <Universal_Decimal_Classification> ?pv . ?pv <pred:value> \"141.45\" .  } UNION { ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0004 0508 6616\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.religion ) ( string ! type ) ) ( string Universal_Decimal_Classification ) ( string = ) ( string 141.45 ) ) ( call SW.filter ( getProperty ( singleton en.religion ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0004 0508 6616 ) ) ) ) )",
    "cypher": "MATCH (n1:religion) WHERE n1.Universal_Decimal_Classification = \"141.45\"\nRETURN count(n1)\nUNION\nMATCH (n1:religion) WHERE n1.ISNI = \"0000 0004 0508 6616\"\nRETURN count(n1)",
    "question": "What is the number of religions that have Universal Decimal Classification is 141.45 or whose ISNI is 0000 0004 0508 6616",
    "cypher_match": "call { match (e)-[:Universal_Decimal_Classification]->(pv:Resource{value:\"141.45\"}) return e union match (e)-[:ISNI]->(pv:Resource{value:\"0000 0004 0508 6616\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"religion\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Universal Decimal Classification",
          "141.45"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "religion"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI",
          "0000 0004 0508 6616"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "religion"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_35266",
    "answer": "2"
  },
  {
    "graphq_ir": "what is the attribute <A> population </A> of <ES> <C> city </C> that <R> twinned administrative body </R> backward to <E> Tijuana </E> </ES>",
    "kopl": "Find(Tijuana).Relate(twinned administrative body,forward).FilterConcept(city).QueryAttr(population)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city\" . ?e_1 <twinned_administrative_body> ?e . ?e_1 <pred:name> \"Tijuana\" .  ?e <population> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.city ) ( string ! type ) ) ( call SW.reverse ( string twinned_administrative_body ) ) ) ( string population ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Tijuana\"\nMATCH (n1:city)-[r1:twinned_administrative_body]->(n2)\nRETURN n1.population",
    "question": "What is the population of the city that is twinned with Tijuana?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city\"}) match (e)-[:population]->(pv) match (e_1:Resource{name:\"Tijuana\"})-[:twinned_administrative_body]->(e) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tijuana"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "twinned administrative body",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "population"
        ]
      }
    ],
    "sample_id": "train_14379",
    "answer": "2141652"
  },
  {
    "graphq_ir": "what is <ES> <C> visual artwork </C> that <R> producer </R> forward to <E> Werner Herzog </E> </ES>",
    "kopl": "Find(Werner Herzog).Relate(producer,backward).FilterConcept(visual artwork).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <producer> ?e_1 . ?e_1 <pred:name> \"Werner Herzog\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.visual_artwork ) ( string ! type ) ) ( string producer ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Werner Herzog\"\nMATCH (n1:visual_artwork)<-[r1:producer]-(n2)\nRETURN n1.name",
    "question": "What visual artwork was produced by Werner Herzog?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:producer]->(e_1:Resource{name:\"Werner Herzog\"}) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Werner Herzog"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "producer",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_56711",
    "answer": "Invincible"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> composer </R> backward to <ES> <E> The Phantom of the Opera </E> (<ES> ones that <R> original language of film or TV show </R> forward to <E> Italian </E> </ES>) </ES> </ES> <A> CANTIC-ID </A> is text <V> a10445444 </V>",
    "kopl": "Find(Italian).Relate(original language of film or TV show,backward).Find(The Phantom of the Opera).And().Relate(composer,forward).FilterConcept(human).QueryAttr(CANTIC-ID).VerifyStr(a10445444)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e_1 <composer> ?e . ?e_1 <pred:name> \"The Phantom of the Opera\" . ?e_1 <original_language_of_film_or_TV_show> ?e_2 . ?e_2 <pred:name> \"Italian\" .  ?e <CANTIC-ID> ?pv . ?pv <pred:value> \"a10445444\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"The Phantom of the Opera\"\nMATCH (n3) WHERE n3.name = \"Italian\"\nMATCH (n4)<-[r2:original_language_of_film_or_TV_show]-(n3)\nMATCH (n1:human)-[r1:composer]->(n4) WHERE n1.CANTIC-ID = \"a10445444\"\nRETURN isEmpty(n1)",
    "question": "Does the person who composed The Phantom of the Opera (the one whose original language is Italian) have a CANTIC-ID of a10445444?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:`CANTIC-ID`]->(pv:Resource) match (e_1:Resource{name:\"The Phantom of the Opera\"})-[:composer]->(e) match (e_1:Resource{name:\"The Phantom of the Opera\"})-[:original_language_of_film_or_TV_show]->(e_2:Resource{name:\"Italian\"}) return pv.value = \"a10445444\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Italian"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "original language of film or TV show",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Phantom of the Opera"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "composer",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          5
        ],
        "inputs": [
          "CANTIC-ID"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          6
        ],
        "inputs": [
          "a10445444"
        ]
      }
    ],
    "sample_id": "train_58598",
    "answer": "no"
  },
  {
    "graphq_ir": "what is <ES> <C> city of the United States </C> whose <A> local dialing code </A> is text <V> 480 602 </V> </ES>",
    "kopl": "FindAll().FilterStr(local dialing code,480 602).FilterConcept(city of the United States).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <local_dialing_code> ?pv . ?pv <pred:value> \"480 602\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.city_of_the_United_States ) ( string ! type ) ) ( string local_dialing_code ) ( string = ) ( string 480 602 ) ) )",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE n1.local_dialing_code = \"480 602\"\nRETURN n1.name",
    "question": "What United States city has the local dialing code 480 602?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:local_dialing_code]->(pv:Resource{value:\"480 602\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "local dialing code",
          "480 602"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_32553",
    "answer": "Mesa"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> sovereign state </C> whose <A> Human Development Index </A> smaller than number <V> 1.0 </V> </ES> or <ES> <C> sovereign state </C> whose <A> area </A> larger than number <V> 45 square versta </V> </ES> </ES>",
    "kopl": "FindAll().FilterNum(Human Development Index,1.0,<).FilterConcept(sovereign state).FindAll().FilterNum(area,45 square versta,>).FilterConcept(sovereign state).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"sovereign state\" .  { ?e <Human_Development_Index> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v < \"1.0\"^^xsd:double ) .  } UNION { ?e <area> ?pv . ?pv <pred:unit> \"square versta\" . ?pv <pred:value> ?v . FILTER ( ?v > \"45\"^^xsd:double ) .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.sovereign_state ) ( string ! type ) ) ( string Human_Development_Index ) ( string < ) ( number 1.0 ) ) ( call SW.filter ( getProperty ( singleton en.sovereign_state ) ( string ! type ) ) ( string area ) ( string > ) ( number 45 square versta ) ) ) ) )",
    "cypher": "MATCH (n1:sovereign_state) WHERE n1.Human_Development_Index <  1.0 \nRETURN count(n1)\nUNION\nMATCH (n1:sovereign_state) WHERE n1.area >  45 square versta \nRETURN count(n1)",
    "question": "How many sovereign states have a Human Development Index value below 1.0 or occupy more than 45 square verstas?",
    "cypher_match": "call { match (e)-[:Human_Development_Index]->(pv:Resource{unit:\"1\"})  where pv.value <  1.0  return e union match (e)-[:area]->(pv:Resource{unit:\"square versta\"})  where pv.value >  45.0  return e } match (e)-[:instance_of]->(c:Resource{name:\"sovereign state\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "Human Development Index",
          "1.0",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "area",
          "45 square versta",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_10863",
    "answer": "123"
  },
  {
    "graphq_ir": "which one has the largest <A> cost </A> among <ES> <ES> <E> Die Another Day </E> whose <A> title </A> is text <V> Die Another Day </V> </ES> or <ES> <E> Halloween </E> (<ES> ones that <R> film release region </R> forward to <E> Italy </E> </ES>) </ES> </ES>",
    "kopl": "Find(Die Another Day).FilterStr(title,Die Another Day).Find(Italy).Relate(film release region,backward).Find(Halloween).And().Or().Select(cost,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Die Another Day\" . ?e <title> ?pv_1 . ?pv_1 <pred:value> \"Die Another Day\" . } UNION { ?e <pred:name> \"Halloween\" . ?e <film_release_region> ?e_1 . ?e_1 <pred:name> \"Italy\" . } ?e <cost> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Die_Another_Day ( string title ) ( string = ) ( string Die Another Day ) ) ( call SW.and en.Halloween ( lambda s ( call SW.filter ( var s ) ( string film_release_region ) ( string = ) en.Italy ) ) ) ) ( string max ) ( string cost ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Die Another Day\"\nMATCH (n1) WHERE n1.title = \"Die Another Day\"\nRETURN n1.name AS name\nORDER BY n1.cost DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Halloween\"\nMATCH (n2) WHERE n2.name = \"Italy\"\nMATCH (n3)<-[r1:film_release_region]-(n2)\nRETURN n3.name AS name\nORDER BY n1.cost DESC\nLIMIT 1",
    "question": "Which cost more, Die Another Day, which was titled Die Another Day, or Halloween that was released in Italy?",
    "cypher_match": "call { match (e:Resource{name:\"Die Another Day\"})-[:title]->(pv_1:Resource{value:\"Die Another Day\"}) return e union match (e:Resource{name:\"Halloween\"})-[:film_release_region]->(e_1:Resource{name:\"Italy\"}) return e } match (e)-[:cost]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Die Another Day"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "Die Another Day"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Italy"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "film release region",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Halloween"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          5
        ],
        "inputs": [
          "cost",
          "greater"
        ]
      }
    ],
    "sample_id": "train_19945",
    "answer": "Die Another Day"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> MTV Movie Award for Most Desirable Female </E> that <R> winner </R> to <E> Janet Jackson </E>",
    "kopl": "Find(MTV Movie Award for Most Desirable Female).Find(Janet Jackson).QueryRelationQualifier(winner,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"MTV Movie Award for Most Desirable Female\" . ?e_2 <pred:name> \"Janet Jackson\" . ?e_1 <winner> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <winner> ; <pred:fact_t> ?e_2 ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"MTV Movie Award for Most Desirable Female\"\nMATCH (n2) WHERE n2.name = \"Janet Jackson\"\nMATCH (n1)-[r1:winner]->(n2)\nRETURN r1.point_in_time",
    "question": "At what time point did Janet Jackson win the MTV Movie Award for Most Desirable Female?",
    "cypher_match": "match (e_1:Resource{name:\"MTV Movie Award for Most Desirable Female\"})-[:winner]->(e_2:Resource{name:\"Janet Jackson\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"winner\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "MTV Movie Award for Most Desirable Female"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Janet Jackson"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "winner",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_20686",
    "answer": "1994"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <E> Dwight Yoakam </E>",
    "kopl": "Find(Dwight Yoakam).QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Dwight Yoakam\" . ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Dwight_Yoakam ( string official_website ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Dwight Yoakam\"\nRETURN n1.official_website",
    "question": "What is the official website for Dwight Yoakam ?",
    "cypher_match": "match (e:Resource{name:\"Dwight Yoakam\"})-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dwight Yoakam"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_7486",
    "answer": "http://www.dwightyoakam.com/"
  },
  {
    "graphq_ir": "what is the qualifier <Q> located in the administrative territorial entity </Q> of <E> Katie Holmes </E> that <R> place of birth </R> to <ES> <E> Toledo </E> (<ES> ones that <R> place of birth </R> backward to <E> Alyson Stoner </E> </ES>) </ES>",
    "kopl": "Find(Katie Holmes).Find(Alyson Stoner).Relate(place of birth,forward).Find(Toledo).And().QueryRelationQualifier(place of birth,located in the administrative territorial entity)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Katie Holmes\" . ?e_2 <pred:name> \"Toledo\" . ?e_3 <place_of_birth> ?e_2 . ?e_3 <pred:name> \"Alyson Stoner\" . ?e_1 <place_of_birth> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <place_of_birth> ; <pred:fact_t> ?e_2 ] <located_in_the_administrative_territorial_entity> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Katie Holmes\"\nMATCH (n4) WHERE n4.name = \"Toledo\"\nMATCH (n3) WHERE n3.name = \"Alyson Stoner\"\nMATCH (n4)-[r1:place_of_birth]->(n3)\nMATCH (n1)-[r2:place_of_birth]->(n4)\nRETURN r2.located_in_the_administrative_territorial_entity",
    "question": "What territorial entity is Toledo, where Katie Holmes and Alyson Stoner were born?",
    "cypher_match": "match (e_3:Resource{name:\"Alyson Stoner\"})-[:place_of_birth]->(e_2:Resource{name:\"Toledo\"}) match (e_1:Resource{name:\"Katie Holmes\"})-[:place_of_birth]->(e_2:Resource{name:\"Toledo\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"place_of_birth\"}),(tmp)-[:located_in_the_administrative_territorial_entity]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Katie Holmes"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Alyson Stoner"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "place of birth",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Toledo"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "place of birth",
          "located in the administrative territorial entity"
        ]
      }
    ],
    "sample_id": "train_47329",
    "answer": "Ohio"
  },
  {
    "graphq_ir": "which one has the smallest <A> elevation above sea level </A> among <ES> <C> city in New Jersey </C> whose <A> population </A> smaller than number <V> 43000 </V> </ES>",
    "kopl": "FindAll().FilterNum(population,43000,<).FilterConcept(city in New Jersey).Select(elevation above sea level,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city in New Jersey\" . ?e <population> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> ?v_1 . FILTER ( ?v_1 < \"43000\"^^xsd:double ) . ?e <elevation_above_sea_level> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.city_in_New_Jersey ) ( string ! type ) ) ( string population ) ( string < ) ( number 43000 ) ) ( string min ) ( string elevation_above_sea_level ) ) )",
    "cypher": "MATCH (n1:city_in_New_Jersey) WHERE n1.population <  43000 \nRETURN n1.name AS name\nORDER BY n1.elevation_above_sea_level DESC\nLIMIT 1",
    "question": "I want to know which is the one with the least elevation, over sea level, within the city in New Jersey that has a population of under 43000",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city in New Jersey\"}) match (e)-[:population]->(pv_1:Resource{unit:\"1\"}) match (e)-[:elevation_above_sea_level]->(pv) where pv_1.value <  43000.0  return e order by pv.value limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "43000",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city in New Jersey"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "elevation above sea level",
          "smallest"
        ]
      }
    ],
    "sample_id": "train_83659",
    "answer": "Atlantic City"
  },
  {
    "graphq_ir": "what is the qualifier <Q> statement is subject of </Q> of <ES> <E> Romania </E> (<ES> ones that <R> diplomatic relation </R> forward to <E> Ukraine </E> </ES>) </ES> that <R> shares border with </R> to <E> Moldova </E>",
    "kopl": "Find(Ukraine).Relate(diplomatic relation,backward).Find(Romania).And().Find(Moldova).QueryRelationQualifier(shares border with,statement is subject of)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Romania\" . ?e_1 <diplomatic_relation> ?e_3 . ?e_3 <pred:name> \"Ukraine\" . ?e_2 <pred:name> \"Moldova\" . ?e_1 <shares_border_with> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <shares_border_with> ; <pred:fact_t> ?e_2 ] <statement_is_subject_of> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Romania\"\nMATCH (n2) WHERE n2.name = \"Ukraine\"\nMATCH (n3)<-[r1:diplomatic_relation]-(n2)\nMATCH (n4) WHERE n4.name = \"Moldova\"\nMATCH (n3)-[r2:shares_border_with]->(n4)\nRETURN r2.statement_is_subject_of",
    "question": "What is the subject of the statement that Romania (that has a diplomatic relationship with Ukraine) shares a border with Moldova?",
    "cypher_match": "match (e_1:Resource{name:\"Romania\"})-[:diplomatic_relation]->(e_3:Resource{name:\"Ukraine\"}) match (e_1:Resource{name:\"Romania\"})-[:shares_border_with]->(e_2:Resource{name:\"Moldova\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"shares_border_with\"}),(tmp)-[:statement_is_subject_of]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Ukraine"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "diplomatic relation",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Romania"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Moldova"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "shares border with",
          "statement is subject of"
        ]
      }
    ],
    "sample_id": "train_44723",
    "answer": "MoldovaRomania border"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <ES> <E> Rock of Ages </E> whose <A> publication date </A> is date <V> 2012-06-14 </V> </ES> or <E> A Prophet </E> </ES>",
    "kopl": "Find(Rock of Ages).FilterDate(publication date,2012-06-14,=).Find(A Prophet).Or().Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Rock of Ages\" . ?e <publication_date> ?pv_1 . ?pv_1 <pred:date> \"2012-06-14\"^^xsd:date . } UNION { ?e <pred:name> \"A Prophet\" . } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Rock_of_Ages ( string publication_date ) ( string = ) ( date 2012-06-14 ) ) en.A_Prophet ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Rock of Ages\"\nMATCH (n1) WHERE n1.publication_date =  2012-06-14 \nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n1) WHERE n1.name = \"A Prophet\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "What is the relationship between Rock of Ages (the one whose publication date is 2012-06-14) or A Prophet?",
    "cypher_match": "call { match (e:Resource{name:\"Rock of Ages\"})-[:publication_date]->(pv_1:Resource{date:Date(\"2012-06-14\")}) return e union match (e:Resource{name:\"A Prophet\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Rock of Ages"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "publication date",
          "2012-06-14",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "A Prophet"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "duration",
          "greater"
        ]
      }
    ],
    "sample_id": "train_32280",
    "answer": "A Prophet"
  },
  {
    "graphq_ir": "what is the relation from <E> Joseph L. Mankiewicz </E> to <E> 23rd Academy Awards </E>",
    "kopl": "Find(Joseph L. Mankiewicz).Find(23rd Academy Awards).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Joseph L. Mankiewicz\" . ?e_2 <pred:name> \"23rd Academy Awards\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Joseph L. Mankiewicz\"\nMATCH (n2) WHERE n2.name = \"23rd Academy Awards\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Joseph L. Mankiewicz and the 23rd Academy Awards?",
    "cypher_match": "match (e_1:Resource{name:\"Joseph L. Mankiewicz\"})-[p]->(e_2:Resource{name:\"23rd Academy Awards\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Joseph L. Mankiewicz"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "23rd Academy Awards"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_13094",
    "answer": "award received"
  },
  {
    "graphq_ir": "what is the attribute <A> inception </A> of <ES> <C> human settlement </C> whose <A> local dialing code </A> is text <V> 603 </V> </ES>",
    "kopl": "FindAll().FilterStr(local dialing code,603).FilterConcept(human settlement).QueryAttr(inception)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human settlement\" . ?e <local_dialing_code> ?pv_1 . ?pv_1 <pred:value> \"603\" . ?e <inception> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.human_settlement ) ( string ! type ) ) ( string local_dialing_code ) ( string = ) ( string 603 ) ) ( string inception ) ) )",
    "cypher": "MATCH (n1:human_settlement) WHERE n1.local_dialing_code = \"603\"\nRETURN n1.inception",
    "question": "What is the founding date of the human settlement with the telephone area code 603?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human settlement\"}) match (e)-[:local_dialing_code]->(pv_1:Resource{value:\"603\"}) match (e)-[:inception]->(pv) return distinct pv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "local dialing code",
          "603"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human settlement"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "inception"
        ]
      }
    ],
    "sample_id": "train_37401",
    "answer": "1638"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> human </C> whose <A> work period (start) </A> larger than year <V> 1951 </V> </ES> and <ES> <C> human </C> whose <A> audio recording of the subject's spoken voice </A> is text <V> Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac </V> </ES> </ES>",
    "kopl": "FindAll().FilterYear(work period (start),1951,>).FilterConcept(human).FindAll().FilterStr(audio recording of the subject's spoken voice,Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac).FilterConcept(human).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <work_period_(start)> ?pv . ?pv <pred:year> ?v . FILTER ( ?v > 1951 ) . ?e <audio_recording_of_the_subject's_spoken_voice> ?pv_1 . ?pv_1 <pred:value> \"Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.and ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string work_period_(start) ) ( string > ) ( year 1951 ) ) ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string audio_recording_of_the_subject's_spoken_voice ) ( string = ) ( string Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac ) ) ) )",
    "cypher": "MATCH (n2:human) WHERE n2.work_period_(start) >  1951 \nMATCH (n2:human) WHERE n2.audio_recording_of_the_subject's_spoken_voice = \"Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac\"\nRETURN n2.name",
    "question": "Who is the individual whose spoken voice is heard at Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac and whose career began after 1951?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:`work_period_(start)`]->(pv) match (e)-[:`audio_recording_of_the_subject's_spoken_voice`]->(pv_1:Resource{value:\"Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac\"}) where pv.year > 1951 return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "work period (start)",
          "1951",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "audio recording of the subject's spoken voice",
          "Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_21671",
    "answer": "Dustin Hoffman"
  },
  {
    "graphq_ir": "what is the attribute <A> population </A> of <ES> <C> ceremonial county of England </C> that <R> place of death </R> backward to <E> Jack Bruce </E> </ES>",
    "kopl": "Find(Jack Bruce).Relate(place of death,forward).FilterConcept(ceremonial county of England).QueryAttr(population)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"ceremonial county of England\" . ?e_1 <place_of_death> ?e . ?e_1 <pred:name> \"Jack Bruce\" .  ?e <population> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.ceremonial_county_of_England ) ( string ! type ) ) ( call SW.reverse ( string place_of_death ) ) ) ( string population ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Jack Bruce\"\nMATCH (n1:ceremonial_county_of_England)-[r1:place_of_death]->(n2)\nRETURN n1.population",
    "question": "What is the popluation of the ceremonial county of England where Jack Bruce died?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"ceremonial county of England\"}) match (e)-[:population]->(pv) match (e_1:Resource{name:\"Jack Bruce\"})-[:place_of_death]->(e) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jack Bruce"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "place of death",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "ceremonial county of England"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "population"
        ]
      }
    ],
    "sample_id": "train_55719",
    "answer": "741900"
  },
  {
    "graphq_ir": "what is <ES> <C> visual artwork </C> that <R> followed by </R> backward to <ES> <E> The Chronicles of Narnia: Prince Caspian </E> whose <A> duration </A> is number <V> 140 minute </V> </ES> </ES>",
    "kopl": "Find(The Chronicles of Narnia: Prince Caspian).FilterNum(duration,140 minute,=).Relate(followed by,forward).FilterConcept(visual artwork).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e_1 <followed_by> ?e . ?e_1 <pred:name> \"The Chronicles of Narnia: Prince Caspian\" . ?e_1 <duration> ?pv . ?pv <pred:unit> \"minute\" . ?pv <pred:value> \"140\"^^xsd:double .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.visual_artwork ) ( string ! type ) ) ( call SW.reverse ( string followed_by ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"The Chronicles of Narnia: Prince Caspian\"\nMATCH (n2) WHERE n2.duration =  140 minute \nMATCH (n1:visual_artwork)-[r1:followed_by]->(n2)\nRETURN n1.name",
    "question": "The Chronicles of Narnia: Prince Caspian (run-time 140 minutes) is followed by what visual artwork?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e_1:Resource{name:\"The Chronicles of Narnia: Prince Caspian\"})-[:followed_by]->(e) match (e_1:Resource{name:\"The Chronicles of Narnia: Prince Caspian\"})-[:duration]->(pv:Resource{unit:\"minute\",value:140.0}) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Chronicles of Narnia: Prince Caspian"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "duration",
          "140 minute",
          "="
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "followed by",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          3
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_19297",
    "answer": "The Chronicles of Narnia: The Voyage of the Dawn Treader"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <ES> <E> Quincy </E> whose <A> subreddit </A> is text <V> QuincyIL </V> </ES> or <ES> <E> Mansfield </E> (<ES> ones that <R> filming location </R> backward to <E> The Shawshank Redemption </E> </ES>) </ES> </ES>",
    "kopl": "Find(Quincy).FilterStr(subreddit,QuincyIL).Find(The Shawshank Redemption).Relate(filming location,forward).Find(Mansfield).And().Or().Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Quincy\" . ?e <subreddit> ?pv_1 . ?pv_1 <pred:value> \"QuincyIL\" . } UNION { ?e <pred:name> \"Mansfield\" . ?e_1 <filming_location> ?e . ?e_1 <pred:name> \"The Shawshank Redemption\" . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Quincy ( string subreddit ) ( string = ) ( string QuincyIL ) ) ( call SW.and en.Mansfield ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string filming_location ) ) ( string = ) en.The_Shawshank_Redemption ) ) ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Quincy\"\nMATCH (n1) WHERE n1.subreddit = \"QuincyIL\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Mansfield\"\nMATCH (n2) WHERE n2.name = \"The Shawshank Redemption\"\nMATCH (n3)-[r1:filming_location]->(n2)\nRETURN n3.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which has more area, Quincy whose subreddit is QuincyIL or Mansfield that is the filming location of The Shawshank Redemption?",
    "cypher_match": "call { match (e:Resource{name:\"Quincy\"})-[:subreddit]->(pv_1:Resource{value:\"QuincyIL\"}) return e union match (e_1:Resource{name:\"The Shawshank Redemption\"})-[:filming_location]->(e:Resource{name:\"Mansfield\"}) return e } match (e)-[:area]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Quincy"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "subreddit",
          "QuincyIL"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Shawshank Redemption"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "filming location",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Mansfield"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          5
        ],
        "inputs": [
          "area",
          "greater"
        ]
      }
    ],
    "sample_id": "train_14576",
    "answer": "Mansfield"
  },
  {
    "graphq_ir": "what is <ES> <C> metropolitan borough </C> whose <A> TOID </A> is text <V> 7000000000000018 </V> </ES>",
    "kopl": "FindAll().FilterStr(TOID,7000000000000018).FilterConcept(metropolitan borough).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"metropolitan borough\" . ?e <TOID> ?pv . ?pv <pred:value> \"7000000000000018\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.metropolitan_borough ) ( string ! type ) ) ( string TOID ) ( string = ) ( string 7000000000000018 ) ) )",
    "cypher": "MATCH (n1:metropolitan_borough) WHERE n1.TOID = \"7000000000000018\"\nRETURN n1.name",
    "question": "TOID 7000000000000018 designates which metro borough?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"metropolitan borough\"}) match (e)-[:TOID]->(pv:Resource{value:\"7000000000000018\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "TOID",
          "7000000000000018"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "metropolitan borough"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_94299",
    "answer": "Birmingham"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <ES> <E> DeKalb County </E> whose <A> PermID </A> is text <V> 5037043580 </V> </ES> or <E> Boulder County </E> </ES>",
    "kopl": "Find(DeKalb County).FilterStr(PermID,5037043580).Find(Boulder County).Or().Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"DeKalb County\" . ?e <PermID> ?pv_1 . ?pv_1 <pred:value> \"5037043580\" . } UNION { ?e <pred:name> \"Boulder County\" . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.DeKalb_County ( string PermID ) ( string = ) ( string 5037043580 ) ) en.Boulder_County ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"DeKalb County\"\nMATCH (n1) WHERE n1.PermID = \"5037043580\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Boulder County\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Is there less area in DeKalb County (the one whose PermID is 5037043580) or Boulder County ?",
    "cypher_match": "call { match (e:Resource{name:\"DeKalb County\"})-[:PermID]->(pv_1:Resource{value:\"5037043580\"}) return e union match (e:Resource{name:\"Boulder County\"}) return e } match (e)-[:area]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "DeKalb County"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "PermID",
          "5037043580"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Boulder County"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "area",
          "less"
        ]
      }
    ],
    "sample_id": "train_51096",
    "answer": "DeKalb County"
  },
  {
    "graphq_ir": "how many <ES> <C> medal </C> that <R> country </R> forward to <ES> <C> sovereign state </C> that <R> country </R> forward to <ES> <E> Republic of the Congo </E> whose <A> life expectancy </A> is number <V> 64.625 year </V> </ES> </ES> </ES>",
    "kopl": "Find(Republic of the Congo).FilterNum(life expectancy,64.625 year,=).Relate(country,backward).FilterConcept(sovereign state).Relate(country,backward).FilterConcept(medal).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"medal\" . ?e <country> ?e_1 . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"sovereign state\" . ?e_1 <country> ?e_2 . ?e_2 <pred:name> \"Republic of the Congo\" . ?e_2 <life_expectancy> ?pv_1 . ?pv_1 <pred:unit> \"year\" . ?pv_1 <pred:value> \"64.625\"^^xsd:double .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.medal ) ( string ! type ) ) ( string country ) ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Republic of the Congo\"\nMATCH (n3) WHERE n3.life_expectancy =  64.625 year \nMATCH (n2:sovereign_state)<-[r2:country]-(n3)\nMATCH (n1:medal)<-[r1:country]-(n2)\nRETURN count(n1)",
    "question": "How many medals origin in a sovereign state whose country is Republic of the Congo (the country whose life expectancy is 64.625 years) ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"medal\"}) match (e)-[:country]->(e_1) match (e_1)-[:instance_of]->(c_1:Resource{name:\"sovereign state\"}) match (e_1)-[:country]->(e_2:Resource{name:\"Republic of the Congo\"}) match (e_2:Resource{name:\"Republic of the Congo\"})-[:life_expectancy]->(pv_1:Resource{unit:\"year\",value:64.625}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Republic of the Congo"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "life expectancy",
          "64.625 year",
          "="
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "medal"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_75162",
    "answer": "0"
  },
  {
    "graphq_ir": "whether <ES> <C> cemetery </C> that <R> country </R> forward to <E> France </E> </ES> <A> inception </A> is not year <V> 1818 </V>",
    "kopl": "Find(France).Relate(country,backward).FilterConcept(cemetery).QueryAttr(inception).VerifyYear(1818,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"cemetery\" . ?e <country> ?e_1 . ?e_1 <pred:name> \"France\" .  ?e <inception> ?pv . ?pv <pred:year> ?v . FILTER ( ?v != 1818 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"France\"\nMATCH (n1:cemetery)<-[r1:country]-(n2) WHERE n1.inception <>  1818 \nRETURN isEmpty(n1)",
    "question": "Was the cemetry located in France not started in 1818?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"cemetery\"}) match (e)-[:country]->(e_1:Resource{name:\"France\"}) match (e)-[:inception]->(pv) return pv.year <> 1818",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "France"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "cemetery"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "inception"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1818",
          "!="
        ]
      }
    ],
    "sample_id": "train_41836",
    "answer": "yes"
  },
  {
    "graphq_ir": "whether <ES> <C> college of the University of Oxford </C> whose <A> IPv4 routing prefix </A> is text <V> 129.67.60.0/22 </V> </ES> <A> inception </A> is date <V> 1989-08-01 </V>",
    "kopl": "FindAll().FilterStr(IPv4 routing prefix,129.67.60.0/22).FilterConcept(college of the University of Oxford).QueryAttr(inception).VerifyDate(1989-08-01,=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"college of the University of Oxford\" . ?e <IPv4_routing_prefix> ?pv_1 . ?pv_1 <pred:value> \"129.67.60.0/22\" . ?e <inception> ?pv . ?pv <pred:date> \"1989-08-01\"^^xsd:date .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:college_of_the_University_of_Oxford) WHERE (n1.IPv4_routing_prefix = \"129.67.60.0/22\" AND n1.inception =  1989-08-01 )\nRETURN isEmpty(n1)",
    "question": "If we know an University of Oxford, whose  IPv4 routing prefix is 129.67.60.0/22, was it founded on 1st August 1989 ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"college of the University of Oxford\"}) match (e)-[:IPv4_routing_prefix]->(pv_1:Resource{value:\"129.67.60.0/22\"}) match (e)-[:inception]->(pv:Resource) return pv.date = Date(\"1989-08-01\")",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "IPv4 routing prefix",
          "129.67.60.0/22"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "college of the University of Oxford"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "inception"
        ]
      },
      {
        "function": "VerifyDate",
        "dependencies": [
          3
        ],
        "inputs": [
          "1989-08-01",
          "="
        ]
      }
    ],
    "sample_id": "train_12977",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> Sex, Lies, and Videotape </E> that <R> award received </R> to <E> National Film Registry </E>",
    "kopl": "Find(Sex, Lies, and Videotape).Find(National Film Registry).QueryRelationQualifier(award received,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Sex, Lies, and Videotape\" . ?e_2 <pred:name> \"National Film Registry\" . ?e_1 <award_received> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <award_received> ; <pred:fact_t> ?e_2 ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Sex, Lies, and Videotape\"\nMATCH (n2) WHERE n2.name = \"National Film Registry\"\nMATCH (n1)-[r1:award_received]->(n2)\nRETURN r1.point_in_time",
    "question": "When did Sex, Lies, and Videotape receive the National Film Registry?",
    "cypher_match": "match (e_1:Resource{name:\"Sex, Lies, and Videotape\"})-[:award_received]->(e_2:Resource{name:\"National Film Registry\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"award_received\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sex, Lies, and Videotape"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "National Film Registry"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "award received",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_29333",
    "answer": "2006-01-01"
  },
  {
    "graphq_ir": "whether <ES> <C> city of the United States </C> that <R> place of death </R> backward to <E> Nathanael Greene </E> </ES> <A> local dialing code </A> is text <V> 912 </V>",
    "kopl": "Find(Nathanael Greene).Relate(place of death,forward).FilterConcept(city of the United States).QueryAttr(local dialing code).VerifyStr(912)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e_1 <place_of_death> ?e . ?e_1 <pred:name> \"Nathanael Greene\" .  ?e <local_dialing_code> ?pv . ?pv <pred:value> \"912\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Nathanael Greene\"\nMATCH (n1:city_of_the_United_States)-[r1:place_of_death]->(n2) WHERE n1.local_dialing_code = \"912\"\nRETURN isEmpty(n1)",
    "question": "Does the U.S. city where Nathanael Greene died have the local dialing code of 912?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:local_dialing_code]->(pv:Resource) match (e_1:Resource{name:\"Nathanael Greene\"})-[:place_of_death]->(e) return pv.value = \"912\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Nathanael Greene"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "place of death",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "local dialing code"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "912"
        ]
      }
    ],
    "sample_id": "train_33390",
    "answer": "yes"
  },
  {
    "graphq_ir": "which one has the largest <A> real gross domestic product growth rate </A> among <ES> <E> Colombia </E> or <ES> <E> Georgia </E> (<ES> ones that <R> diplomatic relation </R> backward to <E> Vietnam </E> </ES>) </ES> </ES>",
    "kopl": "Find(Colombia).Find(Vietnam).Relate(diplomatic relation,forward).Find(Georgia).And().Or().Select(real gross domestic product growth rate,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Colombia\" .  } UNION { ?e <pred:name> \"Georgia\" . ?e_1 <diplomatic_relation> ?e . ?e_1 <pred:name> \"Vietnam\" .   } ?e <real_gross_domestic_product_growth_rate> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Colombia ( call SW.and en.Georgia ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string diplomatic_relation ) ) ( string = ) en.Vietnam ) ) ) ) ( string max ) ( string real_gross_domestic_product_growth_rate ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Colombia\"\nRETURN n1.name AS name\nORDER BY n1.real_gross_domestic_product_growth_rate DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Georgia\"\nMATCH (n2) WHERE n2.name = \"Vietnam\"\nMATCH (n3)-[r1:diplomatic_relation]->(n2)\nRETURN n3.name AS name\nORDER BY n1.real_gross_domestic_product_growth_rate DESC\nLIMIT 1",
    "question": "Does Colombia or Georgia, which has diplomatic relations with Vietnam, have a greater real gross domestic product growth rate?",
    "cypher_match": "call { match (e:Resource{name:\"Colombia\"}) return e union match (e_1:Resource{name:\"Vietnam\"})-[:diplomatic_relation]->(e:Resource{name:\"Georgia\"}) return e } match (e)-[:real_gross_domestic_product_growth_rate]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Colombia"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Vietnam"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "diplomatic relation",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Georgia"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "real gross domestic product growth rate",
          "greater"
        ]
      }
    ],
    "sample_id": "train_35296",
    "answer": "Georgia"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> nominated for </R> forward to <E> Nobel Prize in Chemistry </E> ( <Q> point in time </Q> is date <V> 1955-01-01 </V> ) </ES> <A> Erds number </A> is not number <V> 3.1 </V>",
    "kopl": "Find(Nobel Prize in Chemistry).Relate(nominated for,backward).QFilterDate(point in time,1955-01-01,=).FilterConcept(human).QueryAttr(Erds number).VerifyNum(3.1,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Nobel Prize in Chemistry\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <point_in_time> ?qpv . ?qpv <pred:date> \"1955-01-01\"^^xsd:date . ?e <Erds_number> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v != \"3.1\"^^xsd:double ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Nobel Prize in Chemistry\"\nMATCH (n1:human)<-[r1:nominated_for]-(n2) WHERE (r1.point_in_time =  1955-01-01  AND n1.Erds_number <>  3.1 )\nRETURN isEmpty(n1)",
    "question": "Is Erds number of a person, who was nominated for  Nobel Prize in Chemistry on 1955-01-01, equal to 3.1?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:nominated_for]->(e_1:Resource{name:\"Nobel Prize in Chemistry\"}) match (e)-[:Erds_number]->(pv:Resource{unit:\"1\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:point_in_time]->(qpv:Resource{date:Date(\"1955-01-01\")}) return pv.value <>  3.1 ",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Nobel Prize in Chemistry"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "QFilterDate",
        "dependencies": [
          1
        ],
        "inputs": [
          "point in time",
          "1955-01-01",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "Erds number"
        ]
      },
      {
        "function": "VerifyNum",
        "dependencies": [
          4
        ],
        "inputs": [
          "3.1",
          "!="
        ]
      }
    ],
    "sample_id": "train_45018",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is <ES> <C> university </C> whose <A> official website </A> is text <V> http://www.sfu.ca/ </V> </ES>",
    "kopl": "FindAll().FilterStr(official website,http://www.sfu.ca/).FilterConcept(university).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"university\" . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.sfu.ca/\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.university ) ( string ! type ) ) ( string official_website ) ( string = ) ( string http://www.sfu.ca/ ) ) )",
    "cypher": "MATCH (n1:university) WHERE n1.official_website = \"http://www.sfu.ca/\"\nRETURN n1.name",
    "question": "http://www.sfu.ca/ is the official website of which university?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"university\"}) match (e)-[:official_website]->(pv:Resource{value:\"http://www.sfu.ca/\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.sfu.ca/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "university"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_62755",
    "answer": "Simon Fraser University"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Michelangelo </E> whose <A> name in native language </A> is text <V> Michelangelo </V> </ES> to <E> ninja </E>",
    "kopl": "Find(Michelangelo).FilterStr(name in native language,Michelangelo).Find(ninja).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Michelangelo\" . ?e_1 <name_in_native_language> ?pv . ?pv <pred:value> \"Michelangelo\" . ?e_2 <pred:name> \"ninja\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Michelangelo\"\nMATCH (n1) WHERE n1.name_in_native_language = \"Michelangelo\"\nMATCH (n2) WHERE n2.name = \"ninja\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "Michelangelo (native language name Michelangelo) has what connection to a ninja?",
    "cypher_match": "match (e_1:Resource{name:\"Michelangelo\"})-[:name_in_native_language]->(pv:Resource{value:\"Michelangelo\"}) match (e_1:Resource{name:\"Michelangelo\"})-[p]->(e_2:Resource{name:\"ninja\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Michelangelo"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "name in native language",
          "Michelangelo"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "ninja"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_73797",
    "answer": "occupation"
  },
  {
    "graphq_ir": "whether <ES> <C> film </C> whose <A> title </A> is text <V> The Fisher King </V> </ES> <A> publication date </A> smaller than year <V> 1920 </V> ( <Q> place of publication </Q> is <V> Germany </V> )",
    "kopl": "FindAll().FilterStr(title,The Fisher King).FilterConcept(film).QueryAttrUnderCondition(publication date,place of publication,Germany).VerifyYear(1920,<)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"film\" . ?e <title> ?pv_1 . ?pv_1 <pred:value> \"The Fisher King\" . ?e <publication_date> ?pv . ?pv <pred:year> ?v . FILTER ( ?v < 1920 ) . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv . ?qpv <pred:value> \"Germany\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:film) WHERE (n1.title = \"The Fisher King\" AND n1.publication_date <  1920 )\nRETURN isEmpty(n1)",
    "question": "Is the release date of the film titled The Fisher King before the year 1920 in Germany?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film\"}) match (e)-[:title]->(pv_1:Resource{value:\"The Fisher King\"}) match (e)-[:publication_date]->(pv),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv:Resource{value:\"Germany\"}) return pv.year < 1920",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "The Fisher King"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "QueryAttrUnderCondition",
        "dependencies": [
          2
        ],
        "inputs": [
          "publication date",
          "place of publication",
          "Germany"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1920",
          "<"
        ]
      }
    ],
    "sample_id": "train_85978",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the attribute <A> title </A> of <E> Tucker: The Man and His Dream </E>",
    "kopl": "Find(Tucker: The Man and His Dream).QueryAttr(title)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Tucker: The Man and His Dream\" . ?e <title> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Tucker:_The_Man_and_His_Dream ( string title ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Tucker: The Man and His Dream\"\nRETURN n1.title",
    "question": "What is the title of Tucker: The Man and His Dream?",
    "cypher_match": "match (e:Resource{name:\"Tucker: The Man and His Dream\"})-[:title]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tucker: The Man and His Dream"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title"
        ]
      }
    ],
    "sample_id": "train_68219",
    "answer": "Tucker: The Man and His Dream"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> higher education institution </C> that <R> educated at </R> backward to <E> Jerome Kern </E> </ES> whose <A> students count </A> is <V> 30787 </V>",
    "kopl": "Find(Jerome Kern).Relate(educated at,forward).FilterConcept(higher education institution).QueryAttrQualifier(students count,30787,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"higher education institution\" . ?e_1 <educated_at> ?e . ?e_1 <pred:name> \"Jerome Kern\" .  ?e <students_count> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"30787\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <students_count> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Jerome Kern\"\nMATCH (n1:higher_education_institution)-[r1:educated_at]->(n2) WHERE n1.students_count =  30787 \nRETURN r1.point_in_time",
    "question": "When did the higher education institution where Jerome Kern was educated have a student count of 30787?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"higher education institution\"}) match (e)-[:students_count]->(pv:Resource{unit:\"1\",value:30787.0}) match (e_1:Resource{name:\"Jerome Kern\"})-[:educated_at]->(e),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"students_count\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jerome Kern"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "educated at",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "higher education institution"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "students count",
          "30787",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_29297",
    "answer": "2016-12-01"
  },
  {
    "graphq_ir": "what is <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0001 2142 1582 </V> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0001 2142 1582).FilterConcept(human).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 2142 1582\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0001 2142 1582 ) ) )",
    "cypher": "MATCH (n1:human) WHERE n1.ISNI = \"0000 0001 2142 1582\"\nRETURN n1.name",
    "question": "Which person's ISNI is 0000 0001 2142 1582?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv:Resource{value:\"0000 0001 2142 1582\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0001 2142 1582"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_70507",
    "answer": "Vilmos Zsigmond"
  },
  {
    "graphq_ir": "what is <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0001 1483 0433 </V> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0001 1483 0433).FilterConcept(human).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 1483 0433\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0001 1483 0433 ) ) )",
    "cypher": "MATCH (n1:human) WHERE n1.ISNI = \"0000 0001 1483 0433\"\nRETURN n1.name",
    "question": "What person's ISNI is 0000 0001 1483 0433?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv:Resource{value:\"0000 0001 1483 0433\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0001 1483 0433"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_73068",
    "answer": "Doug Savant"
  },
  {
    "graphq_ir": "whether <E> Peter Capaldi </E> <A> height </A> larger than number <V> 1.7 metre </V>",
    "kopl": "Find(Peter Capaldi).QueryAttr(height).VerifyNum(1.7 metre,>)",
    "sparql": "ASK { ?e <pred:name> \"Peter Capaldi\" . ?e <height> ?pv . ?pv <pred:unit> \"metre\" . ?pv <pred:value> ?v . FILTER ( ?v > \"1.7\"^^xsd:double ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Peter Capaldi\" AND n1.height >  1.7 metre )\nRETURN isEmpty(n1)",
    "question": "Is Peter Capaldi taller than 1.7 meters ?",
    "cypher_match": "match (e:Resource{name:\"Peter Capaldi\"})-[:height]->(pv:Resource{unit:\"metre\"}) return pv.value >  1.7 ",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Peter Capaldi"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "height"
        ]
      },
      {
        "function": "VerifyNum",
        "dependencies": [
          1
        ],
        "inputs": [
          "1.7 metre",
          ">"
        ]
      }
    ],
    "sample_id": "train_76703",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the relation from <E> Jermaine Easter </E> to <E> Milton Keynes Dons F.C. </E>",
    "kopl": "Find(Jermaine Easter).Find(Milton Keynes Dons F.C.).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Jermaine Easter\" . ?e_2 <pred:name> \"Milton Keynes Dons F.C.\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Jermaine Easter\"\nMATCH (n2) WHERE n2.name = \"Milton Keynes Dons F.C.\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is Jermaine Easter's connection to Milton Keynes Dons F.C.?",
    "cypher_match": "match (e_1:Resource{name:\"Jermaine Easter\"})-[p]->(e_2:Resource{name:\"Milton Keynes Dons F.C.\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jermaine Easter"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Milton Keynes Dons F.C."
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_35327",
    "answer": "member of sports team"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> city of the United States </C> whose <A> official website </A> is text <V> http://www.romefloyd.com/ </V> </ES> whose <A> population </A> is <V> 34980 </V>",
    "kopl": "FindAll().FilterStr(official website,http://www.romefloyd.com/).FilterConcept(city of the United States).QueryAttrQualifier(population,34980,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <official_website> ?pv_1 . ?pv_1 <pred:value> \"http://www.romefloyd.com/\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"34980\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE (n1.official_website = \"http://www.romefloyd.com/\" AND n1.population =  34980 )\nRETURN .point_in_time",
    "question": "When did the U.S. city whose official website is http://www.romefloyd.com/ have a population of 34980?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:official_website]->(pv_1:Resource{value:\"http://www.romefloyd.com/\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:34980.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.romefloyd.com/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "population",
          "34980",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_26696",
    "answer": "2000"
  },
  {
    "graphq_ir": "which one has the largest <A> mass </A> among <ES> <E> linoleic acid </E> or <E> arachidonic acid </E> </ES>",
    "kopl": "Find(linoleic acid).Find(arachidonic acid).Or().Select(mass,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"linoleic acid\" .  } UNION { ?e <pred:name> \"arachidonic acid\" .  } ?e <mass> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.linoleic_acid en.arachidonic_acid ) ( string max ) ( string mass ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"linoleic acid\"\nRETURN n1.name AS name\nORDER BY n1.mass DESC\nUNION\nMATCH (n1) WHERE n1.name = \"arachidonic acid\"\nRETURN n1.name AS name\nORDER BY n1.mass DESC\nLIMIT 1",
    "question": "Which acid has a greater mass, linoleic acid or arachidonic acid?",
    "cypher_match": "call { match (e:Resource{name:\"linoleic acid\"}) return e union match (e:Resource{name:\"arachidonic acid\"}) return e } match (e)-[:mass]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "linoleic acid"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "arachidonic acid"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "mass",
          "greater"
        ]
      }
    ],
    "sample_id": "train_86776",
    "answer": "arachidonic acid"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <E> Date Night </E> or <E> Face/Off </E> </ES>",
    "kopl": "Find(Date Night).Find(Face/Off).Or().Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Date Night\" .  } UNION { ?e <pred:name> \"Face/Off\" .  } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Date_Night en.Face/Off ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Date Night\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Face/Off\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Is Date Night or Face/Off longer?",
    "cypher_match": "call { match (e:Resource{name:\"Date Night\"}) return e union match (e:Resource{name:\"Face/Off\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Date Night"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Face/Off"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "duration",
          "greater"
        ]
      }
    ],
    "sample_id": "train_7375",
    "answer": "Face/Off"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <C> television film </C> that <R> color </R> forward to <E> black-and-white </E> </ES>",
    "kopl": "Find(black-and-white).Relate(color,backward).FilterConcept(television film).Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"television film\" . ?e <color> ?e_1 . ?e_1 <pred:name> \"black-and-white\" .  ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.television_film ) ( string ! type ) ) ( string color ) ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"black-and-white\"\nMATCH (n1:television_film)<-[r1:color]-(n2)\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Of all the television films done in black-and-white, which is the longest in duration?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"television film\"}) match (e)-[:color]->(e_1:Resource{name:\"black-and-white\"}) match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "black-and-white"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "color",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "television film"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "duration",
          "largest"
        ]
      }
    ],
    "sample_id": "train_40567",
    "answer": "Germany in Autumn"
  },
  {
    "graphq_ir": "whether <ES> <C> big city </C> whose <A> WOEID </A> is text <V> 673361 </V> </ES> <A> official website </A> is text <V> http://www.miramax.com/movie/life-is-beautiful </V>",
    "kopl": "FindAll().FilterStr(WOEID,673361).FilterConcept(big city).QueryAttr(official website).VerifyStr(http://www.miramax.com/movie/life-is-beautiful)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"big city\" . ?e <WOEID> ?pv_1 . ?pv_1 <pred:value> \"673361\" . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.miramax.com/movie/life-is-beautiful\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:big_city) WHERE (n1.WOEID = \"673361\" AND n1.official_website = \"http://www.miramax.com/movie/life-is-beautiful\")\nRETURN isEmpty(n1)",
    "question": "Is http://www.miramax.com/movie/life-is-beautiful the official website of the big city whose WOEID is 673361?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"big city\"}) match (e)-[:WOEID]->(pv_1:Resource{value:\"673361\"}) match (e)-[:official_website]->(pv:Resource) return pv.value = \"http://www.miramax.com/movie/life-is-beautiful\"",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "WOEID",
          "673361"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "big city"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "http://www.miramax.com/movie/life-is-beautiful"
        ]
      }
    ],
    "sample_id": "train_73069",
    "answer": "no"
  },
  {
    "graphq_ir": "what is <ES> <C> film </C> that <R> award received </R> forward to <E> Academy Award for Best Actress </E> ( <Q> statement is subject of </Q> is text <V> 26th Academy Awards </V> ) </ES>",
    "kopl": "Find(Academy Award for Best Actress).Relate(award received,backward).QFilterStr(statement is subject of,26th Academy Awards).FilterConcept(film).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film\" . ?e <award_received> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Actress\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <award_received> ; <pred:fact_t> ?e_1 ] <statement_is_subject_of> ?qpv . ?qpv <pred:value> \"26th Academy Awards\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Academy Award for Best Actress\"\nMATCH (n1:film)<-[r1:award_received]-(n2) WHERE r1.statement_is_subject_of = \"26th Academy Awards\"\nRETURN n1.name",
    "question": "Which film was awarded the Academy Award for Best Actress in the 26th Academy Awards?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film\"}) match (e)-[:award_received]->(e_1:Resource{name:\"Academy Award for Best Actress\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"award_received\"}),(tmp)-[:statement_is_subject_of]->(qpv:Resource{value:\"26th Academy Awards\"}) return distinct e",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Actress"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "backward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "statement is subject of",
          "26th Academy Awards"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          3
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_64636",
    "answer": "Roman Holiday"
  },
  {
    "graphq_ir": "how many <ES> <C> miniseries </C> that <R> nominated for </R> forward to <ES> <C> Primetime Emmy Award </C> that <R> nominated for </R> backward to <E> Steven Moffat </E> ( <Q> for work </Q> is text <V> Sherlock </V> ) </ES> </ES>",
    "kopl": "Find(Steven Moffat).Relate(nominated for,forward).QFilterStr(for work,Sherlock).FilterConcept(Primetime Emmy Award).Relate(nominated for,backward).FilterConcept(miniseries).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"miniseries\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"Primetime Emmy Award\" . ?e_2 <nominated_for> ?e_1 . ?e_2 <pred:name> \"Steven Moffat\" . [ <pred:fact_h> ?e_2 ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <for_work> ?qpv . ?qpv <pred:value> \"Sherlock\" .   }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Steven Moffat\"\nMATCH (n2:Primetime_Emmy_Award)-[r2:nominated_for]->(n3) WHERE r2.for_work = \"Sherlock\"\nMATCH (n1:miniseries)<-[r1:nominated_for]-(n2)\nRETURN count(n1)",
    "question": "The Primetime Emmy Award nominated to Steven Moffat for Sherlock was also nominated to how many miniseries?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"miniseries\"}) match (e)-[:nominated_for]->(e_1) match (e_1)-[:instance_of]->(c_1:Resource{name:\"Primetime Emmy Award\"}) match (e_2:Resource{name:\"Steven Moffat\"})-[:nominated_for]->(e_1),(e_2)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:for_work]->(qpv:Resource{value:\"Sherlock\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Steven Moffat"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "forward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "for work",
          "Sherlock"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "Primetime Emmy Award"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "miniseries"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_93159",
    "answer": "9"
  },
  {
    "graphq_ir": "how many <ES> <C> former French region </C> that <R> replaced by </R> forward to <ES> <C> region of France </C> whose <A> SIREN number </A> is text <V> 200053403 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(SIREN number,200053403).FilterConcept(region of France).Relate(replaced by,backward).FilterConcept(former French region).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"former French region\" . ?e <replaced_by> ?e_1 . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"region of France\" . ?e_1 <SIREN_number> ?pv_1 . ?pv_1 <pred:value> \"200053403\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.former_French_region ) ( string ! type ) ) ( string replaced_by ) ) ) )",
    "cypher": "MATCH (n2:region_of_France) WHERE n2.SIREN_number = \"200053403\"\nMATCH (n1:former_French_region)<-[r1:replaced_by]-(n2)\nRETURN count(n1)",
    "question": "For the region of France with the SIREN number 200053403, how many former French regions were replaced by it?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"former French region\"}) match (e)-[:replaced_by]->(e_1) match (e_1)-[:instance_of]->(c_1:Resource{name:\"region of France\"}) match (e_1)-[:SIREN_number]->(pv_1:Resource{value:\"200053403\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "SIREN number",
          "200053403"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "region of France"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "replaced by",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "former French region"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_28649",
    "answer": "2"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> political party </C> that <R> official color </R> forward to <E> red </E> </ES> and <ES> <C> political party </C> that <R> parent organization </R> backward to <E> Liberation Tigers of Tamil Eelam </E> </ES> </ES>",
    "kopl": "Find(red).Relate(official color,backward).FilterConcept(political party).Find(Liberation Tigers of Tamil Eelam).Relate(parent organization,forward).FilterConcept(political party).And().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"political party\" . ?e <official_color> ?e_1 . ?e_1 <pred:name> \"red\" .  ?e_2 <parent_organization> ?e . ?e_2 <pred:name> \"Liberation Tigers of Tamil Eelam\" .  }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.and ( call SW.filter ( getProperty ( singleton en.political_party ) ( string ! type ) ) ( string official_color ) ) ( call SW.filter ( getProperty ( singleton en.political_party ) ( string ! type ) ) ( call SW.reverse ( string parent_organization ) ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"red\"\nMATCH (n3:political_party)<-[r1:official_color]-(n2)\nMATCH (n2) WHERE n2.name = \"Liberation Tigers of Tamil Eelam\"\nMATCH (n3:political_party)-[r1:parent_organization]->(n2)\nRETURN count(n3)",
    "question": "How many political parties use red as the official control and have Liberation Tigers of Tamil Eelam as the parent organization ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"political party\"}) match (e)-[:official_color]->(e_1:Resource{name:\"red\"}) match (e_2:Resource{name:\"Liberation Tigers of Tamil Eelam\"})-[:parent_organization]->(e) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "red"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "official color",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "political party"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Liberation Tigers of Tamil Eelam"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "parent organization",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "political party"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_16412",
    "answer": "0"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Batman Forever </E> (<ES> ones that <R> game mode </R> forward to <E> single-player video game </E> </ES>) </ES> to <E> action game </E>",
    "kopl": "Find(single-player video game).Relate(game mode,backward).Find(Batman Forever).And().Find(action game).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Batman Forever\" . ?e_1 <game_mode> ?e_3 . ?e_3 <pred:name> \"single-player video game\" . ?e_2 <pred:name> \"action game\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Batman Forever\"\nMATCH (n2) WHERE n2.name = \"single-player video game\"\nMATCH (n3)<-[r1:game_mode]-(n2)\nMATCH (n4) WHERE n4.name = \"action game\"\nMATCH (n3)-[r2]->(n4)\nRETURN r2.label",
    "question": "How is single-player video game Batman Forever related to action game?",
    "cypher_match": "match (e_1:Resource{name:\"Batman Forever\"})-[:game_mode]->(e_3:Resource{name:\"single-player video game\"}) match (e_1:Resource{name:\"Batman Forever\"})-[p]->(e_2:Resource{name:\"action game\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "single-player video game"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "game mode",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Batman Forever"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "action game"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_773",
    "answer": "genre"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> Charleston County </E> whose <A> population </A> is <V> 389262 </V>",
    "kopl": "Find(Charleston County).QueryAttrQualifier(population,389262,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Charleston County\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"389262\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Charleston County\" AND n1.population =  389262 )\nRETURN .point_in_time",
    "question": "When was the population of Charleston County 389262?",
    "cypher_match": "match (e:Resource{name:\"Charleston County\"})-[:population]->(pv:Resource{unit:\"1\",value:389262.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Charleston County"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "389262",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_14468",
    "answer": "2015-01-01"
  },
  {
    "graphq_ir": "what is the qualifier <Q> start time </Q> of <ES> <E> Chicago </E> whose <A> demonym </A> is text <V> Chicagoan </V> </ES> that <R> twinned administrative body </R> to <E> Belgrade </E>",
    "kopl": "Find(Chicago).FilterStr(demonym,Chicagoan).Find(Belgrade).QueryRelationQualifier(twinned administrative body,start time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Chicago\" . ?e_1 <demonym> ?pv . ?pv <pred:value> \"Chicagoan\" . ?e_2 <pred:name> \"Belgrade\" . ?e_1 <twinned_administrative_body> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <twinned_administrative_body> ; <pred:fact_t> ?e_2 ] <start_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Chicago\"\nMATCH (n1) WHERE n1.demonym = \"Chicagoan\"\nMATCH (n2) WHERE n2.name = \"Belgrade\"\nMATCH (n1)-[r1:twinned_administrative_body]->(n2)\nRETURN r1.start_time",
    "question": "When did Chicago whose demonym is Chicagoan become the twinned administrative body of Belgrade?",
    "cypher_match": "match (e_1:Resource{name:\"Chicago\"})-[:demonym]->(pv:Resource{value:\"Chicagoan\"}) match (e_1:Resource{name:\"Chicago\"})-[:twinned_administrative_body]->(e_2:Resource{name:\"Belgrade\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"twinned_administrative_body\"}),(tmp)-[:start_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Chicago"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "demonym",
          "Chicagoan"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Belgrade"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "twinned administrative body",
          "start time"
        ]
      }
    ],
    "sample_id": "train_45379",
    "answer": "2005-06-01"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0000 7847 8275 </V> </ES> <A> date of birth </A> larger than year <V> 1589 </V>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0000 7847 8275).FilterConcept(human).QueryAttr(date of birth).VerifyYear(1589,>)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv_1 . ?pv_1 <pred:value> \"0000 0000 7847 8275\" . ?e <date_of_birth> ?pv . ?pv <pred:year> ?v . FILTER ( ?v > 1589 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:human) WHERE (n1.ISNI = \"0000 0000 7847 8275\" AND n1.date_of_birth >  1589 )\nRETURN isEmpty(n1)",
    "question": "Was the person with the ISNI of 0000 0000 7847 8275 born after 1589?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv_1:Resource{value:\"0000 0000 7847 8275\"}) match (e)-[:date_of_birth]->(pv) return pv.year > 1589",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0000 7847 8275"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "date of birth"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1589",
          ">"
        ]
      }
    ],
    "sample_id": "train_52015",
    "answer": "yes"
  },
  {
    "graphq_ir": "whether <ES> <E> Michael Winterbottom </E> (<ES> ones that <R> educated at </R> forward to <E> Dulwich College </E> </ES>) </ES> <A> ISNI </A> is text <V> 0000 0001 2144 6958 </V>",
    "kopl": "Find(Dulwich College).Relate(educated at,backward).Find(Michael Winterbottom).And().QueryAttr(ISNI).VerifyStr(0000 0001 2144 6958)",
    "sparql": "ASK { ?e <pred:name> \"Michael Winterbottom\" . ?e <educated_at> ?e_1 . ?e_1 <pred:name> \"Dulwich College\" .  ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 2144 6958\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE (n3.name = \"Michael Winterbottom\" AND n3.ISNI = \"0000 0001 2144 6958\")\nMATCH (n2) WHERE n2.name = \"Dulwich College\"\nMATCH (n3)<-[r1:educated_at]-(n2)\nRETURN isEmpty(n3)",
    "question": "Does Michael Winterbottom, who was educated at Dulwich College, have an ISNI of 0000 0001 2144 6958?",
    "cypher_match": "match (e:Resource{name:\"Michael Winterbottom\"})-[:educated_at]->(e_1:Resource{name:\"Dulwich College\"}) match (e:Resource{name:\"Michael Winterbottom\"})-[:ISNI]->(pv:Resource) return pv.value = \"0000 0001 2144 6958\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dulwich College"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "educated at",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Michael Winterbottom"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          4
        ],
        "inputs": [
          "0000 0001 2144 6958"
        ]
      }
    ],
    "sample_id": "train_35679",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the qualifier <Q> character role </Q> of <E> The Bourne Legacy </E> that <R> cast member </R> to <E> Joan Allen </E>",
    "kopl": "Find(The Bourne Legacy).Find(Joan Allen).QueryRelationQualifier(cast member,character role)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"The Bourne Legacy\" . ?e_2 <pred:name> \"Joan Allen\" . ?e_1 <cast_member> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <cast_member> ; <pred:fact_t> ?e_2 ] <character_role> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"The Bourne Legacy\"\nMATCH (n2) WHERE n2.name = \"Joan Allen\"\nMATCH (n1)-[r1:cast_member]->(n2)\nRETURN r1.character_role",
    "question": "What character did Joan Allen play in The Bourne Legacy?",
    "cypher_match": "match (e_1:Resource{name:\"The Bourne Legacy\"})-[:cast_member]->(e_2:Resource{name:\"Joan Allen\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"cast_member\"}),(tmp)-[:character_role]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Bourne Legacy"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Joan Allen"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "cast member",
          "character role"
        ]
      }
    ],
    "sample_id": "train_3266",
    "answer": "Pamela Landy"
  },
  {
    "graphq_ir": "whether <ES> <C> visual artwork </C> whose <A> title </A> is text <V> Born on the Fourth of July </V> </ES> <A> publication date </A> is year <V> 1991 </V> ( <Q> place of publication </Q> is <V> Germany </V> )",
    "kopl": "FindAll().FilterStr(title,Born on the Fourth of July).FilterConcept(visual artwork).QueryAttrUnderCondition(publication date,place of publication,Germany).VerifyYear(1991,=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <title> ?pv_1 . ?pv_1 <pred:value> \"Born on the Fourth of July\" . ?e <publication_date> ?pv . ?pv <pred:year> 1991 . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv . ?qpv <pred:value> \"Germany\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:visual_artwork) WHERE (n1.title = \"Born on the Fourth of July\" AND n1.publication_date =  1991 )\nRETURN isEmpty(n1)",
    "question": "Was the film Born on the Fourth of July released in Germany in 1991?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:title]->(pv_1:Resource{value:\"Born on the Fourth of July\"}) match (e)-[:publication_date]->(pv:Resource{year:1991}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv:Resource{value:\"Germany\"}) return pv.year = 1991",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "Born on the Fourth of July"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "QueryAttrUnderCondition",
        "dependencies": [
          2
        ],
        "inputs": [
          "publication date",
          "place of publication",
          "Germany"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1991",
          "="
        ]
      }
    ],
    "sample_id": "train_29562",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> sovereign state </C> that <R> diplomatic relation </R> backward to <E> Taiwan </E> ( <Q> statement is subject of </Q> is text <V> East TimorTaiwan relations </V> ) </ES> whose <A> population </A> is <V> 1148958 </V>",
    "kopl": "Find(Taiwan).Relate(diplomatic relation,forward).QFilterStr(statement is subject of,East TimorTaiwan relations).FilterConcept(sovereign state).QueryAttrQualifier(population,1148958,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"sovereign state\" . ?e_1 <diplomatic_relation> ?e . ?e_1 <pred:name> \"Taiwan\" . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <diplomatic_relation> ; <pred:fact_t> ?e ] <statement_is_subject_of> ?qpv_1 . ?qpv_1 <pred:value> \"East TimorTaiwan relations\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"1148958\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Taiwan\"\nMATCH (n1:sovereign_state)-[r1:diplomatic_relation]->(n2) WHERE (r1.statement_is_subject_of = \"East TimorTaiwan relations\" AND n1.population =  1148958 )\nRETURN r1.point_in_time",
    "question": "At what point in time is 1148958 the population of the sovereign state has has East Timor-Taiwan diplomatic relations with Taiwan?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"sovereign state\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:1148958.0}) match (e_1:Resource{name:\"Taiwan\"})-[:diplomatic_relation]->(e),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e), (tmp)-[:fact_r]-(qr:Relation{name:\"diplomatic_relation\"}),(tmp)-[:statement_is_subject_of]->(qpv_1:Resource{value:\"East TimorTaiwan relations\"}),(e)<-[:fact_h]-(tmp_1)-[:fact_t]->(pv), (tmp_1)-[:fact_r]-(qr_1:Relation{name:\"population\"}),(tmp_1)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Taiwan"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "diplomatic relation",
          "forward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "statement is subject of",
          "East TimorTaiwan relations"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          3
        ],
        "inputs": [
          "population",
          "1148958",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_7748",
    "answer": "2012"
  },
  {
    "graphq_ir": "how many <ES> <C> capital </C> that <R> film release region </R> backward to <ES> <C> visual artwork </C> whose <A> title </A> is text <V>     </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(title,   ).FilterConcept(visual artwork).Relate(film release region,forward).FilterConcept(capital).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"capital\" . ?e_1 <film_release_region> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"visual artwork\" . ?e_1 <title> ?pv . ?pv <pred:value> \"   \" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.capital ) ( string ! type ) ) ( call SW.reverse ( string film_release_region ) ) ) ) )",
    "cypher": "MATCH (n2:visual_artwork) WHERE n2.title = \"   \"\nMATCH (n1:capital)-[r1:film_release_region]->(n2)\nRETURN count(n1)",
    "question": "What is the number of capitals that are the release territory of the visual artwork titled    ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"capital\"}) match (e_1)-[:film_release_region]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"visual artwork\"}) match (e_1)-[:title]->(pv:Resource{value:\"   \"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "   "
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "film release region",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "capital"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_70865",
    "answer": "1"
  },
  {
    "graphq_ir": "which one has the largest <A> elevation above sea level </A> among <ES> <C> human settlement </C> whose <A> local dialing code </A> is text <V> 973 </V> </ES>",
    "kopl": "FindAll().FilterStr(local dialing code,973).FilterConcept(human settlement).Select(elevation above sea level,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human settlement\" . ?e <local_dialing_code> ?pv_1 . ?pv_1 <pred:value> \"973\" . ?e <elevation_above_sea_level> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.human_settlement ) ( string ! type ) ) ( string local_dialing_code ) ( string = ) ( string 973 ) ) ( string max ) ( string elevation_above_sea_level ) ) )",
    "cypher": "MATCH (n1:human_settlement) WHERE n1.local_dialing_code = \"973\"\nRETURN n1.name AS name\nORDER BY n1.elevation_above_sea_level DESC\nLIMIT 1",
    "question": "Which human settlement has the largest elevation (above sea level) among those with the local dialing code of 973?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human settlement\"}) match (e)-[:local_dialing_code]->(pv_1:Resource{value:\"973\"}) match (e)-[:elevation_above_sea_level]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "local dialing code",
          "973"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human settlement"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "elevation above sea level",
          "largest"
        ]
      }
    ],
    "sample_id": "train_49783",
    "answer": "West Orange"
  }
]