[
  {
    "graphq_ir": "which one has the largest <A> population </A> among <ES> <ES> <E> Florence </E> whose <A> elevation above sea level </A> is number <V> 42 metre </V> </ES> or <E> Raleigh </E> </ES>",
    "kopl": "Find(Florence).FilterNum(elevation above sea level,42 metre,=).Find(Raleigh).Or().Select(population,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Florence\" . ?e <elevation_above_sea_level> ?pv_1 . ?pv_1 <pred:unit> \"metre\" . ?pv_1 <pred:value> \"42\"^^xsd:double . } UNION { ?e <pred:name> \"Raleigh\" . } ?e <population> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Florence ( string elevation_above_sea_level ) ( string = ) ( number 42 metre ) ) en.Raleigh ) ( string max ) ( string population ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Florence\"\nMATCH (n1) WHERE n1.elevation_above_sea_level =  42 metre \nRETURN n1.name AS name\nORDER BY n1.population DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Raleigh\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nLIMIT 1",
    "question": "Tell me the one with the bigger population, Florence (which has an elevation (over sea level) of 42 metres) or Raleigh.",
    "cypher_match": "call { match (e:Resource{name:\"Florence\"})-[:elevation_above_sea_level]->(pv_1:Resource{unit:\"metre\",value:42.0}) return e union match (e:Resource{name:\"Raleigh\"}) return e } match (e)-[:population]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Florence"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "elevation above sea level",
          "42 metre",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Raleigh"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "population",
          "greater"
        ]
      }
    ],
    "sample_id": "train_52457",
    "answer": "Raleigh"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <E> San Francisco Bay Area </E> or <E> Seattle metropolitan area </E> </ES>",
    "kopl": "Find(San Francisco Bay Area).Find(Seattle metropolitan area).Or().Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"San Francisco Bay Area\" .  } UNION { ?e <pred:name> \"Seattle metropolitan area\" .  } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.San_Francisco_Bay_Area en.Seattle_metropolitan_area ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"San Francisco Bay Area\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Seattle metropolitan area\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Does the San Francisco Bay Area or the Seattle metropolitan area occupy a larger area?",
    "cypher_match": "call { match (e:Resource{name:\"San Francisco Bay Area\"}) return e union match (e:Resource{name:\"Seattle metropolitan area\"}) return e } match (e)-[:area]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "San Francisco Bay Area"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Seattle metropolitan area"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "area",
          "greater"
        ]
      }
    ],
    "sample_id": "train_76485",
    "answer": "San Francisco Bay Area"
  },
  {
    "graphq_ir": "what is the attribute <A> area </A> of <E> North Island </E>",
    "kopl": "Find(North Island).QueryAttr(area)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"North Island\" . ?e <area> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.North_Island ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"North Island\"\nRETURN n1.area",
    "question": "How large is North Island in terms of area?",
    "cypher_match": "match (e:Resource{name:\"North Island\"})-[:area]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "North Island"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "area"
        ]
      }
    ],
    "sample_id": "train_84842",
    "answer": "113729 square kilometre"
  },
  {
    "graphq_ir": "what is the qualifier <Q> number of subscribers </Q> of <ES> <C> human </C> whose <A> birth name </A> is text <V> Richard Melville Hall </V> </ES> whose <A> Twitter username </A> is <V> thelittleidiot </V>",
    "kopl": "FindAll().FilterStr(birth name,Richard Melville Hall).FilterConcept(human).QueryAttrQualifier(Twitter username,thelittleidiot,number of subscribers)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <birth_name> ?pv_1 . ?pv_1 <pred:value> \"Richard Melville Hall\" . ?e <Twitter_username> ?pv . ?pv <pred:value> \"thelittleidiot\" . [ <pred:fact_h> ?e ; <pred:fact_r> <Twitter_username> ; <pred:fact_t> ?pv ] <number_of_subscribers> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:human) WHERE (n1.birth_name = \"Richard Melville Hall\" AND n1.Twitter_username =  thelittleidiot )\nRETURN .number_of_subscribers",
    "question": "How many subscribe to thelittleidiot, the Twitter handle of the person born as Richard Melville Hall?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:birth_name]->(pv_1:Resource{value:\"Richard Melville Hall\"}) match (e)-[:Twitter_username]->(pv:Resource{value:\"thelittleidiot\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"Twitter_username\"}),(tmp)-[:number_of_subscribers]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "birth name",
          "Richard Melville Hall"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "Twitter username",
          "thelittleidiot",
          "number of subscribers"
        ]
      }
    ],
    "sample_id": "train_83443",
    "answer": "1349252"
  },
  {
    "graphq_ir": "what is the relation from <E> Lille </E> to <ES> <E> Leeds </E> (<ES> ones that <R> located in the administrative territorial entity </R> backward to <E> University of Leeds </E> </ES>) </ES>",
    "kopl": "Find(Lille).Find(University of Leeds).Relate(located in the administrative territorial entity,forward).Find(Leeds).And().QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Lille\" . ?e_2 <pred:name> \"Leeds\" . ?e_3 <located_in_the_administrative_territorial_entity> ?e_2 . ?e_3 <pred:name> \"University of Leeds\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Lille\"\nMATCH (n4) WHERE n4.name = \"Leeds\"\nMATCH (n3) WHERE n3.name = \"University of Leeds\"\nMATCH (n4)-[r1:located_in_the_administrative_territorial_entity]->(n3)\nMATCH (n1)-[r2]->(n4)\nRETURN r2.label",
    "question": "What is the connection between Lille to Leeds (the one that contains University of Leeds)?",
    "cypher_match": "match (e_3:Resource{name:\"University of Leeds\"})-[:located_in_the_administrative_territorial_entity]->(e_2:Resource{name:\"Leeds\"}) match (e_1:Resource{name:\"Lille\"})-[p]->(e_2:Resource{name:\"Leeds\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Lille"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "University of Leeds"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "located in the administrative territorial entity",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Leeds"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_19317",
    "answer": "twinned administrative body"
  },
  {
    "graphq_ir": "what is the attribute <A> inception </A> of <ES> <C> human settlement </C> whose <A> local dialing code </A> is text <V> 603 </V> </ES>",
    "kopl": "FindAll().FilterStr(local dialing code,603).FilterConcept(human settlement).QueryAttr(inception)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human settlement\" . ?e <local_dialing_code> ?pv_1 . ?pv_1 <pred:value> \"603\" . ?e <inception> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.human_settlement ) ( string ! type ) ) ( string local_dialing_code ) ( string = ) ( string 603 ) ) ( string inception ) ) )",
    "cypher": "MATCH (n1:human_settlement) WHERE n1.local_dialing_code = \"603\"\nRETURN n1.inception",
    "question": "What is the founding date of the human settlement with the telephone area code 603?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human settlement\"}) match (e)-[:local_dialing_code]->(pv_1:Resource{value:\"603\"}) match (e)-[:inception]->(pv) return distinct pv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "local dialing code",
          "603"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human settlement"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "inception"
        ]
      }
    ],
    "sample_id": "train_37401",
    "answer": "1638"
  },
  {
    "graphq_ir": "what is the qualifier <Q> located in the administrative territorial entity </Q> of <E> Katie Holmes </E> that <R> place of birth </R> to <ES> <E> Toledo </E> (<ES> ones that <R> place of birth </R> backward to <E> Alyson Stoner </E> </ES>) </ES>",
    "kopl": "Find(Katie Holmes).Find(Alyson Stoner).Relate(place of birth,forward).Find(Toledo).And().QueryRelationQualifier(place of birth,located in the administrative territorial entity)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Katie Holmes\" . ?e_2 <pred:name> \"Toledo\" . ?e_3 <place_of_birth> ?e_2 . ?e_3 <pred:name> \"Alyson Stoner\" . ?e_1 <place_of_birth> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <place_of_birth> ; <pred:fact_t> ?e_2 ] <located_in_the_administrative_territorial_entity> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Katie Holmes\"\nMATCH (n4) WHERE n4.name = \"Toledo\"\nMATCH (n3) WHERE n3.name = \"Alyson Stoner\"\nMATCH (n4)-[r1:place_of_birth]->(n3)\nMATCH (n1)-[r2:place_of_birth]->(n4)\nRETURN r2.located_in_the_administrative_territorial_entity",
    "question": "What territorial entity is Toledo, where Katie Holmes and Alyson Stoner were born?",
    "cypher_match": "match (e_3:Resource{name:\"Alyson Stoner\"})-[:place_of_birth]->(e_2:Resource{name:\"Toledo\"}) match (e_1:Resource{name:\"Katie Holmes\"})-[:place_of_birth]->(e_2:Resource{name:\"Toledo\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"place_of_birth\"}),(tmp)-[:located_in_the_administrative_territorial_entity]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Katie Holmes"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Alyson Stoner"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "place of birth",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Toledo"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "place of birth",
          "located in the administrative territorial entity"
        ]
      }
    ],
    "sample_id": "train_47329",
    "answer": "Ohio"
  },
  {
    "graphq_ir": "what is <ES> <C> city of the United States </C> whose <A> local dialing code </A> is text <V> 480 602 </V> </ES>",
    "kopl": "FindAll().FilterStr(local dialing code,480 602).FilterConcept(city of the United States).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <local_dialing_code> ?pv . ?pv <pred:value> \"480 602\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.city_of_the_United_States ) ( string ! type ) ) ( string local_dialing_code ) ( string = ) ( string 480 602 ) ) )",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE n1.local_dialing_code = \"480 602\"\nRETURN n1.name",
    "question": "What United States city has the local dialing code 480 602?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:local_dialing_code]->(pv:Resource{value:\"480 602\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "local dialing code",
          "480 602"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_32553",
    "answer": "Mesa"
  },
  {
    "graphq_ir": "what is <ES> <C> war </C> that <R> participant </R> forward to <ES> <E> India </E> (<ES> ones that <R> diplomatic relation </R> backward to <E> European Union </E> </ES>) </ES> </ES>",
    "kopl": "Find(European Union).Relate(diplomatic relation,forward).Find(India).And().Relate(participant,backward).FilterConcept(war).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"war\" . ?e <participant> ?e_1 . ?e_1 <pred:name> \"India\" . ?e_2 <diplomatic_relation> ?e_1 . ?e_2 <pred:name> \"European Union\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.war ) ( string ! type ) ) ( string participant ) ) )",
    "cypher": "MATCH (n4) WHERE n4.name = \"India\"\nMATCH (n3) WHERE n3.name = \"European Union\"\nMATCH (n4)-[r2:diplomatic_relation]->(n3)\nMATCH (n1:war)<-[r1:participant]-(n4)\nRETURN n1.name",
    "question": "Tell me the war that has India as a participant (the one that has diplomatic relationship with European Union)",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"war\"}) match (e)-[:participant]->(e_1:Resource{name:\"India\"}) match (e_2:Resource{name:\"European Union\"})-[:diplomatic_relation]->(e_1:Resource{name:\"India\"}) return distinct e",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "European Union"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "diplomatic relation",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "India"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "participant",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "war"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_46477",
    "answer": "Indo-Pakistani War of 1971"
  },
  {
    "graphq_ir": "what is the attribute <A> Twitter username </A> of <E> New York Islanders </E>",
    "kopl": "Find(New York Islanders).QueryAttr(Twitter username)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"New York Islanders\" . ?e <Twitter_username> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.New_York_Islanders ( string Twitter_username ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"New York Islanders\"\nRETURN n1.Twitter_username",
    "question": "What Twitter handle belongs to the New York Islanders?",
    "cypher_match": "match (e:Resource{name:\"New York Islanders\"})-[:Twitter_username]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "New York Islanders"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Twitter username"
        ]
      }
    ],
    "sample_id": "train_2830",
    "answer": "NYIslanders"
  },
  {
    "graphq_ir": "what is <ES> <C> visual artwork </C> that <R> producer </R> forward to <E> Werner Herzog </E> </ES>",
    "kopl": "Find(Werner Herzog).Relate(producer,backward).FilterConcept(visual artwork).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <producer> ?e_1 . ?e_1 <pred:name> \"Werner Herzog\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.visual_artwork ) ( string ! type ) ) ( string producer ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Werner Herzog\"\nMATCH (n1:visual_artwork)<-[r1:producer]-(n2)\nRETURN n1.name",
    "question": "What visual artwork was produced by Werner Herzog?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:producer]->(e_1:Resource{name:\"Werner Herzog\"}) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Werner Herzog"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "producer",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_56711",
    "answer": "Invincible"
  },
  {
    "graphq_ir": "what is the qualifier <Q> place of publication </Q> of <ES> <C> visual artwork </C> whose <A> official website </A> is text <V> https://www.warnerbros.com/matrix </V> </ES> whose <A> publication date </A> is <V> 1999-07-14 </V>",
    "kopl": "FindAll().FilterStr(official website,https://www.warnerbros.com/matrix).FilterConcept(visual artwork).QueryAttrQualifier(publication date,1999-07-14,place of publication)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <official_website> ?pv_1 . ?pv_1 <pred:value> \"https://www.warnerbros.com/matrix\" . ?e <publication_date> ?pv . ?pv <pred:date> \"1999-07-14\"^^xsd:date . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:visual_artwork) WHERE (n1.official_website = \"https://www.warnerbros.com/matrix\" AND n1.publication_date =  1999-07-14 )\nRETURN .place_of_publication",
    "question": "Where was the visual artwork with official website as https://www.warnerbros.com/matrix, published on 1999-07-14",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:official_website]->(pv_1:Resource{value:\"https://www.warnerbros.com/matrix\"}) match (e)-[:publication_date]->(pv:Resource{date:Date(\"1999-07-14\")}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "https://www.warnerbros.com/matrix"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "publication date",
          "1999-07-14",
          "place of publication"
        ]
      }
    ],
    "sample_id": "train_17101",
    "answer": "Sweden"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> MTV Movie Award for Most Desirable Female </E> that <R> winner </R> to <E> Janet Jackson </E>",
    "kopl": "Find(MTV Movie Award for Most Desirable Female).Find(Janet Jackson).QueryRelationQualifier(winner,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"MTV Movie Award for Most Desirable Female\" . ?e_2 <pred:name> \"Janet Jackson\" . ?e_1 <winner> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <winner> ; <pred:fact_t> ?e_2 ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"MTV Movie Award for Most Desirable Female\"\nMATCH (n2) WHERE n2.name = \"Janet Jackson\"\nMATCH (n1)-[r1:winner]->(n2)\nRETURN r1.point_in_time",
    "question": "At what time point did Janet Jackson win the MTV Movie Award for Most Desirable Female?",
    "cypher_match": "match (e_1:Resource{name:\"MTV Movie Award for Most Desirable Female\"})-[:winner]->(e_2:Resource{name:\"Janet Jackson\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"winner\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "MTV Movie Award for Most Desirable Female"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Janet Jackson"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "winner",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_20686",
    "answer": "1994"
  },
  {
    "graphq_ir": "whether <E> Ingrid Bergman </E> <A> Munzinger IBA </A> is text <V> 00000027205 </V>",
    "kopl": "Find(Ingrid Bergman).QueryAttr(Munzinger IBA).VerifyStr(00000027205)",
    "sparql": "ASK { ?e <pred:name> \"Ingrid Bergman\" . ?e <Munzinger_IBA> ?pv . ?pv <pred:value> \"00000027205\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Ingrid Bergman\" AND n1.Munzinger_IBA = \"00000027205\")\nRETURN isEmpty(n1)",
    "question": "Is the Munzinger IBA for Ingrid Bergman 00000027205 ?",
    "cypher_match": "match (e:Resource{name:\"Ingrid Bergman\"})-[:Munzinger_IBA]->(pv:Resource) return pv.value = \"00000027205\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Ingrid Bergman"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Munzinger IBA"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "00000027205"
        ]
      }
    ],
    "sample_id": "train_34463",
    "answer": "no"
  },
  {
    "graphq_ir": "what is <ES> <C> film festival edition </C> that <R> follows </R> forward to <E> 2010 Sundance Film Festival </E> </ES>",
    "kopl": "Find(2010 Sundance Film Festival).Relate(follows,backward).FilterConcept(film festival edition).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film festival edition\" . ?e <follows> ?e_1 . ?e_1 <pred:name> \"2010 Sundance Film Festival\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.film_festival_edition ) ( string ! type ) ) ( string follows ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"2010 Sundance Film Festival\"\nMATCH (n1:film_festival_edition)<-[r1:follows]-(n2)\nRETURN n1.name",
    "question": "What number was the edition of the Sundance Film Festival after 2010?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film festival edition\"}) match (e)-[:follows]->(e_1:Resource{name:\"2010 Sundance Film Festival\"}) return distinct e",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "2010 Sundance Film Festival"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "follows",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film festival edition"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_61044",
    "answer": "2011 Sundance Film Festival"
  },
  {
    "graphq_ir": "how many <ES> <C> film character </C> that <R> educated at </R> forward to <E> Boston University School of Law </E> </ES>",
    "kopl": "Find(Boston University School of Law).Relate(educated at,backward).FilterConcept(film character).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film character\" . ?e <educated_at> ?e_1 . ?e_1 <pred:name> \"Boston University School of Law\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.film_character ) ( string ! type ) ) ( string educated_at ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Boston University School of Law\"\nMATCH (n1:film_character)<-[r1:educated_at]-(n2)\nRETURN count(n1)",
    "question": "What number of movie characters were educated at Boston University School of Law?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film character\"}) match (e)-[:educated_at]->(e_1:Resource{name:\"Boston University School of Law\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Boston University School of Law"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "educated at",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film character"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_85100",
    "answer": "0"
  },
  {
    "graphq_ir": "what is <ES> <C> visual artwork </C> that <R> followed by </R> backward to <ES> <C> film </C> whose <A> official website </A> is text <V> http://web.archive.org/web/20061116073244/http://saw3.com/ </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(official website,http://web.archive.org/web/20061116073244/http://saw3.com/).FilterConcept(film).Relate(followed by,forward).FilterConcept(visual artwork).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e_1 <followed_by> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"film\" . ?e_1 <official_website> ?pv . ?pv <pred:value> \"http://web.archive.org/web/20061116073244/http://saw3.com/\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.visual_artwork ) ( string ! type ) ) ( call SW.reverse ( string followed_by ) ) ) )",
    "cypher": "MATCH (n2:film) WHERE n2.official_website = \"http://web.archive.org/web/20061116073244/http://saw3.com/\"\nMATCH (n1:visual_artwork)-[r1:followed_by]->(n2)\nRETURN n1.name",
    "question": "Which movie succeeds the movie whose official website is http://web.archive.org/web/20061116073244/http://saw3.com/?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e_1)-[:followed_by]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"film\"}) match (e_1)-[:official_website]->(pv:Resource{value:\"http://web.archive.org/web/20061116073244/http://saw3.com/\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://web.archive.org/web/20061116073244/http://saw3.com/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "followed by",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_49504",
    "answer": "Saw IV"
  },
  {
    "graphq_ir": "what is the qualifier <Q> end time </Q> of <E> Giovani dos Santos </E> that <R> member of sports team </R> to <E> RCD Mallorca </E>",
    "kopl": "Find(Giovani dos Santos).Find(RCD Mallorca).QueryRelationQualifier(member of sports team,end time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Giovani dos Santos\" . ?e_2 <pred:name> \"RCD Mallorca\" . ?e_1 <member_of_sports_team> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <member_of_sports_team> ; <pred:fact_t> ?e_2 ] <end_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Giovani dos Santos\"\nMATCH (n2) WHERE n2.name = \"RCD Mallorca\"\nMATCH (n1)-[r1:member_of_sports_team]->(n2)\nRETURN r1.end_time",
    "question": "I want to know the end time for Giovani dos Santos is an RCD Mallorca member.",
    "cypher_match": "match (e_1:Resource{name:\"Giovani dos Santos\"})-[:member_of_sports_team]->(e_2:Resource{name:\"RCD Mallorca\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"member_of_sports_team\"}),(tmp)-[:end_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Giovani dos Santos"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "RCD Mallorca"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "member of sports team",
          "end time"
        ]
      }
    ],
    "sample_id": "train_40533",
    "answer": "2013-01-01"
  },
  {
    "graphq_ir": "what is the relation from <E> Notting Hill </E> to <ES> <E> Hugh Grant </E> whose <A> CANTIC-ID </A> is text <V> a11752531 </V> </ES>",
    "kopl": "Find(Notting Hill).Find(Hugh Grant).FilterStr(CANTIC-ID,a11752531).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Notting Hill\" . ?e_2 <pred:name> \"Hugh Grant\" . ?e_2 <CANTIC-ID> ?pv . ?pv <pred:value> \"a11752531\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Notting Hill\"\nMATCH (n2) WHERE n2.name = \"Hugh Grant\"\nMATCH (n2) WHERE n2.CANTIC-ID = \"a11752531\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Notting Hill to Hugh Grant (the one whose CANTIC-ID is a11752531)?",
    "cypher_match": "match (e_2:Resource{name:\"Hugh Grant\"})-[:`CANTIC-ID`]->(pv:Resource{value:\"a11752531\"}) match (e_1:Resource{name:\"Notting Hill\"})-[p]->(e_2:Resource{name:\"Hugh Grant\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Notting Hill"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Hugh Grant"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "CANTIC-ID",
          "a11752531"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_60963",
    "answer": "cast member"
  },
  {
    "graphq_ir": "what is <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0001 2142 1582 </V> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0001 2142 1582).FilterConcept(human).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 2142 1582\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0001 2142 1582 ) ) )",
    "cypher": "MATCH (n1:human) WHERE n1.ISNI = \"0000 0001 2142 1582\"\nRETURN n1.name",
    "question": "Which person's ISNI is 0000 0001 2142 1582?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv:Resource{value:\"0000 0001 2142 1582\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0001 2142 1582"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_70507",
    "answer": "Vilmos Zsigmond"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <E> Jarhead </E> or <ES> <E> Yellow Submarine </E> (<ES> ones that <R> film release region </R> forward to <E> Hungary </E> </ES>) </ES> </ES>",
    "kopl": "Find(Jarhead).Find(Hungary).Relate(film release region,backward).Find(Yellow Submarine).And().Or().Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Jarhead\" .  } UNION { ?e <pred:name> \"Yellow Submarine\" . ?e <film_release_region> ?e_1 . ?e_1 <pred:name> \"Hungary\" .   } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Jarhead ( call SW.and en.Yellow_Submarine ( lambda s ( call SW.filter ( var s ) ( string film_release_region ) ( string = ) en.Hungary ) ) ) ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Jarhead\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Yellow Submarine\"\nMATCH (n2) WHERE n2.name = \"Hungary\"\nMATCH (n3)<-[r1:film_release_region]-(n2)\nRETURN n3.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Which is longer, Jarhead or Yellow Submarine whose release region is Hungary?",
    "cypher_match": "call { match (e:Resource{name:\"Jarhead\"}) return e union match (e:Resource{name:\"Yellow Submarine\"})-[:film_release_region]->(e_1:Resource{name:\"Hungary\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jarhead"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Hungary"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "film release region",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Yellow Submarine"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "duration",
          "greater"
        ]
      }
    ],
    "sample_id": "train_511",
    "answer": "Jarhead"
  },
  {
    "graphq_ir": "what is the relation from <E> 16 Blocks </E> to <E> Klaus Badelt </E>",
    "kopl": "Find(16 Blocks).Find(Klaus Badelt).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"16 Blocks\" . ?e_2 <pred:name> \"Klaus Badelt\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"16 Blocks\"\nMATCH (n2) WHERE n2.name = \"Klaus Badelt\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is 16 Blocks related to Klaus Badelt?",
    "cypher_match": "match (e_1:Resource{name:\"16 Blocks\"})-[p]->(e_2:Resource{name:\"Klaus Badelt\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "16 Blocks"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Klaus Badelt"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_48486",
    "answer": "composer"
  },
  {
    "graphq_ir": "what is the attribute <A> population </A> of <ES> <C> city </C> that <R> twinned administrative body </R> backward to <E> Tijuana </E> </ES>",
    "kopl": "Find(Tijuana).Relate(twinned administrative body,forward).FilterConcept(city).QueryAttr(population)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city\" . ?e_1 <twinned_administrative_body> ?e . ?e_1 <pred:name> \"Tijuana\" .  ?e <population> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.city ) ( string ! type ) ) ( call SW.reverse ( string twinned_administrative_body ) ) ) ( string population ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Tijuana\"\nMATCH (n1:city)-[r1:twinned_administrative_body]->(n2)\nRETURN n1.population",
    "question": "What is the population of the city that is twinned with Tijuana?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city\"}) match (e)-[:population]->(pv) match (e_1:Resource{name:\"Tijuana\"})-[:twinned_administrative_body]->(e) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tijuana"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "twinned administrative body",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "population"
        ]
      }
    ],
    "sample_id": "train_14379",
    "answer": "2141652"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <ES> <E> DeKalb County </E> whose <A> PermID </A> is text <V> 5037043580 </V> </ES> or <E> Boulder County </E> </ES>",
    "kopl": "Find(DeKalb County).FilterStr(PermID,5037043580).Find(Boulder County).Or().Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"DeKalb County\" . ?e <PermID> ?pv_1 . ?pv_1 <pred:value> \"5037043580\" . } UNION { ?e <pred:name> \"Boulder County\" . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.DeKalb_County ( string PermID ) ( string = ) ( string 5037043580 ) ) en.Boulder_County ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"DeKalb County\"\nMATCH (n1) WHERE n1.PermID = \"5037043580\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Boulder County\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Is there less area in DeKalb County (the one whose PermID is 5037043580) or Boulder County ?",
    "cypher_match": "call { match (e:Resource{name:\"DeKalb County\"})-[:PermID]->(pv_1:Resource{value:\"5037043580\"}) return e union match (e:Resource{name:\"Boulder County\"}) return e } match (e)-[:area]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "DeKalb County"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "PermID",
          "5037043580"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Boulder County"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "area",
          "less"
        ]
      }
    ],
    "sample_id": "train_51096",
    "answer": "DeKalb County"
  },
  {
    "graphq_ir": "what is the relation from <E> Cinderella Man </E> to <E> Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role </E>",
    "kopl": "Find(Cinderella Man).Find(Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Cinderella Man\" . ?e_2 <pred:name> \"Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Cinderella Man\"\nMATCH (n2) WHERE n2.name = \"Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is Cinderella Man related to the Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role?",
    "cypher_match": "match (e_1:Resource{name:\"Cinderella Man\"})-[p]->(e_2:Resource{name:\"Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Cinderella Man"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Screen Actors Guild Award for Outstanding Performance by a Male Actor in a Leading Role"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_65803",
    "answer": "nominated for"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> whose <A> name in native language </A> is text <V> Richard C. Clark </V> </ES> <A> ISNI </A> is text <V> 0000 0001 0707 9354 </V>",
    "kopl": "FindAll().FilterStr(name in native language,Richard C. Clark).FilterConcept(human).QueryAttr(ISNI).VerifyStr(0000 0001 0707 9354)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <name_in_native_language> ?pv_1 . ?pv_1 <pred:value> \"Richard C. Clark\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 0707 9354\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:human) WHERE (n1.name_in_native_language = \"Richard C. Clark\" AND n1.ISNI = \"0000 0001 0707 9354\")\nRETURN isEmpty(n1)",
    "question": "Is 0000 0001 0707 9354 the ISNI of the person whose native language name is Richard C. Clark?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:name_in_native_language]->(pv_1:Resource{value:\"Richard C. Clark\"}) match (e)-[:ISNI]->(pv:Resource) return pv.value = \"0000 0001 0707 9354\"",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "name in native language",
          "Richard C. Clark"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "ISNI"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "0000 0001 0707 9354"
        ]
      }
    ],
    "sample_id": "train_41800",
    "answer": "no"
  },
  {
    "graphq_ir": "what is <ES> <C> television film </C> that <R> cast member </R> forward to <E> Alan Cumming </E> </ES>",
    "kopl": "Find(Alan Cumming).Relate(cast member,backward).FilterConcept(television film).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"television film\" . ?e <cast_member> ?e_1 . ?e_1 <pred:name> \"Alan Cumming\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.television_film ) ( string ! type ) ) ( string cast_member ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Alan Cumming\"\nMATCH (n1:television_film)<-[r1:cast_member]-(n2)\nRETURN n1.name",
    "question": "Which TV film features Alan Cumming in the cast?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"television film\"}) match (e)-[:cast_member]->(e_1:Resource{name:\"Alan Cumming\"}) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Alan Cumming"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "cast member",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "television film"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_79103",
    "answer": "Annie"
  },
  {
    "graphq_ir": "what is the relation from <E> Delft </E> to <E> The Hague </E>",
    "kopl": "Find(Delft).Find(The Hague).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Delft\" . ?e_2 <pred:name> \"The Hague\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Delft\"\nMATCH (n2) WHERE n2.name = \"The Hague\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between Delft and The Hague?",
    "cypher_match": "match (e_1:Resource{name:\"Delft\"})-[p]->(e_2:Resource{name:\"The Hague\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Delft"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Hague"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_58240",
    "answer": "shares border with"
  },
  {
    "graphq_ir": "what is the relation from <E> FC Levadia Tallinn </E> to <E> green </E>",
    "kopl": "Find(FC Levadia Tallinn).Find(green).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"FC Levadia Tallinn\" . ?e_2 <pred:name> \"green\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"FC Levadia Tallinn\"\nMATCH (n2) WHERE n2.name = \"green\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between FC Levadia Tallinn and green?",
    "cypher_match": "match (e_1:Resource{name:\"FC Levadia Tallinn\"})-[p]->(e_2:Resource{name:\"green\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "FC Levadia Tallinn"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "green"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_32752",
    "answer": "official color"
  },
  {
    "graphq_ir": "what is the qualifier <Q> language of work or name </Q> of <ES> <C> city of the United States </C> whose <A> population </A> is number <V> 67947 </V> ( <Q> point in time </Q> is year <V> 2010 </V> ) </ES> whose <A> official website </A> is <V> http://www.santafenm.gov/ </V>",
    "kopl": "FindAll().FilterNum(population,67947,=).QFilterYear(point in time,2010,=).FilterConcept(city of the United States).QueryAttrQualifier(official website,http://www.santafenm.gov/,language of work or name)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <population> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> \"67947\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv_1 ] <point_in_time> ?qpv_1 . ?qpv_1 <pred:year> 2010 . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.santafenm.gov/\" . [ <pred:fact_h> ?e ; <pred:fact_r> <official_website> ; <pred:fact_t> ?pv ] <language_of_work_or_name> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE (n1.population =  67947  AND n1.official_website =  http://www.santafenm.gov/ )\nRETURN .language_of_work_or_name",
    "question": "What language is associated with the official website http://www.santafenm.gov/ for the United States city whose population is 67947 in the year 2010?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:population]->(pv_1:Resource{unit:\"1\",value:67947.0}) match (e)-[:official_website]->(pv:Resource{value:\"http://www.santafenm.gov/\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv_1), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv_1:Resource{year:2010}),(e)<-[:fact_h]-(tmp_1)-[:fact_t]->(pv), (tmp_1)-[:fact_r]-(qr_1:Relation{name:\"official_website\"}),(tmp_1)-[:language_of_work_or_name]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "67947",
          "="
        ]
      },
      {
        "function": "QFilterYear",
        "dependencies": [
          1
        ],
        "inputs": [
          "point in time",
          "2010",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          3
        ],
        "inputs": [
          "official website",
          "http://www.santafenm.gov/",
          "language of work or name"
        ]
      }
    ],
    "sample_id": "train_78009",
    "answer": "English"
  },
  {
    "graphq_ir": "what is the qualifier <Q> place of publication </Q> of <ES> <C> visual artwork </C> that <R> director of photography </R> forward to <ES> <E> Harry Stradling </E> whose <A> date of birth </A> is date <V> 1925-01-07 </V> </ES> </ES> whose <A> publication date </A> is <V> 1974-03-07 </V>",
    "kopl": "Find(Harry Stradling).FilterDate(date of birth,1925-01-07,=).Relate(director of photography,backward).FilterConcept(visual artwork).QueryAttrQualifier(publication date,1974-03-07,place of publication)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <director_of_photography> ?e_1 . ?e_1 <pred:name> \"Harry Stradling\" . ?e_1 <date_of_birth> ?pv_1 . ?pv_1 <pred:date> \"1925-01-07\"^^xsd:date . ?e <publication_date> ?pv . ?pv <pred:date> \"1974-03-07\"^^xsd:date . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Harry Stradling\"\nMATCH (n2) WHERE n2.date_of_birth =  1925-01-07 \nMATCH (n1:visual_artwork)<-[r1:director_of_photography]-(n2) WHERE n1.publication_date =  1974-03-07 \nRETURN r1.place_of_publication",
    "question": "What is the publication place of the visual artwork having Harry Stradling (who was born on 1925-01-07) as its director of photography and 1974-03-07 as its release date?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:director_of_photography]->(e_1:Resource{name:\"Harry Stradling\"}) match (e)-[:publication_date]->(pv:Resource{date:Date(\"1974-03-07\")}) match (e_1:Resource{name:\"Harry Stradling\"})-[:date_of_birth]->(pv_1:Resource{date:Date(\"1925-01-07\")}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Harry Stradling"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "date of birth",
          "1925-01-07",
          "="
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "director of photography",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          3
        ],
        "inputs": [
          "publication date",
          "1974-03-07",
          "place of publication"
        ]
      }
    ],
    "sample_id": "train_80884",
    "answer": "Germany"
  },
  {
    "graphq_ir": "what is the qualifier <Q> number of subscribers </Q> of <E> Sichuan </E> whose <A> subreddit </A> is <V> sichuan </V>",
    "kopl": "Find(Sichuan).QueryAttrQualifier(subreddit,sichuan,number of subscribers)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Sichuan\" . ?e <subreddit> ?pv . ?pv <pred:value> \"sichuan\" . [ <pred:fact_h> ?e ; <pred:fact_r> <subreddit> ; <pred:fact_t> ?pv ] <number_of_subscribers> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Sichuan\" AND n1.subreddit =  sichuan )\nRETURN .number_of_subscribers",
    "question": "How many subscribers does Sichuan have on its subreddit sichuan?",
    "cypher_match": "match (e:Resource{name:\"Sichuan\"})-[:subreddit]->(pv:Resource{value:\"sichuan\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"subreddit\"}),(tmp)-[:number_of_subscribers]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sichuan"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          0
        ],
        "inputs": [
          "subreddit",
          "sichuan",
          "number of subscribers"
        ]
      }
    ],
    "sample_id": "train_55165",
    "answer": "17"
  },
  {
    "graphq_ir": "what is the relation from <E> pop music </E> to <E> Paris Hilton </E>",
    "kopl": "Find(pop music).Find(Paris Hilton).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"pop music\" . ?e_2 <pred:name> \"Paris Hilton\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"pop music\"\nMATCH (n2) WHERE n2.name = \"Paris Hilton\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is Paris Hilton related to pop music?",
    "cypher_match": "match (e_1:Resource{name:\"pop music\"})-[p]->(e_2:Resource{name:\"Paris Hilton\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "pop music"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Paris Hilton"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_17951",
    "answer": "famous people"
  },
  {
    "graphq_ir": "what is the attribute <A> Instagram username </A> of <E> National Register of Historic Places </E>",
    "kopl": "Find(National Register of Historic Places).QueryAttr(Instagram username)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"National Register of Historic Places\" . ?e <Instagram_username> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.National_Register_of_Historic_Places ( string Instagram_username ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"National Register of Historic Places\"\nRETURN n1.Instagram_username",
    "question": "What is the Instagram username for National Register of Historic Places ?",
    "cypher_match": "match (e:Resource{name:\"National Register of Historic Places\"})-[:Instagram_username]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "National Register of Historic Places"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Instagram username"
        ]
      }
    ],
    "sample_id": "train_1467",
    "answer": "nationalregisternps"
  },
  {
    "graphq_ir": "how many <ES> <C> former French region </C> that <R> replaced by </R> forward to <ES> <C> region of France </C> whose <A> SIREN number </A> is text <V> 200053403 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(SIREN number,200053403).FilterConcept(region of France).Relate(replaced by,backward).FilterConcept(former French region).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"former French region\" . ?e <replaced_by> ?e_1 . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"region of France\" . ?e_1 <SIREN_number> ?pv_1 . ?pv_1 <pred:value> \"200053403\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.former_French_region ) ( string ! type ) ) ( string replaced_by ) ) ) )",
    "cypher": "MATCH (n2:region_of_France) WHERE n2.SIREN_number = \"200053403\"\nMATCH (n1:former_French_region)<-[r1:replaced_by]-(n2)\nRETURN count(n1)",
    "question": "For the region of France with the SIREN number 200053403, how many former French regions were replaced by it?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"former French region\"}) match (e)-[:replaced_by]->(e_1) match (e_1)-[:instance_of]->(c_1:Resource{name:\"region of France\"}) match (e_1)-[:SIREN_number]->(pv_1:Resource{value:\"200053403\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "SIREN number",
          "200053403"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "region of France"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "replaced by",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "former French region"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_28649",
    "answer": "2"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <ES> <E> Thomas Hardy </E> whose <A> date of death </A> is date <V> 1805-01-01 </V> </ES>",
    "kopl": "Find(Thomas Hardy).FilterDate(date of death,1805-01-01,=).QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Thomas Hardy\" . ?e <date_of_death> ?pv_1 . ?pv_1 <pred:date> \"1805-01-01\"^^xsd:date . ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter en.Thomas_Hardy ( string date_of_death ) ( string = ) ( date 1805-01-01 ) ) ( string ISNI ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Thomas Hardy\"\nMATCH (n1) WHERE n1.date_of_death =  1805-01-01 \nRETURN n1.ISNI",
    "question": "What is the ISNI for Thomas Hardy, who died 1805-01-01?",
    "cypher_match": "match (e:Resource{name:\"Thomas Hardy\"})-[:date_of_death]->(pv_1:Resource{date:Date(\"1805-01-01\")}) match (e:Resource{name:\"Thomas Hardy\"})-[:ISNI]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Thomas Hardy"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "date of death",
          "1805-01-01",
          "="
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          1
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_66424",
    "answer": "0000 0000 0888 5545"
  },
  {
    "graphq_ir": "which one has the largest <A> number of episodes </A> among <ES> <C> comedy </C> that <R> genre </R> forward to <E> situation comedy </E> </ES>",
    "kopl": "Find(situation comedy).Relate(genre,backward).FilterConcept(comedy).Select(number of episodes,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"comedy\" . ?e <genre> ?e_1 . ?e_1 <pred:name> \"situation comedy\" .  ?e <number_of_episodes> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.comedy ) ( string ! type ) ) ( string genre ) ) ( string max ) ( string number_of_episodes ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"situation comedy\"\nMATCH (n1:comedy)<-[r1:genre]-(n2)\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nLIMIT 1",
    "question": "Of all the comedies in the situation comedy genre, which was the most episodes?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"comedy\"}) match (e)-[:genre]->(e_1:Resource{name:\"situation comedy\"}) match (e)-[:number_of_episodes]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "situation comedy"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "genre",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "comedy"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "number of episodes",
          "largest"
        ]
      }
    ],
    "sample_id": "train_3112",
    "answer": "The Golden Girls"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> nominated for </R> forward to <E> Tony Award for Best Actress in a Play </E> ( <Q> point in time </Q> is year <V> 1991 </V> ) </ES> <A> Deutsche Synchronkartei actor-ID </A> is text <V> 71675 </V>",
    "kopl": "Find(Tony Award for Best Actress in a Play).Relate(nominated for,backward).QFilterYear(point in time,1991,=).FilterConcept(human).QueryAttr(Deutsche Synchronkartei actor-ID).VerifyStr(71675)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Tony Award for Best Actress in a Play\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <point_in_time> ?qpv . ?qpv <pred:year> 1991 . ?e <Deutsche_Synchronkartei_actor-ID> ?pv . ?pv <pred:value> \"71675\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Tony Award for Best Actress in a Play\"\nMATCH (n1:human)<-[r1:nominated_for]-(n2) WHERE (r1.point_in_time =  1991  AND n1.Deutsche_Synchronkartei_actor-ID = \"71675\")\nRETURN isEmpty(n1)",
    "question": "Is 71675 the Deutsche Synchronkartei actor-ID of the person that was nominated for a Tony Award for Best Actress in a Play in 1991?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:nominated_for]->(e_1:Resource{name:\"Tony Award for Best Actress in a Play\"}) match (e)-[:`Deutsche_Synchronkartei_actor-ID`]->(pv:Resource),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:point_in_time]->(qpv:Resource{year:1991}) return pv.value = \"71675\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tony Award for Best Actress in a Play"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "QFilterYear",
        "dependencies": [
          1
        ],
        "inputs": [
          "point in time",
          "1991",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "Deutsche Synchronkartei actor-ID"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          4
        ],
        "inputs": [
          "71675"
        ]
      }
    ],
    "sample_id": "train_21561",
    "answer": "no"
  },
  {
    "graphq_ir": "whether <ES> <E> Michael Winterbottom </E> (<ES> ones that <R> educated at </R> forward to <E> Dulwich College </E> </ES>) </ES> <A> ISNI </A> is text <V> 0000 0001 2144 6958 </V>",
    "kopl": "Find(Dulwich College).Relate(educated at,backward).Find(Michael Winterbottom).And().QueryAttr(ISNI).VerifyStr(0000 0001 2144 6958)",
    "sparql": "ASK { ?e <pred:name> \"Michael Winterbottom\" . ?e <educated_at> ?e_1 . ?e_1 <pred:name> \"Dulwich College\" .  ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 2144 6958\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE (n3.name = \"Michael Winterbottom\" AND n3.ISNI = \"0000 0001 2144 6958\")\nMATCH (n2) WHERE n2.name = \"Dulwich College\"\nMATCH (n3)<-[r1:educated_at]-(n2)\nRETURN isEmpty(n3)",
    "question": "Does Michael Winterbottom, who was educated at Dulwich College, have an ISNI of 0000 0001 2144 6958?",
    "cypher_match": "match (e:Resource{name:\"Michael Winterbottom\"})-[:educated_at]->(e_1:Resource{name:\"Dulwich College\"}) match (e:Resource{name:\"Michael Winterbottom\"})-[:ISNI]->(pv:Resource) return pv.value = \"0000 0001 2144 6958\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dulwich College"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "educated at",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Michael Winterbottom"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          4
        ],
        "inputs": [
          "0000 0001 2144 6958"
        ]
      }
    ],
    "sample_id": "train_35679",
    "answer": "no"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> sovereign state </C> whose <A> Human Development Index </A> smaller than number <V> 1.0 </V> </ES> or <ES> <C> sovereign state </C> whose <A> area </A> larger than number <V> 45 square versta </V> </ES> </ES>",
    "kopl": "FindAll().FilterNum(Human Development Index,1.0,<).FilterConcept(sovereign state).FindAll().FilterNum(area,45 square versta,>).FilterConcept(sovereign state).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"sovereign state\" .  { ?e <Human_Development_Index> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v < \"1.0\"^^xsd:double ) .  } UNION { ?e <area> ?pv . ?pv <pred:unit> \"square versta\" . ?pv <pred:value> ?v . FILTER ( ?v > \"45\"^^xsd:double ) .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.sovereign_state ) ( string ! type ) ) ( string Human_Development_Index ) ( string < ) ( number 1.0 ) ) ( call SW.filter ( getProperty ( singleton en.sovereign_state ) ( string ! type ) ) ( string area ) ( string > ) ( number 45 square versta ) ) ) ) )",
    "cypher": "MATCH (n1:sovereign_state) WHERE n1.Human_Development_Index <  1.0 \nRETURN count(n1)\nUNION\nMATCH (n1:sovereign_state) WHERE n1.area >  45 square versta \nRETURN count(n1)",
    "question": "How many sovereign states have a Human Development Index value below 1.0 or occupy more than 45 square verstas?",
    "cypher_match": "call { match (e)-[:Human_Development_Index]->(pv:Resource{unit:\"1\"})  where pv.value <  1.0  return e union match (e)-[:area]->(pv:Resource{unit:\"square versta\"})  where pv.value >  45.0  return e } match (e)-[:instance_of]->(c:Resource{name:\"sovereign state\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "Human Development Index",
          "1.0",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "area",
          "45 square versta",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_10863",
    "answer": "123"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0000 6310 5556 </V> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0000 6310 5556).FilterConcept(human).QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv_1 . ?pv_1 <pred:value> \"0000 0000 6310 5556\" . ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0000 6310 5556 ) ) ( string official_website ) ) )",
    "cypher": "MATCH (n1:human) WHERE n1.ISNI = \"0000 0000 6310 5556\"\nRETURN n1.official_website",
    "question": "What is the official website of the person with ISNI 0000 0000 6310 5556?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv_1:Resource{value:\"0000 0000 6310 5556\"}) match (e)-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0000 6310 5556"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_70544",
    "answer": "http://www.gwenstefani.com"
  },
  {
    "graphq_ir": "what is the relation from <E> Jeremy Renner </E> to <E> Modesto </E>",
    "kopl": "Find(Jeremy Renner).Find(Modesto).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Jeremy Renner\" . ?e_2 <pred:name> \"Modesto\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Jeremy Renner\"\nMATCH (n2) WHERE n2.name = \"Modesto\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is Jeremy Renner connected to Modesto?",
    "cypher_match": "match (e_1:Resource{name:\"Jeremy Renner\"})-[p]->(e_2:Resource{name:\"Modesto\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jeremy Renner"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Modesto"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_48570",
    "answer": "place of birth"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> university </C> whose <A> postal code </A> is text <V> 58202-8193 </V> </ES> or <ES> <C> university </C> whose <A> ISNI </A> is text <V> 0000 0001 2336 6580 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(postal code,58202-8193).FilterConcept(university).FindAll().FilterStr(ISNI,0000 0001 2336 6580).FilterConcept(university).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"university\" .  { ?e <postal_code> ?pv . ?pv <pred:value> \"58202-8193\" .  } UNION { ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 2336 6580\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.university ) ( string ! type ) ) ( string postal_code ) ( string = ) ( string 58202-8193 ) ) ( call SW.filter ( getProperty ( singleton en.university ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0001 2336 6580 ) ) ) ) )",
    "cypher": "MATCH (n1:university) WHERE n1.postal_code = \"58202-8193\"\nRETURN count(n1)\nUNION\nMATCH (n1:university) WHERE n1.ISNI = \"0000 0001 2336 6580\"\nRETURN count(n1)",
    "question": "How many universities have postal code 58202-8193 or have ISNI 0000 0001 2336 6580?",
    "cypher_match": "call { match (e)-[:postal_code]->(pv:Resource{value:\"58202-8193\"}) return e union match (e)-[:ISNI]->(pv:Resource{value:\"0000 0001 2336 6580\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"university\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "postal code",
          "58202-8193"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "university"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI",
          "0000 0001 2336 6580"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "university"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_82492",
    "answer": "2"
  },
  {
    "graphq_ir": "what is the qualifier <Q> statement is subject of </Q> of <ES> <E> Days of Thunder </E> (<ES> ones that <R> film release region </R> forward to <E> United States of America </E> </ES>) </ES> that <R> nominated for </R> to <E> Academy Award for Best Sound Mixing </E>",
    "kopl": "Find(United States of America).Relate(film release region,backward).Find(Days of Thunder).And().Find(Academy Award for Best Sound Mixing).QueryRelationQualifier(nominated for,statement is subject of)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Days of Thunder\" . ?e_1 <film_release_region> ?e_3 . ?e_3 <pred:name> \"United States of America\" . ?e_2 <pred:name> \"Academy Award for Best Sound Mixing\" . ?e_1 <nominated_for> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_2 ] <statement_is_subject_of> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Days of Thunder\"\nMATCH (n2) WHERE n2.name = \"United States of America\"\nMATCH (n3)<-[r1:film_release_region]-(n2)\nMATCH (n4) WHERE n4.name = \"Academy Award for Best Sound Mixing\"\nMATCH (n3)-[r2:nominated_for]->(n4)\nRETURN r2.statement_is_subject_of",
    "question": "What is the subject of a statement saying that  Days of Thunder (the one whose release region is United States of America) was nominated for Academy Award for Best Sound Mixing ?",
    "cypher_match": "match (e_1:Resource{name:\"Days of Thunder\"})-[:film_release_region]->(e_3:Resource{name:\"United States of America\"}) match (e_1:Resource{name:\"Days of Thunder\"})-[:nominated_for]->(e_2:Resource{name:\"Academy Award for Best Sound Mixing\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:statement_is_subject_of]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "United States of America"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "film release region",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Days of Thunder"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Sound Mixing"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "nominated for",
          "statement is subject of"
        ]
      }
    ],
    "sample_id": "train_31155",
    "answer": "63rd Academy Awards"
  },
  {
    "graphq_ir": "what is the qualifier <Q> nominee </Q> of <E> Blade Runner </E> that <R> nominated for </R> to <E> BAFTA Award for Best Editing </E>",
    "kopl": "Find(Blade Runner).Find(BAFTA Award for Best Editing).QueryRelationQualifier(nominated for,nominee)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Blade Runner\" . ?e_2 <pred:name> \"BAFTA Award for Best Editing\" . ?e_1 <nominated_for> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_2 ] <nominee> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Blade Runner\"\nMATCH (n2) WHERE n2.name = \"BAFTA Award for Best Editing\"\nMATCH (n1)-[r1:nominated_for]->(n2)\nRETURN r1.nominee",
    "question": "Who is the nominee connected to the nomination of the film Blade Runner for a BAFTA Award for Best Editing?",
    "cypher_match": "match (e_1:Resource{name:\"Blade Runner\"})-[:nominated_for]->(e_2:Resource{name:\"BAFTA Award for Best Editing\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:nominee]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Blade Runner"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "BAFTA Award for Best Editing"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "nominated for",
          "nominee"
        ]
      }
    ],
    "sample_id": "train_81282",
    "answer": "Terry Rawlings"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Michelangelo </E> whose <A> name in native language </A> is text <V> Michelangelo </V> </ES> to <E> ninja </E>",
    "kopl": "Find(Michelangelo).FilterStr(name in native language,Michelangelo).Find(ninja).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Michelangelo\" . ?e_1 <name_in_native_language> ?pv . ?pv <pred:value> \"Michelangelo\" . ?e_2 <pred:name> \"ninja\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Michelangelo\"\nMATCH (n1) WHERE n1.name_in_native_language = \"Michelangelo\"\nMATCH (n2) WHERE n2.name = \"ninja\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "Michelangelo (native language name Michelangelo) has what connection to a ninja?",
    "cypher_match": "match (e_1:Resource{name:\"Michelangelo\"})-[:name_in_native_language]->(pv:Resource{value:\"Michelangelo\"}) match (e_1:Resource{name:\"Michelangelo\"})-[p]->(e_2:Resource{name:\"ninja\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Michelangelo"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "name in native language",
          "Michelangelo"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "ninja"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_73797",
    "answer": "occupation"
  },
  {
    "graphq_ir": "what is the qualifier <Q> located in the administrative territorial entity </Q> of <ES> <C> pome </C> whose <A> total produced </A> is number <V> 590016000 pound </V> </ES> whose <A> total produced </A> is <V> 280014000 pound </V>",
    "kopl": "FindAll().FilterNum(total produced,590016000 pound,=).FilterConcept(pome).QueryAttrQualifier(total produced,280014000 pound,located in the administrative territorial entity)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"pome\" . ?e <total_produced> ?pv_1 . ?pv_1 <pred:unit> \"pound\" . ?pv_1 <pred:value> \"590016000\"^^xsd:double . ?e <total_produced> ?pv . ?pv <pred:unit> \"pound\" . ?pv <pred:value> \"280014000\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <total_produced> ; <pred:fact_t> ?pv ] <located_in_the_administrative_territorial_entity> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:pome) WHERE (n1.total_produced =  590016000 pound  AND n1.total_produced =  280014000 pound )\nRETURN .located_in_the_administrative_territorial_entity",
    "question": "Where are the administrative offices located for the company Pome which produced 280014000 pounds of product?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"pome\"}) match (e)-[:total_produced]->(pv_1:Resource{unit:\"pound\",value:590016000.0}) match (e)-[:total_produced]->(pv:Resource{unit:\"pound\",value:280014000.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"total_produced\"}),(tmp)-[:located_in_the_administrative_territorial_entity]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "total produced",
          "590016000 pound",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "pome"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "total produced",
          "280014000 pound",
          "located in the administrative territorial entity"
        ]
      }
    ],
    "sample_id": "train_78816",
    "answer": "California"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> sovereign state </C> that <R> diplomatic relation </R> backward to <E> Taiwan </E> ( <Q> statement is subject of </Q> is text <V> East Timor–Taiwan relations </V> ) </ES> whose <A> population </A> is <V> 1148958 </V>",
    "kopl": "Find(Taiwan).Relate(diplomatic relation,forward).QFilterStr(statement is subject of,East Timor–Taiwan relations).FilterConcept(sovereign state).QueryAttrQualifier(population,1148958,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"sovereign state\" . ?e_1 <diplomatic_relation> ?e . ?e_1 <pred:name> \"Taiwan\" . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <diplomatic_relation> ; <pred:fact_t> ?e ] <statement_is_subject_of> ?qpv_1 . ?qpv_1 <pred:value> \"East Timor–Taiwan relations\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"1148958\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Taiwan\"\nMATCH (n1:sovereign_state)-[r1:diplomatic_relation]->(n2) WHERE (r1.statement_is_subject_of = \"East Timor–Taiwan relations\" AND n1.population =  1148958 )\nRETURN r1.point_in_time",
    "question": "At what point in time is 1148958 the population of the sovereign state has has East Timor-Taiwan diplomatic relations with Taiwan?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"sovereign state\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:1148958.0}) match (e_1:Resource{name:\"Taiwan\"})-[:diplomatic_relation]->(e),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e), (tmp)-[:fact_r]-(qr:Relation{name:\"diplomatic_relation\"}),(tmp)-[:statement_is_subject_of]->(qpv_1:Resource{value:\"East Timor–Taiwan relations\"}),(e)<-[:fact_h]-(tmp_1)-[:fact_t]->(pv), (tmp_1)-[:fact_r]-(qr_1:Relation{name:\"population\"}),(tmp_1)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Taiwan"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "diplomatic relation",
          "forward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "statement is subject of",
          "East Timor–Taiwan relations"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          3
        ],
        "inputs": [
          "population",
          "1148958",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_7748",
    "answer": "2012"
  },
  {
    "graphq_ir": "which one has the smallest <A> duration </A> among <ES> <ES> <E> Speed </E> (<ES> ones that <R> award received </R> forward to <E> Academy Award for Best Sound Mixing </E> </ES>) </ES> or <ES> <E> Star Wars: The Clone Wars </E> (<ES> ones that <R> production company </R> forward to <E> Warner Bros. </E> </ES>) </ES> </ES>",
    "kopl": "Find(Academy Award for Best Sound Mixing).Relate(award received,backward).Find(Speed).And().Find(Warner Bros.).Relate(production company,backward).Find(Star Wars: The Clone Wars).And().Or().Select(duration,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Speed\" . ?e <award_received> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Sound Mixing\" .   } UNION { ?e <pred:name> \"Star Wars: The Clone Wars\" . ?e <production_company> ?e_2 . ?e_2 <pred:name> \"Warner Bros.\" .  } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.Speed ( lambda s ( call SW.filter ( var s ) ( string award_received ) ( string = ) en.Academy_Award_for_Best_Sound_Mixing ) ) ) ( call SW.and en.Star_Wars:_The_Clone_Wars ( lambda s ( call SW.filter ( var s ) ( string production_company ) ( string = ) en.Warner_Bros. ) ) ) ) ( string min ) ( string duration ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Speed\"\nMATCH (n2) WHERE n2.name = \"Academy Award for Best Sound Mixing\"\nMATCH (n3)<-[r1:award_received]-(n2)\nRETURN n3.name AS name\nORDER BY n3.duration DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Star Wars: The Clone Wars\"\nMATCH (n2) WHERE n2.name = \"Warner Bros.\"\nMATCH (n3)<-[r1:production_company]-(n2)\nRETURN n3.name AS name\nORDER BY n3.duration DESC\nLIMIT 1",
    "question": "Which movie is shorter, Speed (the one that received Academy Award for Best Sound Mixing) or Star Wars: The Clone Wars (the one whose production company is Warner Bros.)?",
    "cypher_match": "call { match (e:Resource{name:\"Speed\"})-[:award_received]->(e_1:Resource{name:\"Academy Award for Best Sound Mixing\"}) return e union match (e:Resource{name:\"Star Wars: The Clone Wars\"})-[:production_company]->(e_2:Resource{name:\"Warner Bros.\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Sound Mixing"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Speed"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Warner Bros."
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          4
        ],
        "inputs": [
          "production company",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Star Wars: The Clone Wars"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          5,
          6
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          7
        ],
        "inputs": [
          "duration",
          "less"
        ]
      }
    ],
    "sample_id": "train_62671",
    "answer": "Star Wars: The Clone Wars"
  },
  {
    "graphq_ir": "what is the relation from <E> Joseph L. Mankiewicz </E> to <E> 23rd Academy Awards </E>",
    "kopl": "Find(Joseph L. Mankiewicz).Find(23rd Academy Awards).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Joseph L. Mankiewicz\" . ?e_2 <pred:name> \"23rd Academy Awards\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Joseph L. Mankiewicz\"\nMATCH (n2) WHERE n2.name = \"23rd Academy Awards\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Joseph L. Mankiewicz and the 23rd Academy Awards?",
    "cypher_match": "match (e_1:Resource{name:\"Joseph L. Mankiewicz\"})-[p]->(e_2:Resource{name:\"23rd Academy Awards\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Joseph L. Mankiewicz"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "23rd Academy Awards"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_13094",
    "answer": "award received"
  },
  {
    "graphq_ir": "whether <E> Jake Shimabukuro </E> <A> official website </A> is text <V> http://www.jakeshimabukuro.com/ </V>",
    "kopl": "Find(Jake Shimabukuro).QueryAttr(official website).VerifyStr(http://www.jakeshimabukuro.com/)",
    "sparql": "ASK { ?e <pred:name> \"Jake Shimabukuro\" . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.jakeshimabukuro.com/\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Jake Shimabukuro\" AND n1.official_website = \"http://www.jakeshimabukuro.com/\")\nRETURN isEmpty(n1)",
    "question": "Is the official website of Jake Shimabukuro http://www.jakeshimabukuro.com/?",
    "cypher_match": "match (e:Resource{name:\"Jake Shimabukuro\"})-[:official_website]->(pv:Resource) return pv.value = \"http://www.jakeshimabukuro.com/\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jake Shimabukuro"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "http://www.jakeshimabukuro.com/"
        ]
      }
    ],
    "sample_id": "train_58763",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the qualifier <Q> number of matches played/races/starts </Q> of <E> Chris Nurse </E> that <R> member of sports team </R> to <E> Fort Lauderdale Strikers </E>",
    "kopl": "Find(Chris Nurse).Find(Fort Lauderdale Strikers).QueryRelationQualifier(member of sports team,number of matches played/races/starts)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Chris Nurse\" . ?e_2 <pred:name> \"Fort Lauderdale Strikers\" . ?e_1 <member_of_sports_team> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <member_of_sports_team> ; <pred:fact_t> ?e_2 ] <number_of_matches_played/races/starts> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Chris Nurse\"\nMATCH (n2) WHERE n2.name = \"Fort Lauderdale Strikers\"\nMATCH (n1)-[r1:member_of_sports_team]->(n2)\nRETURN r1.number_of_matches_played/races/starts",
    "question": "Chris Nurse had how many match appearances as a member of the Fort Lauderdale Strikers?",
    "cypher_match": "match (e_1:Resource{name:\"Chris Nurse\"})-[:member_of_sports_team]->(e_2:Resource{name:\"Fort Lauderdale Strikers\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"member_of_sports_team\"}),(tmp)-[:`number_of_matches_played/races/starts`]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Chris Nurse"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Fort Lauderdale Strikers"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "member of sports team",
          "number of matches played/races/starts"
        ]
      }
    ],
    "sample_id": "train_64111",
    "answer": "16"
  },
  {
    "graphq_ir": "whether <ES> <C> city of the United States </C> that <R> place of death </R> backward to <E> Nathanael Greene </E> </ES> <A> local dialing code </A> is text <V> 912 </V>",
    "kopl": "Find(Nathanael Greene).Relate(place of death,forward).FilterConcept(city of the United States).QueryAttr(local dialing code).VerifyStr(912)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e_1 <place_of_death> ?e . ?e_1 <pred:name> \"Nathanael Greene\" .  ?e <local_dialing_code> ?pv . ?pv <pred:value> \"912\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Nathanael Greene\"\nMATCH (n1:city_of_the_United_States)-[r1:place_of_death]->(n2) WHERE n1.local_dialing_code = \"912\"\nRETURN isEmpty(n1)",
    "question": "Does the U.S. city where Nathanael Greene died have the local dialing code of 912?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:local_dialing_code]->(pv:Resource) match (e_1:Resource{name:\"Nathanael Greene\"})-[:place_of_death]->(e) return pv.value = \"912\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Nathanael Greene"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "place of death",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "local dialing code"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "912"
        ]
      }
    ],
    "sample_id": "train_33390",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <E> David Foster </E> (<ES> ones that <R> country of citizenship </R> forward to <E> Canada </E> </ES>) </ES> that <R> award received </R> to <E> Grammy Award for Best Musical Theater Album </E>",
    "kopl": "Find(Canada).Relate(country of citizenship,backward).Find(David Foster).And().Find(Grammy Award for Best Musical Theater Album).QueryRelationQualifier(award received,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"David Foster\" . ?e_1 <country_of_citizenship> ?e_3 . ?e_3 <pred:name> \"Canada\" . ?e_2 <pred:name> \"Grammy Award for Best Musical Theater Album\" . ?e_1 <award_received> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <award_received> ; <pred:fact_t> ?e_2 ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"David Foster\"\nMATCH (n2) WHERE n2.name = \"Canada\"\nMATCH (n3)<-[r1:country_of_citizenship]-(n2)\nMATCH (n4) WHERE n4.name = \"Grammy Award for Best Musical Theater Album\"\nMATCH (n3)-[r2:award_received]->(n4)\nRETURN r2.point_in_time",
    "question": "When did David Foster (the one that is the citizen of Canada) receive Grammy Award for Best Musical Theater Album ?",
    "cypher_match": "match (e_1:Resource{name:\"David Foster\"})-[:country_of_citizenship]->(e_3:Resource{name:\"Canada\"}) match (e_1:Resource{name:\"David Foster\"})-[:award_received]->(e_2:Resource{name:\"Grammy Award for Best Musical Theater Album\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"award_received\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Canada"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "country of citizenship",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "David Foster"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Grammy Award for Best Musical Theater Album"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "award received",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_62528",
    "answer": "1982"
  },
  {
    "graphq_ir": "what is the qualifier <Q> start time </Q> of <ES> <E> Chicago </E> whose <A> demonym </A> is text <V> Chicagoan </V> </ES> that <R> twinned administrative body </R> to <E> Belgrade </E>",
    "kopl": "Find(Chicago).FilterStr(demonym,Chicagoan).Find(Belgrade).QueryRelationQualifier(twinned administrative body,start time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Chicago\" . ?e_1 <demonym> ?pv . ?pv <pred:value> \"Chicagoan\" . ?e_2 <pred:name> \"Belgrade\" . ?e_1 <twinned_administrative_body> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <twinned_administrative_body> ; <pred:fact_t> ?e_2 ] <start_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Chicago\"\nMATCH (n1) WHERE n1.demonym = \"Chicagoan\"\nMATCH (n2) WHERE n2.name = \"Belgrade\"\nMATCH (n1)-[r1:twinned_administrative_body]->(n2)\nRETURN r1.start_time",
    "question": "When did Chicago whose demonym is Chicagoan become the twinned administrative body of Belgrade?",
    "cypher_match": "match (e_1:Resource{name:\"Chicago\"})-[:demonym]->(pv:Resource{value:\"Chicagoan\"}) match (e_1:Resource{name:\"Chicago\"})-[:twinned_administrative_body]->(e_2:Resource{name:\"Belgrade\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"twinned_administrative_body\"}),(tmp)-[:start_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Chicago"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "demonym",
          "Chicagoan"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Belgrade"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "twinned administrative body",
          "start time"
        ]
      }
    ],
    "sample_id": "train_45379",
    "answer": "2005-06-01"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> basketball team </C> whose <A> subreddit </A> is text <V> rockets </V> </ES> or <ES> <C> basketball team </C> that <R> seed team </R> backward to <E> 1993 NCAA Men's Division I Basketball Tournament </E> </ES> </ES>",
    "kopl": "FindAll().FilterStr(subreddit,rockets).FilterConcept(basketball team).Find(1993 NCAA Men's Division I Basketball Tournament).Relate(seed team,forward).FilterConcept(basketball team).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"basketball team\" .  { ?e <subreddit> ?pv . ?pv <pred:value> \"rockets\" .  } UNION { ?e_1 <seed_team> ?e . ?e_1 <pred:name> \"1993 NCAA Men's Division I Basketball Tournament\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.basketball_team ) ( string ! type ) ) ( string subreddit ) ( string = ) ( string rockets ) ) ( call SW.filter ( getProperty ( singleton en.basketball_team ) ( string ! type ) ) ( call SW.reverse ( string seed_team ) ) ) ) ) )",
    "cypher": "MATCH (n1:basketball_team) WHERE n1.subreddit = \"rockets\"\nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"1993 NCAA Men's Division I Basketball Tournament\"\nMATCH (n1:basketball_team)-[r1:seed_team]->(n2)\nRETURN count(n1)",
    "question": "How many basketball team we know with the 'rockets' subreddit or that were seeded in 1993 NCAA Men's Division I Basketball Tournament ?",
    "cypher_match": "call { match (e)-[:subreddit]->(pv:Resource{value:\"rockets\"}) return e union match (e_1:Resource{name:\"1993 NCAA Men's Division I Basketball Tournament\"})-[:seed_team]->(e) return e } match (e)-[:instance_of]->(c:Resource{name:\"basketball team\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "subreddit",
          "rockets"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "basketball team"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "1993 NCAA Men's Division I Basketball Tournament"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "seed team",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "basketball team"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_81012",
    "answer": "5"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <E> Til Schweiger </E>",
    "kopl": "Find(Til Schweiger).QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Til Schweiger\" . ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Til_Schweiger ( string ISNI ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Til Schweiger\"\nRETURN n1.ISNI",
    "question": "Which ISNI code belongs to Til Schweiger?",
    "cypher_match": "match (e:Resource{name:\"Til Schweiger\"})-[:ISNI]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Til Schweiger"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_43105",
    "answer": "0000 0001 1497 4293"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> martial arts </C> that <R> sport </R> backward to <E> Johnny Yong Bosch </E> </ES> and <ES> <C> martial arts </C> that <R> country </R> forward to <E> Japan </E> </ES> </ES>",
    "kopl": "Find(Johnny Yong Bosch).Relate(sport,forward).FilterConcept(martial arts).Find(Japan).Relate(country,backward).FilterConcept(martial arts).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"martial arts\" . ?e_1 <sport> ?e . ?e_1 <pred:name> \"Johnny Yong Bosch\" .  ?e <country> ?e_2 . ?e_2 <pred:name> \"Japan\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.and ( call SW.filter ( getProperty ( singleton en.martial_arts ) ( string ! type ) ) ( call SW.reverse ( string sport ) ) ) ( call SW.filter ( getProperty ( singleton en.martial_arts ) ( string ! type ) ) ( string country ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Johnny Yong Bosch\"\nMATCH (n3:martial_arts)-[r1:sport]->(n2)\nMATCH (n2) WHERE n2.name = \"Japan\"\nMATCH (n3:martial_arts)<-[r1:country]-(n2)\nRETURN n3.name",
    "question": "Which martial arts has the sports team of Johnny Yong Bosch and the country of Japan?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"martial arts\"}) match (e)-[:country]->(e_2:Resource{name:\"Japan\"}) match (e_1:Resource{name:\"Johnny Yong Bosch\"})-[:sport]->(e) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Johnny Yong Bosch"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "sport",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "martial arts"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Japan"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "martial arts"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_84186",
    "answer": "judo"
  },
  {
    "graphq_ir": "whether <ES> <C> visual artwork </C> whose <A> title </A> is text <V> Born on the Fourth of July </V> </ES> <A> publication date </A> is year <V> 1991 </V> ( <Q> place of publication </Q> is <V> Germany </V> )",
    "kopl": "FindAll().FilterStr(title,Born on the Fourth of July).FilterConcept(visual artwork).QueryAttrUnderCondition(publication date,place of publication,Germany).VerifyYear(1991,=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e <title> ?pv_1 . ?pv_1 <pred:value> \"Born on the Fourth of July\" . ?e <publication_date> ?pv . ?pv <pred:year> 1991 . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv . ?qpv <pred:value> \"Germany\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:visual_artwork) WHERE (n1.title = \"Born on the Fourth of July\" AND n1.publication_date =  1991 )\nRETURN isEmpty(n1)",
    "question": "Was the film Born on the Fourth of July released in Germany in 1991?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e)-[:title]->(pv_1:Resource{value:\"Born on the Fourth of July\"}) match (e)-[:publication_date]->(pv:Resource{year:1991}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv:Resource{value:\"Germany\"}) return pv.year = 1991",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "Born on the Fourth of July"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "QueryAttrUnderCondition",
        "dependencies": [
          2
        ],
        "inputs": [
          "publication date",
          "place of publication",
          "Germany"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1991",
          "="
        ]
      }
    ],
    "sample_id": "train_29562",
    "answer": "no"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> human </C> whose <A> work period (start) </A> larger than year <V> 1951 </V> </ES> and <ES> <C> human </C> whose <A> audio recording of the subject's spoken voice </A> is text <V> Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac </V> </ES> </ES>",
    "kopl": "FindAll().FilterYear(work period (start),1951,>).FilterConcept(human).FindAll().FilterStr(audio recording of the subject's spoken voice,Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac).FilterConcept(human).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <work_period_(start)> ?pv . ?pv <pred:year> ?v . FILTER ( ?v > 1951 ) . ?e <audio_recording_of_the_subject's_spoken_voice> ?pv_1 . ?pv_1 <pred:value> \"Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.and ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string work_period_(start) ) ( string > ) ( year 1951 ) ) ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string audio_recording_of_the_subject's_spoken_voice ) ( string = ) ( string Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac ) ) ) )",
    "cypher": "MATCH (n2:human) WHERE n2.work_period_(start) >  1951 \nMATCH (n2:human) WHERE n2.audio_recording_of_the_subject's_spoken_voice = \"Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac\"\nRETURN n2.name",
    "question": "Who is the individual whose spoken voice is heard at Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac and whose career began after 1951?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:`work_period_(start)`]->(pv) match (e)-[:`audio_recording_of_the_subject's_spoken_voice`]->(pv_1:Resource{value:\"Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac\"}) where pv.year > 1951 return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "work period (start)",
          "1951",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "audio recording of the subject's spoken voice",
          "Dustin hoffman bbc radio4 desert island discs 02 12 2012 b01p314n.flac"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_21671",
    "answer": "Dustin Hoffman"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> city of the United States </C> whose <A> official website </A> is text <V> http://www.romefloyd.com/ </V> </ES> whose <A> population </A> is <V> 34980 </V>",
    "kopl": "FindAll().FilterStr(official website,http://www.romefloyd.com/).FilterConcept(city of the United States).QueryAttrQualifier(population,34980,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <official_website> ?pv_1 . ?pv_1 <pred:value> \"http://www.romefloyd.com/\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"34980\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE (n1.official_website = \"http://www.romefloyd.com/\" AND n1.population =  34980 )\nRETURN .point_in_time",
    "question": "When did the U.S. city whose official website is http://www.romefloyd.com/ have a population of 34980?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:official_website]->(pv_1:Resource{value:\"http://www.romefloyd.com/\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:34980.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.romefloyd.com/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "population",
          "34980",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_26696",
    "answer": "2000"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <C> county of Washington </C> whose <A> population </A> smaller than number <V> 910000 </V> </ES>",
    "kopl": "FindAll().FilterNum(population,910000,<).FilterConcept(county of Washington).Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of Washington\" . ?e <population> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> ?v_1 . FILTER ( ?v_1 < \"910000\"^^xsd:double ) . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.county_of_Washington ) ( string ! type ) ) ( string population ) ( string < ) ( number 910000 ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1:county_of_Washington) WHERE n1.population <  910000 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "What county in Washington with a population of less than 910000 has the largest area?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"county of Washington\"}) match (e)-[:population]->(pv_1:Resource{unit:\"1\"}) match (e)-[:area]->(pv) where pv_1.value <  910000.0  return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "910000",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "county of Washington"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "largest"
        ]
      }
    ],
    "sample_id": "train_37789",
    "answer": "Okanogan County"
  },
  {
    "graphq_ir": "what is <ES> <C> metropolitan borough </C> whose <A> TOID </A> is text <V> 7000000000000018 </V> </ES>",
    "kopl": "FindAll().FilterStr(TOID,7000000000000018).FilterConcept(metropolitan borough).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"metropolitan borough\" . ?e <TOID> ?pv . ?pv <pred:value> \"7000000000000018\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.metropolitan_borough ) ( string ! type ) ) ( string TOID ) ( string = ) ( string 7000000000000018 ) ) )",
    "cypher": "MATCH (n1:metropolitan_borough) WHERE n1.TOID = \"7000000000000018\"\nRETURN n1.name",
    "question": "TOID 7000000000000018 designates which metro borough?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"metropolitan borough\"}) match (e)-[:TOID]->(pv:Resource{value:\"7000000000000018\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "TOID",
          "7000000000000018"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "metropolitan borough"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_94299",
    "answer": "Birmingham"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <C> city in New Jersey </C> whose <A> inception </A> smaller than year <V> 1863 </V> </ES>",
    "kopl": "FindAll().FilterYear(inception,1863,<).FilterConcept(city in New Jersey).Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city in New Jersey\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> ?v_1 . FILTER ( ?v_1 < 1863 ) . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.city_in_New_Jersey ) ( string ! type ) ) ( string inception ) ( string < ) ( year 1863 ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1:city_in_New_Jersey) WHERE n1.inception <  1863 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which has the most area among the New Jersey cities established before 1863?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city in New Jersey\"}) match (e)-[:inception]->(pv_1) match (e)-[:area]->(pv) where pv_1.year < 1863 return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "inception",
          "1863",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city in New Jersey"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "largest"
        ]
      }
    ],
    "sample_id": "train_31083",
    "answer": "Newark"
  },
  {
    "graphq_ir": "which one has the largest <A> population </A> among <ES> <E> French Third Republic </E> or <E> Dutch Republic </E> </ES>",
    "kopl": "Find(French Third Republic).Find(Dutch Republic).Or().Select(population,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"French Third Republic\" .  } UNION { ?e <pred:name> \"Dutch Republic\" .  } ?e <population> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.French_Third_Republic en.Dutch_Republic ) ( string max ) ( string population ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"French Third Republic\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Dutch Republic\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nLIMIT 1",
    "question": "Which has a larger population, French Third Republic or Dutch Republic?",
    "cypher_match": "call { match (e:Resource{name:\"French Third Republic\"}) return e union match (e:Resource{name:\"Dutch Republic\"}) return e } match (e)-[:population]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "French Third Republic"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dutch Republic"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "population",
          "greater"
        ]
      }
    ],
    "sample_id": "train_68884",
    "answer": "French Third Republic"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <ES> <E> Sullivan County </E> (<ES> ones that <R> shares border with </R> backward to <E> Grafton County </E> </ES>) </ES> or <E> Sandoval County </E> </ES>",
    "kopl": "Find(Grafton County).Relate(shares border with,forward).Find(Sullivan County).And().Find(Sandoval County).Or().Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Sullivan County\" . ?e_1 <shares_border_with> ?e . ?e_1 <pred:name> \"Grafton County\" .   } UNION { ?e <pred:name> \"Sandoval County\" .  } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.Sullivan_County ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string shares_border_with ) ) ( string = ) en.Grafton_County ) ) ) en.Sandoval_County ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Sullivan County\"\nMATCH (n2) WHERE n2.name = \"Grafton County\"\nMATCH (n3)-[r1:shares_border_with]->(n2)\nRETURN n3.name AS name\nORDER BY n3.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Sandoval County\"\nRETURN n1.name AS name\nORDER BY n3.area DESC\nLIMIT 1",
    "question": "Which area is larger, Sullivan County (the one that shares border with Grafton County) or Sandoval County?",
    "cypher_match": "call { match (e_1:Resource{name:\"Grafton County\"})-[:shares_border_with]->(e:Resource{name:\"Sullivan County\"}) return e union match (e:Resource{name:\"Sandoval County\"}) return e } match (e)-[:area]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Grafton County"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "shares border with",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sullivan County"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sandoval County"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "area",
          "greater"
        ]
      }
    ],
    "sample_id": "train_31903",
    "answer": "Sandoval County"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <E> Dazed and Confused </E> or <ES> <E> Terminator 3: Rise of the Machines </E> (<ES> ones that <R> composer </R> forward to <E> Marco Beltrami </E> </ES>) </ES> </ES>",
    "kopl": "Find(Dazed and Confused).Find(Marco Beltrami).Relate(composer,backward).Find(Terminator 3: Rise of the Machines).And().Or().Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Dazed and Confused\" .  } UNION { ?e <pred:name> \"Terminator 3: Rise of the Machines\" . ?e <composer> ?e_1 . ?e_1 <pred:name> \"Marco Beltrami\" .   } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Dazed_and_Confused ( call SW.and en.Terminator_3:_Rise_of_the_Machines ( lambda s ( call SW.filter ( var s ) ( string composer ) ( string = ) en.Marco_Beltrami ) ) ) ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Dazed and Confused\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Terminator 3: Rise of the Machines\"\nMATCH (n2) WHERE n2.name = \"Marco Beltrami\"\nMATCH (n3)<-[r1:composer]-(n2)\nRETURN n3.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Which movie is longer, Dazed and Confused or Terminator 3: Rise of the Machines (the one whose composer is Marco Beltrami)?",
    "cypher_match": "call { match (e:Resource{name:\"Dazed and Confused\"}) return e union match (e:Resource{name:\"Terminator 3: Rise of the Machines\"})-[:composer]->(e_1:Resource{name:\"Marco Beltrami\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dazed and Confused"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Marco Beltrami"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "composer",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Terminator 3: Rise of the Machines"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "duration",
          "greater"
        ]
      }
    ],
    "sample_id": "train_46765",
    "answer": "Terminator 3: Rise of the Machines"
  },
  {
    "graphq_ir": "what is the relation from <E> Batman Beyond </E> to <E> Lauren Tom </E>",
    "kopl": "Find(Batman Beyond).Find(Lauren Tom).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Batman Beyond\" . ?e_2 <pred:name> \"Lauren Tom\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Batman Beyond\"\nMATCH (n2) WHERE n2.name = \"Lauren Tom\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Batman Beyond to Lauren Tom?",
    "cypher_match": "match (e_1:Resource{name:\"Batman Beyond\"})-[p]->(e_2:Resource{name:\"Lauren Tom\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Batman Beyond"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Lauren Tom"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_51130",
    "answer": "voice actor"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> ethnic community </C> whose <A> population </A> larger than number <V> 5700000000 </V> </ES> or <ES> <C> ethnic community </C> that <R> part of </R> forward to <E> Irish Americans </E> </ES> </ES>",
    "kopl": "FindAll().FilterNum(population,5700000000,>).FilterConcept(ethnic community).Find(Irish Americans).Relate(part of,backward).FilterConcept(ethnic community).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"ethnic community\" .  { ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v > \"5700000000\"^^xsd:double ) .  } UNION { ?e <part_of> ?e_1 . ?e_1 <pred:name> \"Irish Americans\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.ethnic_community ) ( string ! type ) ) ( string population ) ( string > ) ( number 5700000000 ) ) ( call SW.filter ( getProperty ( singleton en.ethnic_community ) ( string ! type ) ) ( string part_of ) ) ) ) )",
    "cypher": "MATCH (n1:ethnic_community) WHERE n1.population >  5700000000 \nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"Irish Americans\"\nMATCH (n1:ethnic_community)<-[r1:part_of]-(n2)\nRETURN count(n1)",
    "question": "How many ethnic communities have a population greater than 5700000000 or is a part of Irish Americans?",
    "cypher_match": "call { match (e)-[:population]->(pv:Resource{unit:\"1\"})  where pv.value >  5700000000.0  return e union match (e)-[:part_of]->(e_1:Resource{name:\"Irish Americans\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"ethnic community\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "5700000000",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "ethnic community"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Irish Americans"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "part of",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "ethnic community"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_72664",
    "answer": "0"
  },
  {
    "graphq_ir": "how many <ES> <C> literary award </C> that <R> award received </R> backward to <E> Larry Niven </E> </ES>",
    "kopl": "Find(Larry Niven).Relate(award received,forward).FilterConcept(literary award).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"literary award\" . ?e_1 <award_received> ?e . ?e_1 <pred:name> \"Larry Niven\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.literary_award ) ( string ! type ) ) ( call SW.reverse ( string award_received ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Larry Niven\"\nMATCH (n1:literary_award)-[r1:award_received]->(n2)\nRETURN count(n1)",
    "question": "How many literary awards has Larry Niven been given?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"literary award\"}) match (e_1:Resource{name:\"Larry Niven\"})-[:award_received]->(e) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Larry Niven"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "literary award"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_793",
    "answer": "5"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0000 7847 8275 </V> </ES> <A> date of birth </A> larger than year <V> 1589 </V>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0000 7847 8275).FilterConcept(human).QueryAttr(date of birth).VerifyYear(1589,>)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv_1 . ?pv_1 <pred:value> \"0000 0000 7847 8275\" . ?e <date_of_birth> ?pv . ?pv <pred:year> ?v . FILTER ( ?v > 1589 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:human) WHERE (n1.ISNI = \"0000 0000 7847 8275\" AND n1.date_of_birth >  1589 )\nRETURN isEmpty(n1)",
    "question": "Was the person with the ISNI of 0000 0000 7847 8275 born after 1589?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv_1:Resource{value:\"0000 0000 7847 8275\"}) match (e)-[:date_of_birth]->(pv) return pv.year > 1589",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0000 7847 8275"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "date of birth"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1589",
          ">"
        ]
      }
    ],
    "sample_id": "train_52015",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <E> Michael Haneke </E>",
    "kopl": "Find(Michael Haneke).QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Michael Haneke\" . ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Michael_Haneke ( string ISNI ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Michael Haneke\"\nRETURN n1.ISNI",
    "question": "What is the ISNI for Michael Haneke?",
    "cypher_match": "match (e:Resource{name:\"Michael Haneke\"})-[:ISNI]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Michael Haneke"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_70966",
    "answer": "0000 0001 2125 4091"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <E> Dwight Yoakam </E>",
    "kopl": "Find(Dwight Yoakam).QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Dwight Yoakam\" . ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Dwight_Yoakam ( string official_website ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Dwight Yoakam\"\nRETURN n1.official_website",
    "question": "What is the official website for Dwight Yoakam ?",
    "cypher_match": "match (e:Resource{name:\"Dwight Yoakam\"})-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dwight Yoakam"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_7486",
    "answer": "http://www.dwightyoakam.com/"
  },
  {
    "graphq_ir": "whether <ES> <C> legislative term </C> that <R> follows </R> backward to <E> 19th United States Congress </E> </ES> <A> start time </A> is not year <V> 1990 </V>",
    "kopl": "Find(19th United States Congress).Relate(follows,forward).FilterConcept(legislative term).QueryAttr(start time).VerifyYear(1990,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"legislative term\" . ?e_1 <follows> ?e . ?e_1 <pred:name> \"19th United States Congress\" .  ?e <start_time> ?pv . ?pv <pred:year> ?v . FILTER ( ?v != 1990 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"19th United States Congress\"\nMATCH (n1:legislative_term)-[r1:follows]->(n2) WHERE n1.start_time <>  1990 \nRETURN isEmpty(n1)",
    "question": "Did a legislative term, that is followed by 19th United States Congress, begin in a year other than 1990 ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"legislative term\"}) match (e)-[:start_time]->(pv) match (e_1:Resource{name:\"19th United States Congress\"})-[:follows]->(e) return pv.year <> 1990",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "19th United States Congress"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "follows",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "legislative term"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "start time"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1990",
          "!="
        ]
      }
    ],
    "sample_id": "train_81046",
    "answer": "yes"
  },
  {
    "graphq_ir": "which one has the smallest <A> number of children </A> among <ES> <E> Laura Innes </E> or <E> J. K. Rowling </E> </ES>",
    "kopl": "Find(Laura Innes).Find(J. K. Rowling).Or().Select(number of children,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Laura Innes\" .  } UNION { ?e <pred:name> \"J. K. Rowling\" .  } ?e <number_of_children> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Laura_Innes en.J._K._Rowling ) ( string min ) ( string number_of_children ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Laura Innes\"\nRETURN n1.name AS name\nORDER BY n1.number_of_children DESC\nUNION\nMATCH (n1) WHERE n1.name = \"J. K. Rowling\"\nRETURN n1.name AS name\nORDER BY n1.number_of_children DESC\nLIMIT 1",
    "question": "Who has fewer children, J. K. Rowling or Laura Innes?",
    "cypher_match": "call { match (e:Resource{name:\"Laura Innes\"}) return e union match (e:Resource{name:\"J. K. Rowling\"}) return e } match (e)-[:number_of_children]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Laura Innes"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "J. K. Rowling"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "number of children",
          "less"
        ]
      }
    ],
    "sample_id": "train_42011",
    "answer": "Laura Innes"
  },
  {
    "graphq_ir": "whether <ES> <E> John Hughes </E> (<ES> ones that <R> member of sports team </R> forward to <E> Sunderland A.F.C. </E> </ES>) </ES> <A> date of birth </A> smaller than year <V> 1969 </V>",
    "kopl": "Find(Sunderland A.F.C.).Relate(member of sports team,backward).Find(John Hughes).And().QueryAttr(date of birth).VerifyYear(1969,<)",
    "sparql": "ASK { ?e <pred:name> \"John Hughes\" . ?e <member_of_sports_team> ?e_1 . ?e_1 <pred:name> \"Sunderland A.F.C.\" .  ?e <date_of_birth> ?pv . ?pv <pred:year> ?v . FILTER ( ?v < 1969 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE (n3.name = \"John Hughes\" AND n3.date_of_birth <  1969 )\nMATCH (n2) WHERE n2.name = \"Sunderland A.F.C.\"\nMATCH (n3)<-[r1:member_of_sports_team]-(n2)\nRETURN isEmpty(n3)",
    "question": "Was John Hughes (the one that is a member of Sunderland A.F.C.) born before 1969?",
    "cypher_match": "match (e:Resource{name:\"John Hughes\"})-[:member_of_sports_team]->(e_1:Resource{name:\"Sunderland A.F.C.\"}) match (e:Resource{name:\"John Hughes\"})-[:date_of_birth]->(pv) return pv.year < 1969",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sunderland A.F.C."
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "member of sports team",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "John Hughes"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "date of birth"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          4
        ],
        "inputs": [
          "1969",
          "<"
        ]
      }
    ],
    "sample_id": "train_13198",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> Charleston County </E> whose <A> population </A> is <V> 389262 </V>",
    "kopl": "Find(Charleston County).QueryAttrQualifier(population,389262,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Charleston County\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"389262\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Charleston County\" AND n1.population =  389262 )\nRETURN .point_in_time",
    "question": "When was the population of Charleston County 389262?",
    "cypher_match": "match (e:Resource{name:\"Charleston County\"})-[:population]->(pv:Resource{unit:\"1\",value:389262.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Charleston County"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "389262",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_14468",
    "answer": "2015-01-01"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> higher education institution </C> that <R> educated at </R> backward to <E> Jerome Kern </E> </ES> whose <A> students count </A> is <V> 30787 </V>",
    "kopl": "Find(Jerome Kern).Relate(educated at,forward).FilterConcept(higher education institution).QueryAttrQualifier(students count,30787,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"higher education institution\" . ?e_1 <educated_at> ?e . ?e_1 <pred:name> \"Jerome Kern\" .  ?e <students_count> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"30787\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <students_count> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Jerome Kern\"\nMATCH (n1:higher_education_institution)-[r1:educated_at]->(n2) WHERE n1.students_count =  30787 \nRETURN r1.point_in_time",
    "question": "When did the higher education institution where Jerome Kern was educated have a student count of 30787?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"higher education institution\"}) match (e)-[:students_count]->(pv:Resource{unit:\"1\",value:30787.0}) match (e_1:Resource{name:\"Jerome Kern\"})-[:educated_at]->(e),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"students_count\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jerome Kern"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "educated at",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "higher education institution"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "students count",
          "30787",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_29297",
    "answer": "2016-12-01"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> political party </C> that <R> official color </R> forward to <E> red </E> </ES> and <ES> <C> political party </C> that <R> parent organization </R> backward to <E> Liberation Tigers of Tamil Eelam </E> </ES> </ES>",
    "kopl": "Find(red).Relate(official color,backward).FilterConcept(political party).Find(Liberation Tigers of Tamil Eelam).Relate(parent organization,forward).FilterConcept(political party).And().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"political party\" . ?e <official_color> ?e_1 . ?e_1 <pred:name> \"red\" .  ?e_2 <parent_organization> ?e . ?e_2 <pred:name> \"Liberation Tigers of Tamil Eelam\" .  }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.and ( call SW.filter ( getProperty ( singleton en.political_party ) ( string ! type ) ) ( string official_color ) ) ( call SW.filter ( getProperty ( singleton en.political_party ) ( string ! type ) ) ( call SW.reverse ( string parent_organization ) ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"red\"\nMATCH (n3:political_party)<-[r1:official_color]-(n2)\nMATCH (n2) WHERE n2.name = \"Liberation Tigers of Tamil Eelam\"\nMATCH (n3:political_party)-[r1:parent_organization]->(n2)\nRETURN count(n3)",
    "question": "How many political parties use red as the official control and have Liberation Tigers of Tamil Eelam as the parent organization ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"political party\"}) match (e)-[:official_color]->(e_1:Resource{name:\"red\"}) match (e_2:Resource{name:\"Liberation Tigers of Tamil Eelam\"})-[:parent_organization]->(e) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "red"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "official color",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "political party"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Liberation Tigers of Tamil Eelam"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "parent organization",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "political party"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_16412",
    "answer": "0"
  },
  {
    "graphq_ir": "what is the attribute <A> start time </A> of <E> 1980 Winter Olympics </E>",
    "kopl": "Find(1980 Winter Olympics).QueryAttr(start time)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"1980 Winter Olympics\" . ?e <start_time> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.1980_Winter_Olympics ( string start_time ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"1980 Winter Olympics\"\nRETURN n1.start_time",
    "question": "What is the start time for the 1980 Winter Olympics?",
    "cypher_match": "match (e:Resource{name:\"1980 Winter Olympics\"})-[:start_time]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "1980 Winter Olympics"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "start time"
        ]
      }
    ],
    "sample_id": "train_20362",
    "answer": "1980-02-14"
  },
  {
    "graphq_ir": "what is the attribute <A> publication date </A> of <ES> <E> Transformers: Dark of the Moon </E> (<ES> ones that <R> platform </R> forward to <E> Wii </E> </ES>) </ES>",
    "kopl": "Find(Wii).Relate(platform,backward).Find(Transformers: Dark of the Moon).And().QueryAttr(publication date)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Transformers: Dark of the Moon\" . ?e <platform> ?e_1 . ?e_1 <pred:name> \"Wii\" .  ?e <publication_date> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.and en.Transformers:_Dark_of_the_Moon ( lambda s ( call SW.filter ( var s ) ( string platform ) ( string = ) en.Wii ) ) ) ( string publication_date ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Transformers: Dark of the Moon\"\nMATCH (n2) WHERE n2.name = \"Wii\"\nMATCH (n3)<-[r1:platform]-(n2)\nRETURN n3.publication_date",
    "question": "When was Transformers: Dark of the Moon (the one that is released for Wii) published?",
    "cypher_match": "match (e:Resource{name:\"Transformers: Dark of the Moon\"})-[:platform]->(e_1:Resource{name:\"Wii\"}) match (e:Resource{name:\"Transformers: Dark of the Moon\"})-[:publication_date]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Wii"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "platform",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Transformers: Dark of the Moon"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "publication date"
        ]
      }
    ],
    "sample_id": "train_29520",
    "answer": "2011-06-14"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <ES> <C> association football club </C> whose <A> Twitter username </A> is text <V> FGRFC_Official </V> </ES>",
    "kopl": "FindAll().FilterStr(Twitter username,FGRFC_Official).FilterConcept(association football club).QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"association football club\" . ?e <Twitter_username> ?pv_1 . ?pv_1 <pred:value> \"FGRFC_Official\" . ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.association_football_club ) ( string ! type ) ) ( string Twitter_username ) ( string = ) ( string FGRFC_Official ) ) ( string official_website ) ) )",
    "cypher": "MATCH (n1:association_football_club) WHERE n1.Twitter_username = \"FGRFC_Official\"\nRETURN n1.official_website",
    "question": "Regarding the association football club that have the Twitter username of FGRFC_Official tell me its official website",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"association football club\"}) match (e)-[:Twitter_username]->(pv_1:Resource{value:\"FGRFC_Official\"}) match (e)-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Twitter username",
          "FGRFC_Official"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "association football club"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_60928",
    "answer": "https://www.fgr.co.uk/"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> Walmart </E> whose <A> total revenue </A> is <V> 446509000000 United States dollar </V>",
    "kopl": "Find(Walmart).QueryAttrQualifier(total revenue,446509000000 United States dollar,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Walmart\" . ?e <total_revenue> ?pv . ?pv <pred:unit> \"United States dollar\" . ?pv <pred:value> \"446509000000\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <total_revenue> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Walmart\" AND n1.total_revenue =  446509000000 United States dollar )\nRETURN .point_in_time",
    "question": "When did Walmart have a total revenue of 446509000000 United States dollars?",
    "cypher_match": "match (e:Resource{name:\"Walmart\"})-[:total_revenue]->(pv:Resource{unit:\"United States dollar\",value:446509000000.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"total_revenue\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Walmart"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          0
        ],
        "inputs": [
          "total revenue",
          "446509000000 United States dollar",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_34724",
    "answer": "2012"
  },
  {
    "graphq_ir": "whether <E> Peter Capaldi </E> <A> height </A> larger than number <V> 1.7 metre </V>",
    "kopl": "Find(Peter Capaldi).QueryAttr(height).VerifyNum(1.7 metre,>)",
    "sparql": "ASK { ?e <pred:name> \"Peter Capaldi\" . ?e <height> ?pv . ?pv <pred:unit> \"metre\" . ?pv <pred:value> ?v . FILTER ( ?v > \"1.7\"^^xsd:double ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Peter Capaldi\" AND n1.height >  1.7 metre )\nRETURN isEmpty(n1)",
    "question": "Is Peter Capaldi taller than 1.7 meters ?",
    "cypher_match": "match (e:Resource{name:\"Peter Capaldi\"})-[:height]->(pv:Resource{unit:\"metre\"}) return pv.value >  1.7 ",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Peter Capaldi"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "height"
        ]
      },
      {
        "function": "VerifyNum",
        "dependencies": [
          1
        ],
        "inputs": [
          "1.7 metre",
          ">"
        ]
      }
    ],
    "sample_id": "train_76703",
    "answer": "yes"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> miniseries </C> that <R> after a work by </R> forward to <E> Charles Dickens </E> </ES> or <ES> <C> miniseries </C> that <R> main subject </R> forward to <E> World War II </E> </ES> </ES>",
    "kopl": "Find(Charles Dickens).Relate(after a work by,backward).FilterConcept(miniseries).Find(World War II).Relate(main subject,backward).FilterConcept(miniseries).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"miniseries\" .  { ?e <after_a_work_by> ?e_1 . ?e_1 <pred:name> \"Charles Dickens\" .  } UNION { ?e <main_subject> ?e_1 . ?e_1 <pred:name> \"World War II\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.miniseries ) ( string ! type ) ) ( string after_a_work_by ) ) ( call SW.filter ( getProperty ( singleton en.miniseries ) ( string ! type ) ) ( string main_subject ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Charles Dickens\"\nMATCH (n1:miniseries)<-[r1:after_a_work_by]-(n2)\nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"World War II\"\nMATCH (n1:miniseries)<-[r1:main_subject]-(n2)\nRETURN count(n1)",
    "question": "How many miniseries are written by Charles Dickens or mainly depict World War II?",
    "cypher_match": "call { match (e)-[:after_a_work_by]->(e_1:Resource{name:\"Charles Dickens\"}) return e union match (e)-[:main_subject]->(e_1:Resource{name:\"World War II\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"miniseries\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Charles Dickens"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "after a work by",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "miniseries"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "World War II"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "main subject",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "miniseries"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_20884",
    "answer": "6"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> form of government </C> whose <A> pronunciation audio </A> is text <V> Lb-Italien.ogg </V> </ES> and <ES> <C> form of government </C> whose <A> nominal GDP </A> larger than number <V> 14000000000000 Russian ruble </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(pronunciation audio,Lb-Italien.ogg).FilterConcept(form of government).FindAll().FilterNum(nominal GDP,14000000000000 Russian ruble,>).FilterConcept(form of government).And().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"form of government\" . ?e <pronunciation_audio> ?pv . ?pv <pred:value> \"Lb-Italien.ogg\" . ?e <nominal_GDP> ?pv_1 . ?pv_1 <pred:unit> \"Russian ruble\" . ?pv_1 <pred:value> ?v . FILTER ( ?v > \"14000000000000\"^^xsd:double ) .  }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.and ( call SW.filter ( getProperty ( singleton en.form_of_government ) ( string ! type ) ) ( string pronunciation_audio ) ( string = ) ( string Lb-Italien.ogg ) ) ( call SW.filter ( getProperty ( singleton en.form_of_government ) ( string ! type ) ) ( string nominal_GDP ) ( string > ) ( number 14000000000000 Russian ruble ) ) ) ) )",
    "cypher": "MATCH (n2:form_of_government) WHERE n2.pronunciation_audio = \"Lb-Italien.ogg\"\nMATCH (n2:form_of_government) WHERE n2.nominal_GDP >  14000000000000 Russian ruble \nRETURN count(n2)",
    "question": "How many forms of government have a pronunciation audio of Lb-Italien.ogg and a nominal GDP greater than 14000000000000 Russian rubles?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"form of government\"}) match (e)-[:pronunciation_audio]->(pv:Resource{value:\"Lb-Italien.ogg\"}) match (e)-[:nominal_GDP]->(pv_1:Resource{unit:\"Russian ruble\"}) where pv_1.value >  14000000000000.0  return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "pronunciation audio",
          "Lb-Italien.ogg"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "form of government"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "nominal GDP",
          "14000000000000 Russian ruble",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "form of government"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_68234",
    "answer": "0"
  },
  {
    "graphq_ir": "what is the attribute <A> IPTC Newscode </A> of <E> mountain biking </E>",
    "kopl": "Find(mountain biking).QueryAttr(IPTC Newscode)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"mountain biking\" . ?e <IPTC_Newscode> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.mountain_biking ( string IPTC_Newscode ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"mountain biking\"\nRETURN n1.IPTC_Newscode",
    "question": "What is the IPTC Newscode for mountainbiking?",
    "cypher_match": "match (e:Resource{name:\"mountain biking\"})-[:IPTC_Newscode]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "mountain biking"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "IPTC Newscode"
        ]
      }
    ],
    "sample_id": "train_16272",
    "answer": "mediatopic/20000903"
  },
  {
    "graphq_ir": "what is <ES> <C> human </C> that <R> creator </R> backward to <ES> <C> television series </C> that <R> cast member </R> forward to <E> Kathleen Quinlan </E> </ES> </ES>",
    "kopl": "Find(Kathleen Quinlan).Relate(cast member,backward).FilterConcept(television series).Relate(creator,forward).FilterConcept(human).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e_1 <creator> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"television series\" . ?e_1 <cast_member> ?e_3 . ?e_3 <pred:name> \"Kathleen Quinlan\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( call SW.reverse ( string creator ) ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Kathleen Quinlan\"\nMATCH (n2:television_series)<-[r2:cast_member]-(n3)\nMATCH (n1:human)-[r1:creator]->(n2)\nRETURN n1.name",
    "question": "Who created the television series that has Kathleen Quinlan as a cast member?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e_1)-[:creator]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"television series\"}) match (e_1)-[:cast_member]->(e_3:Resource{name:\"Kathleen Quinlan\"}) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Kathleen Quinlan"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "cast member",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "television series"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "creator",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_79203",
    "answer": "David Shore"
  },
  {
    "graphq_ir": "whether <ES> <C> free software copyleft license </C> whose <A> short name </A> is text <V> GNU GPL </V> </ES> <A> full work available at </A> is text <V> https://www.gnu.org/licenses/gpl.html </V>",
    "kopl": "FindAll().FilterStr(short name,GNU GPL).FilterConcept(free software copyleft license).QueryAttr(full work available at).VerifyStr(https://www.gnu.org/licenses/gpl.html)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"free software copyleft license\" . ?e <short_name> ?pv_1 . ?pv_1 <pred:value> \"GNU GPL\" . ?e <full_work_available_at> ?pv . ?pv <pred:value> \"https://www.gnu.org/licenses/gpl.html\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:free_software_copyleft_license) WHERE (n1.short_name = \"GNU GPL\" AND n1.full_work_available_at = \"https://www.gnu.org/licenses/gpl.html\")\nRETURN isEmpty(n1)",
    "question": "Is the full work available for a free software copyleft license with GNU GPL short name, in relation to https://www.gnu.org/licenses/gpl.html ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"free software copyleft license\"}) match (e)-[:short_name]->(pv_1:Resource{value:\"GNU GPL\"}) match (e)-[:full_work_available_at]->(pv:Resource) return pv.value = \"https://www.gnu.org/licenses/gpl.html\"",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "short name",
          "GNU GPL"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "free software copyleft license"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "full work available at"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "https://www.gnu.org/licenses/gpl.html"
        ]
      }
    ],
    "sample_id": "train_55769",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the qualifier <Q> end time </Q> of <E> Nancy Pelosi </E> that <R> residence </R> to <ES> <E> New York </E> (<ES> ones that <R> located in the administrative territorial entity </R> backward to <E> Nassau County </E> </ES>) </ES>",
    "kopl": "Find(Nancy Pelosi).Find(Nassau County).Relate(located in the administrative territorial entity,forward).Find(New York).And().QueryRelationQualifier(residence,end time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Nancy Pelosi\" . ?e_2 <pred:name> \"New York\" . ?e_3 <located_in_the_administrative_territorial_entity> ?e_2 . ?e_3 <pred:name> \"Nassau County\" . ?e_1 <residence> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <residence> ; <pred:fact_t> ?e_2 ] <end_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Nancy Pelosi\"\nMATCH (n4) WHERE n4.name = \"New York\"\nMATCH (n3) WHERE n3.name = \"Nassau County\"\nMATCH (n4)-[r1:located_in_the_administrative_territorial_entity]->(n3)\nMATCH (n1)-[r2:residence]->(n4)\nRETURN r2.end_time",
    "question": "Nancy Pelosi was a resident of the New York which includes Nassau County until what date?",
    "cypher_match": "match (e_3:Resource{name:\"Nassau County\"})-[:located_in_the_administrative_territorial_entity]->(e_2:Resource{name:\"New York\"}) match (e_1:Resource{name:\"Nancy Pelosi\"})-[:residence]->(e_2:Resource{name:\"New York\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"residence\"}),(tmp)-[:end_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Nancy Pelosi"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Nassau County"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "located in the administrative territorial entity",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "New York"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "residence",
          "end time"
        ]
      }
    ],
    "sample_id": "train_20718",
    "answer": "1969"
  },
  {
    "graphq_ir": "what is the attribute <A> population </A> of <ES> <C> ceremonial county of England </C> that <R> place of death </R> backward to <E> Jack Bruce </E> </ES>",
    "kopl": "Find(Jack Bruce).Relate(place of death,forward).FilterConcept(ceremonial county of England).QueryAttr(population)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"ceremonial county of England\" . ?e_1 <place_of_death> ?e . ?e_1 <pred:name> \"Jack Bruce\" .  ?e <population> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.filter ( getProperty ( singleton en.ceremonial_county_of_England ) ( string ! type ) ) ( call SW.reverse ( string place_of_death ) ) ) ( string population ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Jack Bruce\"\nMATCH (n1:ceremonial_county_of_England)-[r1:place_of_death]->(n2)\nRETURN n1.population",
    "question": "What is the popluation of the ceremonial county of England where Jack Bruce died?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"ceremonial county of England\"}) match (e)-[:population]->(pv) match (e_1:Resource{name:\"Jack Bruce\"})-[:place_of_death]->(e) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jack Bruce"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "place of death",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "ceremonial county of England"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "population"
        ]
      }
    ],
    "sample_id": "train_55719",
    "answer": "741900"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Jon Stewart </E> (<ES> ones that <R> member of sports team </R> forward to <E> Weymouth F.C. </E> </ES>) </ES> to <E> Burnley F.C. </E>",
    "kopl": "Find(Weymouth F.C.).Relate(member of sports team,backward).Find(Jon Stewart).And().Find(Burnley F.C.).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Jon Stewart\" . ?e_1 <member_of_sports_team> ?e_3 . ?e_3 <pred:name> \"Weymouth F.C.\" . ?e_2 <pred:name> \"Burnley F.C.\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Jon Stewart\"\nMATCH (n2) WHERE n2.name = \"Weymouth F.C.\"\nMATCH (n3)<-[r1:member_of_sports_team]-(n2)\nMATCH (n4) WHERE n4.name = \"Burnley F.C.\"\nMATCH (n3)-[r2]->(n4)\nRETURN r2.label",
    "question": "What does Weymouth F.C. member Jon Stewart have to do with Burnley F.C.?",
    "cypher_match": "match (e_1:Resource{name:\"Jon Stewart\"})-[:member_of_sports_team]->(e_3:Resource{name:\"Weymouth F.C.\"}) match (e_1:Resource{name:\"Jon Stewart\"})-[p]->(e_2:Resource{name:\"Burnley F.C.\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Weymouth F.C."
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "member of sports team",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jon Stewart"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Burnley F.C."
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_54098",
    "answer": "member of sports team"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Melbourne </E> whose <A> official website </A> is text <V> http://www.melbourneflorida.org </V> </ES> to <ES> <E> Melbourne </E> (<ES> ones that <R> place of birth </R> backward to <E> Scott McDonald </E> </ES>) </ES>",
    "kopl": "Find(Melbourne).FilterStr(official website,http://www.melbourneflorida.org).Find(Scott McDonald).Relate(place of birth,forward).Find(Melbourne).And().QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Melbourne\" . ?e_1 <official_website> ?pv . ?pv <pred:value> \"http://www.melbourneflorida.org\" . ?e_2 <pred:name> \"Melbourne\" . ?e_3 <place_of_birth> ?e_2 . ?e_3 <pred:name> \"Scott McDonald\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Melbourne\"\nMATCH (n1) WHERE n1.official_website = \"http://www.melbourneflorida.org\"\nMATCH (n4) WHERE n4.name = \"Melbourne\"\nMATCH (n3) WHERE n3.name = \"Scott McDonald\"\nMATCH (n4)-[r1:place_of_birth]->(n3)\nMATCH (n1)-[r2]->(n4)\nRETURN r2.label",
    "question": "What relation between Melbourne (its official website is http://www.melbourneflorida.org) and Melbourne (It's the birthplace of Scott McDonald)?",
    "cypher_match": "match (e_1:Resource{name:\"Melbourne\"})-[:official_website]->(pv:Resource{value:\"http://www.melbourneflorida.org\"}) match (e_1:Resource{name:\"Melbourne\"})-[p]->(e_2:Resource{name:\"Melbourne\"}) match (e_3:Resource{name:\"Scott McDonald\"})-[:place_of_birth]->(e_2:Resource{name:\"Melbourne\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Melbourne"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.melbourneflorida.org"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Scott McDonald"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "place of birth",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Melbourne"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_56859",
    "answer": "named after"
  },
  {
    "graphq_ir": "what is the qualifier <Q> character role </Q> of <ES> <E> The Lord of the Rings: The Fellowship of the Ring </E> (<ES> ones that <R> nominated for </R> forward to <E> BAFTA Award for Best Editing </E> </ES>) </ES> that <R> cast member </R> to <ES> <E> Billy Boyd </E> (<ES> ones that <R> winner </R> backward to <E> Broadcast Film Critics Association Award for Best Cast </E> </ES>) </ES>",
    "kopl": "Find(BAFTA Award for Best Editing).Relate(nominated for,backward).Find(The Lord of the Rings: The Fellowship of the Ring).And().Find(Broadcast Film Critics Association Award for Best Cast).Relate(winner,forward).Find(Billy Boyd).And().QueryRelationQualifier(cast member,character role)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"The Lord of the Rings: The Fellowship of the Ring\" . ?e_1 <nominated_for> ?e_3 . ?e_3 <pred:name> \"BAFTA Award for Best Editing\" . ?e_2 <pred:name> \"Billy Boyd\" . ?e_4 <winner> ?e_2 . ?e_4 <pred:name> \"Broadcast Film Critics Association Award for Best Cast\" . ?e_1 <cast_member> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <cast_member> ; <pred:fact_t> ?e_2 ] <character_role> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"The Lord of the Rings: The Fellowship of the Ring\"\nMATCH (n2) WHERE n2.name = \"BAFTA Award for Best Editing\"\nMATCH (n3)<-[r1:nominated_for]-(n2)\nMATCH (n6) WHERE n6.name = \"Billy Boyd\"\nMATCH (n5) WHERE n5.name = \"Broadcast Film Critics Association Award for Best Cast\"\nMATCH (n6)-[r2:winner]->(n5)\nMATCH (n3)-[r3:cast_member]->(n6)\nRETURN r3.character_role",
    "question": "What is the role of Billy Boyd (the one that wins Broadcast Film Critics Association Award for Best Cast) The Lord of the Rings: The Fellowship of the Ring (the one that was nominated for BAFTA Award for Best Editing) ?",
    "cypher_match": "match (e_1:Resource{name:\"The Lord of the Rings: The Fellowship of the Ring\"})-[:nominated_for]->(e_3:Resource{name:\"BAFTA Award for Best Editing\"}) match (e_1:Resource{name:\"The Lord of the Rings: The Fellowship of the Ring\"})-[:cast_member]->(e_2:Resource{name:\"Billy Boyd\"}) match (e_4:Resource{name:\"Broadcast Film Critics Association Award for Best Cast\"})-[:winner]->(e_2:Resource{name:\"Billy Boyd\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"cast_member\"}),(tmp)-[:character_role]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "BAFTA Award for Best Editing"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Lord of the Rings: The Fellowship of the Ring"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Broadcast Film Critics Association Award for Best Cast"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          4
        ],
        "inputs": [
          "winner",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Billy Boyd"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          5,
          6
        ],
        "inputs": []
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          3,
          7
        ],
        "inputs": [
          "cast member",
          "character role"
        ]
      }
    ],
    "sample_id": "train_49398",
    "answer": "Peregrin Took"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> composer </R> backward to <ES> <E> The Phantom of the Opera </E> (<ES> ones that <R> original language of film or TV show </R> forward to <E> Italian </E> </ES>) </ES> </ES> <A> CANTIC-ID </A> is text <V> a10445444 </V>",
    "kopl": "Find(Italian).Relate(original language of film or TV show,backward).Find(The Phantom of the Opera).And().Relate(composer,forward).FilterConcept(human).QueryAttr(CANTIC-ID).VerifyStr(a10445444)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e_1 <composer> ?e . ?e_1 <pred:name> \"The Phantom of the Opera\" . ?e_1 <original_language_of_film_or_TV_show> ?e_2 . ?e_2 <pred:name> \"Italian\" .  ?e <CANTIC-ID> ?pv . ?pv <pred:value> \"a10445444\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"The Phantom of the Opera\"\nMATCH (n3) WHERE n3.name = \"Italian\"\nMATCH (n4)<-[r2:original_language_of_film_or_TV_show]-(n3)\nMATCH (n1:human)-[r1:composer]->(n4) WHERE n1.CANTIC-ID = \"a10445444\"\nRETURN isEmpty(n1)",
    "question": "Does the person who composed The Phantom of the Opera (the one whose original language is Italian) have a CANTIC-ID of a10445444?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:`CANTIC-ID`]->(pv:Resource) match (e_1:Resource{name:\"The Phantom of the Opera\"})-[:composer]->(e) match (e_1:Resource{name:\"The Phantom of the Opera\"})-[:original_language_of_film_or_TV_show]->(e_2:Resource{name:\"Italian\"}) return pv.value = \"a10445444\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Italian"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "original language of film or TV show",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Phantom of the Opera"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "composer",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          5
        ],
        "inputs": [
          "CANTIC-ID"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          6
        ],
        "inputs": [
          "a10445444"
        ]
      }
    ],
    "sample_id": "train_58598",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the relation from <E> National Society of Film Critics Award for Best Actress </E> to <E> Elisabeth Shue </E>",
    "kopl": "Find(National Society of Film Critics Award for Best Actress).Find(Elisabeth Shue).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"National Society of Film Critics Award for Best Actress\" . ?e_2 <pred:name> \"Elisabeth Shue\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"National Society of Film Critics Award for Best Actress\"\nMATCH (n2) WHERE n2.name = \"Elisabeth Shue\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between National Society of Film Critics Award for Best Actress to Elisabeth Shue?",
    "cypher_match": "match (e_1:Resource{name:\"National Society of Film Critics Award for Best Actress\"})-[p]->(e_2:Resource{name:\"Elisabeth Shue\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "National Society of Film Critics Award for Best Actress"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Elisabeth Shue"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_88825",
    "answer": "winner"
  },
  {
    "graphq_ir": "what is <ES> <C> higher education institution </C> that <R> educated at </R> backward to <E> Shirley Knight </E> </ES>",
    "kopl": "Find(Shirley Knight).Relate(educated at,forward).FilterConcept(higher education institution).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"higher education institution\" . ?e_1 <educated_at> ?e . ?e_1 <pred:name> \"Shirley Knight\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.higher_education_institution ) ( string ! type ) ) ( call SW.reverse ( string educated_at ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Shirley Knight\"\nMATCH (n1:higher_education_institution)-[r1:educated_at]->(n2)\nRETURN n1.name",
    "question": "Shirley Knight was a student of which institution of higher learning?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"higher education institution\"}) match (e_1:Resource{name:\"Shirley Knight\"})-[:educated_at]->(e) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Shirley Knight"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "educated at",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "higher education institution"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_28828",
    "answer": "Wichita State University"
  },
  {
    "graphq_ir": "which one has the largest <A> real gross domestic product growth rate </A> among <ES> <E> Colombia </E> or <ES> <E> Georgia </E> (<ES> ones that <R> diplomatic relation </R> backward to <E> Vietnam </E> </ES>) </ES> </ES>",
    "kopl": "Find(Colombia).Find(Vietnam).Relate(diplomatic relation,forward).Find(Georgia).And().Or().Select(real gross domestic product growth rate,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Colombia\" .  } UNION { ?e <pred:name> \"Georgia\" . ?e_1 <diplomatic_relation> ?e . ?e_1 <pred:name> \"Vietnam\" .   } ?e <real_gross_domestic_product_growth_rate> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Colombia ( call SW.and en.Georgia ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string diplomatic_relation ) ) ( string = ) en.Vietnam ) ) ) ) ( string max ) ( string real_gross_domestic_product_growth_rate ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Colombia\"\nRETURN n1.name AS name\nORDER BY n1.real_gross_domestic_product_growth_rate DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Georgia\"\nMATCH (n2) WHERE n2.name = \"Vietnam\"\nMATCH (n3)-[r1:diplomatic_relation]->(n2)\nRETURN n3.name AS name\nORDER BY n1.real_gross_domestic_product_growth_rate DESC\nLIMIT 1",
    "question": "Does Colombia or Georgia, which has diplomatic relations with Vietnam, have a greater real gross domestic product growth rate?",
    "cypher_match": "call { match (e:Resource{name:\"Colombia\"}) return e union match (e_1:Resource{name:\"Vietnam\"})-[:diplomatic_relation]->(e:Resource{name:\"Georgia\"}) return e } match (e)-[:real_gross_domestic_product_growth_rate]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Colombia"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Vietnam"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "diplomatic relation",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Georgia"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "real gross domestic product growth rate",
          "greater"
        ]
      }
    ],
    "sample_id": "train_35296",
    "answer": "Georgia"
  },
  {
    "graphq_ir": "how many <ES> <C> medal </C> that <R> country </R> forward to <ES> <C> sovereign state </C> that <R> country </R> forward to <ES> <E> Republic of the Congo </E> whose <A> life expectancy </A> is number <V> 64.625 year </V> </ES> </ES> </ES>",
    "kopl": "Find(Republic of the Congo).FilterNum(life expectancy,64.625 year,=).Relate(country,backward).FilterConcept(sovereign state).Relate(country,backward).FilterConcept(medal).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"medal\" . ?e <country> ?e_1 . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"sovereign state\" . ?e_1 <country> ?e_2 . ?e_2 <pred:name> \"Republic of the Congo\" . ?e_2 <life_expectancy> ?pv_1 . ?pv_1 <pred:unit> \"year\" . ?pv_1 <pred:value> \"64.625\"^^xsd:double .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.medal ) ( string ! type ) ) ( string country ) ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Republic of the Congo\"\nMATCH (n3) WHERE n3.life_expectancy =  64.625 year \nMATCH (n2:sovereign_state)<-[r2:country]-(n3)\nMATCH (n1:medal)<-[r1:country]-(n2)\nRETURN count(n1)",
    "question": "How many medals origin in a sovereign state whose country is Republic of the Congo (the country whose life expectancy is 64.625 years) ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"medal\"}) match (e)-[:country]->(e_1) match (e_1)-[:instance_of]->(c_1:Resource{name:\"sovereign state\"}) match (e_1)-[:country]->(e_2:Resource{name:\"Republic of the Congo\"}) match (e_2:Resource{name:\"Republic of the Congo\"})-[:life_expectancy]->(pv_1:Resource{unit:\"year\",value:64.625}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Republic of the Congo"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "life expectancy",
          "64.625 year",
          "="
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "sovereign state"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "medal"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_75162",
    "answer": "0"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> agent </C> whose <A> ISNI </A> is text <V> 0000 0001 2159 0079 </V> </ES> and <ES> <C> agent </C> whose <A> inception </A> is not year <V> 1799 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0001 2159 0079).FilterConcept(agent).FindAll().FilterYear(inception,1799,!=).FilterConcept(agent).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"agent\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 2159 0079\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> ?v . FILTER ( ?v != 1799 ) .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.and ( call SW.filter ( getProperty ( singleton en.agent ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0001 2159 0079 ) ) ( call SW.filter ( getProperty ( singleton en.agent ) ( string ! type ) ) ( string inception ) ( string ! = ) ( year 1799 ) ) ) )",
    "cypher": "MATCH (n2:agent) WHERE n2.ISNI = \"0000 0001 2159 0079\"\nMATCH (n2:agent) WHERE n2.inception <>  1799 \nRETURN n2.name",
    "question": "What agent has the ISNI 0000 0001 2159 0079 and was not established in 1799?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"agent\"}) match (e)-[:ISNI]->(pv:Resource{value:\"0000 0001 2159 0079\"}) match (e)-[:inception]->(pv_1) where pv_1.year <> 1799 return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0001 2159 0079"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "agent"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "inception",
          "1799",
          "!="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "agent"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_88037",
    "answer": "Organisation for Economic Co-operation and Development"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <C> county of Texas </C> whose <A> inception </A> smaller than year <V> 1849 </V> </ES>",
    "kopl": "FindAll().FilterYear(inception,1849,<).FilterConcept(county of Texas).Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of Texas\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> ?v_1 . FILTER ( ?v_1 < 1849 ) . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.county_of_Texas ) ( string ! type ) ) ( string inception ) ( string < ) ( year 1849 ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1:county_of_Texas) WHERE n1.inception <  1849 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which Texas county whose establishment date is before 1849 has the largest area?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"county of Texas\"}) match (e)-[:inception]->(pv_1) match (e)-[:area]->(pv) where pv_1.year < 1849 return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "inception",
          "1849",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "county of Texas"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "largest"
        ]
      }
    ],
    "sample_id": "train_27541",
    "answer": "Harris County"
  },
  {
    "graphq_ir": "whether <ES> <C> cemetery </C> that <R> country </R> forward to <E> France </E> </ES> <A> inception </A> is not year <V> 1818 </V>",
    "kopl": "Find(France).Relate(country,backward).FilterConcept(cemetery).QueryAttr(inception).VerifyYear(1818,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"cemetery\" . ?e <country> ?e_1 . ?e_1 <pred:name> \"France\" .  ?e <inception> ?pv . ?pv <pred:year> ?v . FILTER ( ?v != 1818 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"France\"\nMATCH (n1:cemetery)<-[r1:country]-(n2) WHERE n1.inception <>  1818 \nRETURN isEmpty(n1)",
    "question": "Was the cemetry located in France not started in 1818?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"cemetery\"}) match (e)-[:country]->(e_1:Resource{name:\"France\"}) match (e)-[:inception]->(pv) return pv.year <> 1818",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "France"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "cemetery"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "inception"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1818",
          "!="
        ]
      }
    ],
    "sample_id": "train_41836",
    "answer": "yes"
  },
  {
    "graphq_ir": "which one has the largest <A> mass </A> among <ES> <E> linoleic acid </E> or <E> arachidonic acid </E> </ES>",
    "kopl": "Find(linoleic acid).Find(arachidonic acid).Or().Select(mass,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"linoleic acid\" .  } UNION { ?e <pred:name> \"arachidonic acid\" .  } ?e <mass> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.linoleic_acid en.arachidonic_acid ) ( string max ) ( string mass ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"linoleic acid\"\nRETURN n1.name AS name\nORDER BY n1.mass DESC\nUNION\nMATCH (n1) WHERE n1.name = \"arachidonic acid\"\nRETURN n1.name AS name\nORDER BY n1.mass DESC\nLIMIT 1",
    "question": "Which acid has a greater mass, linoleic acid or arachidonic acid?",
    "cypher_match": "call { match (e:Resource{name:\"linoleic acid\"}) return e union match (e:Resource{name:\"arachidonic acid\"}) return e } match (e)-[:mass]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "linoleic acid"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "arachidonic acid"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "mass",
          "greater"
        ]
      }
    ],
    "sample_id": "train_86776",
    "answer": "arachidonic acid"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <E> Monroe County </E> whose <A> FIPS 6-4 (US counties) </A> is text <V> 18105 </V> </ES> whose <A> population </A> is <V> 140305 </V>",
    "kopl": "Find(Monroe County).FilterStr(FIPS 6-4 (US counties),18105).QueryAttrQualifier(population,140305,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Monroe County\" . ?e <FIPS_6-4_(US_counties)> ?pv_1 . ?pv_1 <pred:value> \"18105\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"140305\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Monroe County\" AND n1.population =  140305 )\nMATCH (n1) WHERE n1.FIPS_6-4_(US_counties) = \"18105\"\nRETURN .point_in_time",
    "question": "When did Monroe County (the one whose FIPS 6-4 (US counties) is 18105) have a population of 140305?",
    "cypher_match": "match (e:Resource{name:\"Monroe County\"})-[:`FIPS_6-4_(US_counties)`]->(pv_1:Resource{value:\"18105\"}) match (e:Resource{name:\"Monroe County\"})-[:population]->(pv:Resource{unit:\"1\",value:140305.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Monroe County"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "FIPS 6-4 (US counties)",
          "18105"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          1
        ],
        "inputs": [
          "population",
          "140305",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_4974",
    "answer": "2011-07-01"
  },
  {
    "graphq_ir": "what is the qualifier <Q> character role </Q> of <E> The Bourne Legacy </E> that <R> cast member </R> to <E> Joan Allen </E>",
    "kopl": "Find(The Bourne Legacy).Find(Joan Allen).QueryRelationQualifier(cast member,character role)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"The Bourne Legacy\" . ?e_2 <pred:name> \"Joan Allen\" . ?e_1 <cast_member> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <cast_member> ; <pred:fact_t> ?e_2 ] <character_role> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"The Bourne Legacy\"\nMATCH (n2) WHERE n2.name = \"Joan Allen\"\nMATCH (n1)-[r1:cast_member]->(n2)\nRETURN r1.character_role",
    "question": "What character did Joan Allen play in The Bourne Legacy?",
    "cypher_match": "match (e_1:Resource{name:\"The Bourne Legacy\"})-[:cast_member]->(e_2:Resource{name:\"Joan Allen\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"cast_member\"}),(tmp)-[:character_role]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Bourne Legacy"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Joan Allen"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "cast member",
          "character role"
        ]
      }
    ],
    "sample_id": "train_3266",
    "answer": "Pamela Landy"
  },
  {
    "graphq_ir": "how many <ES> <C> hip hop music </C> that <R> famous people </R> forward to <E> Lil Jon </E> </ES>",
    "kopl": "Find(Lil Jon).Relate(famous people,backward).FilterConcept(hip hop music).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"hip hop music\" . ?e <famous_people> ?e_1 . ?e_1 <pred:name> \"Lil Jon\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.hip_hop_music ) ( string ! type ) ) ( string famous_people ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Lil Jon\"\nMATCH (n1:hip_hop_music)<-[r1:famous_people]-(n2)\nRETURN count(n1)",
    "question": "What number of hip hop music features Lil Jon?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"hip hop music\"}) match (e)-[:famous_people]->(e_1:Resource{name:\"Lil Jon\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Lil Jon"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "famous people",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "hip hop music"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_74242",
    "answer": "4"
  },
  {
    "graphq_ir": "what is the attribute <A> date of birth </A> of <E> Richard Kind </E>",
    "kopl": "Find(Richard Kind).QueryAttr(date of birth)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Richard Kind\" . ?e <date_of_birth> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Richard_Kind ( string date_of_birth ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Richard Kind\"\nRETURN n1.date_of_birth",
    "question": "When was Richard Kind born?",
    "cypher_match": "match (e:Resource{name:\"Richard Kind\"})-[:date_of_birth]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Richard Kind"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "date of birth"
        ]
      }
    ],
    "sample_id": "train_75193",
    "answer": "1956-11-22"
  },
  {
    "graphq_ir": "whether <ES> <C> big city </C> whose <A> WOEID </A> is text <V> 673361 </V> </ES> <A> official website </A> is text <V> http://www.miramax.com/movie/life-is-beautiful </V>",
    "kopl": "FindAll().FilterStr(WOEID,673361).FilterConcept(big city).QueryAttr(official website).VerifyStr(http://www.miramax.com/movie/life-is-beautiful)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"big city\" . ?e <WOEID> ?pv_1 . ?pv_1 <pred:value> \"673361\" . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.miramax.com/movie/life-is-beautiful\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:big_city) WHERE (n1.WOEID = \"673361\" AND n1.official_website = \"http://www.miramax.com/movie/life-is-beautiful\")\nRETURN isEmpty(n1)",
    "question": "Is http://www.miramax.com/movie/life-is-beautiful the official website of the big city whose WOEID is 673361?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"big city\"}) match (e)-[:WOEID]->(pv_1:Resource{value:\"673361\"}) match (e)-[:official_website]->(pv:Resource) return pv.value = \"http://www.miramax.com/movie/life-is-beautiful\"",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "WOEID",
          "673361"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "big city"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "http://www.miramax.com/movie/life-is-beautiful"
        ]
      }
    ],
    "sample_id": "train_73069",
    "answer": "no"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> county of Indiana </C> that <R> contains administrative territorial entity </R> forward to <ES> <E> Anderson </E> whose <A> official website </A> is text <V> http://www.cityofanderson.com/ </V> </ES> </ES> or <ES> <C> county of Indiana </C> that <R> located in the administrative territorial entity </R> forward to <E> Indiana </E> </ES> </ES>",
    "kopl": "Find(Anderson).FilterStr(official website,http://www.cityofanderson.com/).Relate(contains administrative territorial entity,backward).FilterConcept(county of Indiana).Find(Indiana).Relate(located in the administrative territorial entity,backward).FilterConcept(county of Indiana).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of Indiana\" .  { ?e <contains_administrative_territorial_entity> ?e_1 . ?e_1 <pred:name> \"Anderson\" . ?e_1 <official_website> ?pv . ?pv <pred:value> \"http://www.cityofanderson.com/\" .  } UNION { ?e <located_in_the_administrative_territorial_entity> ?e_1 . ?e_1 <pred:name> \"Indiana\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.county_of_Indiana ) ( string ! type ) ) ( string contains_administrative_territorial_entity ) ) ( call SW.filter ( getProperty ( singleton en.county_of_Indiana ) ( string ! type ) ) ( string located_in_the_administrative_territorial_entity ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Anderson\"\nMATCH (n2) WHERE n2.official_website = \"http://www.cityofanderson.com/\"\nMATCH (n1:county_of_Indiana)<-[r1:contains_administrative_territorial_entity]-(n2)\nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"Indiana\"\nMATCH (n1:county_of_Indiana)<-[r1:located_in_the_administrative_territorial_entity]-(n2)\nRETURN count(n1)",
    "question": "How many counties of Indiana contain the administrative division Anderson (the one whose official website is http://www.cityofanderson.com/) or are located in Indiana?",
    "cypher_match": "call { match (e)-[:contains_administrative_territorial_entity]->(e_1:Resource{name:\"Anderson\"}),(e_1:Resource{name:\"Anderson\"})-[:official_website]->(pv:Resource{value:\"http://www.cityofanderson.com/\"}) return e union match (e)-[:located_in_the_administrative_territorial_entity]->(e_1:Resource{name:\"Indiana\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"county of Indiana\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Anderson"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.cityofanderson.com/"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "contains administrative territorial entity",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "county of Indiana"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Indiana"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          4
        ],
        "inputs": [
          "located in the administrative territorial entity",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          5
        ],
        "inputs": [
          "county of Indiana"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          3,
          6
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          7
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_37405",
    "answer": "13"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> Sex, Lies, and Videotape </E> that <R> award received </R> to <E> National Film Registry </E>",
    "kopl": "Find(Sex, Lies, and Videotape).Find(National Film Registry).QueryRelationQualifier(award received,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Sex, Lies, and Videotape\" . ?e_2 <pred:name> \"National Film Registry\" . ?e_1 <award_received> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <award_received> ; <pred:fact_t> ?e_2 ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Sex, Lies, and Videotape\"\nMATCH (n2) WHERE n2.name = \"National Film Registry\"\nMATCH (n1)-[r1:award_received]->(n2)\nRETURN r1.point_in_time",
    "question": "When did Sex, Lies, and Videotape receive the National Film Registry?",
    "cypher_match": "match (e_1:Resource{name:\"Sex, Lies, and Videotape\"})-[:award_received]->(e_2:Resource{name:\"National Film Registry\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"award_received\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sex, Lies, and Videotape"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "National Film Registry"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "award received",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_29333",
    "answer": "2006-01-01"
  },
  {
    "graphq_ir": "what is the relation from <E> A Simple Life </E> to <E> Italy </E>",
    "kopl": "Find(A Simple Life).Find(Italy).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"A Simple Life\" . ?e_2 <pred:name> \"Italy\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"A Simple Life\"\nMATCH (n2) WHERE n2.name = \"Italy\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relation between A Simple Life with Italy?",
    "cypher_match": "match (e_1:Resource{name:\"A Simple Life\"})-[p]->(e_2:Resource{name:\"Italy\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "A Simple Life"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Italy"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_57476",
    "answer": "film release region"
  },
  {
    "graphq_ir": "how many <ES> <C> album </C> that <R> derivative work </R> forward to <ES> <E> Tommy </E> (<ES> ones that <R> distributor </R> forward to <E> Columbia Pictures </E> </ES>) </ES> </ES>",
    "kopl": "Find(Columbia Pictures).Relate(distributor,backward).Find(Tommy).And().Relate(derivative work,backward).FilterConcept(album).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"album\" . ?e <derivative_work> ?e_1 . ?e_1 <pred:name> \"Tommy\" . ?e_1 <distributor> ?e_2 . ?e_2 <pred:name> \"Columbia Pictures\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.album ) ( string ! type ) ) ( string derivative_work ) ) ) )",
    "cypher": "MATCH (n4) WHERE n4.name = \"Tommy\"\nMATCH (n3) WHERE n3.name = \"Columbia Pictures\"\nMATCH (n4)<-[r2:distributor]-(n3)\nMATCH (n1:album)<-[r1:derivative_work]-(n4)\nRETURN count(n1)",
    "question": "How many albums derive Tommy distributed by Columbia Pictures?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"album\"}) match (e)-[:derivative_work]->(e_1:Resource{name:\"Tommy\"}) match (e_1:Resource{name:\"Tommy\"})-[:distributor]->(e_2:Resource{name:\"Columbia Pictures\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Columbia Pictures"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "distributor",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tommy"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "derivative work",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "album"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_86929",
    "answer": "1"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <E> Date Night </E> or <E> Face/Off </E> </ES>",
    "kopl": "Find(Date Night).Find(Face/Off).Or().Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Date Night\" .  } UNION { ?e <pred:name> \"Face/Off\" .  } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Date_Night en.Face/Off ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Date Night\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Face/Off\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Is Date Night or Face/Off longer?",
    "cypher_match": "call { match (e:Resource{name:\"Date Night\"}) return e union match (e:Resource{name:\"Face/Off\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Date Night"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Face/Off"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "duration",
          "greater"
        ]
      }
    ],
    "sample_id": "train_7375",
    "answer": "Face/Off"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> film </C> whose <A> title </A> is text <V> Hercules </V> </ES> and <ES> <C> film </C> whose <A> duration </A> smaller than number <V> 220 minute </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(title,Hercules).FilterConcept(film).FindAll().FilterNum(duration,220 minute,<).FilterConcept(film).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film\" . ?e <title> ?pv . ?pv <pred:value> \"Hercules\" . ?e <duration> ?pv_1 . ?pv_1 <pred:unit> \"minute\" . ?pv_1 <pred:value> ?v . FILTER ( ?v < \"220\"^^xsd:double ) .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.and ( call SW.filter ( getProperty ( singleton en.film ) ( string ! type ) ) ( string title ) ( string = ) ( string Hercules ) ) ( call SW.filter ( getProperty ( singleton en.film ) ( string ! type ) ) ( string duration ) ( string < ) ( number 220 minute ) ) ) )",
    "cypher": "MATCH (n2:film) WHERE n2.title = \"Hercules\"\nMATCH (n2:film) WHERE n2.duration <  220 minute \nRETURN n2.name",
    "question": "Which film titled Hercules clocks in at under 220 minutes?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film\"}) match (e)-[:title]->(pv:Resource{value:\"Hercules\"}) match (e)-[:duration]->(pv_1:Resource{unit:\"minute\"}) where pv_1.value <  220.0  return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "Hercules"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "duration",
          "220 minute",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_21823",
    "answer": "Hercules"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Batman Forever </E> (<ES> ones that <R> game mode </R> forward to <E> single-player video game </E> </ES>) </ES> to <E> action game </E>",
    "kopl": "Find(single-player video game).Relate(game mode,backward).Find(Batman Forever).And().Find(action game).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Batman Forever\" . ?e_1 <game_mode> ?e_3 . ?e_3 <pred:name> \"single-player video game\" . ?e_2 <pred:name> \"action game\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Batman Forever\"\nMATCH (n2) WHERE n2.name = \"single-player video game\"\nMATCH (n3)<-[r1:game_mode]-(n2)\nMATCH (n4) WHERE n4.name = \"action game\"\nMATCH (n3)-[r2]->(n4)\nRETURN r2.label",
    "question": "How is single-player video game Batman Forever related to action game?",
    "cypher_match": "match (e_1:Resource{name:\"Batman Forever\"})-[:game_mode]->(e_3:Resource{name:\"single-player video game\"}) match (e_1:Resource{name:\"Batman Forever\"})-[p]->(e_2:Resource{name:\"action game\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "single-player video game"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "game mode",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Batman Forever"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "action game"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_773",
    "answer": "genre"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Law & Order </E> (<ES> ones that <R> nominated for </R> forward to <E> Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series </E> </ES>) </ES> to <E> police procedural </E>",
    "kopl": "Find(Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series).Relate(nominated for,backward).Find(Law & Order).And().Find(police procedural).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Law & Order\" . ?e_1 <nominated_for> ?e_3 . ?e_3 <pred:name> \"Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series\" . ?e_2 <pred:name> \"police procedural\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Law & Order\"\nMATCH (n2) WHERE n2.name = \"Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series\"\nMATCH (n3)<-[r1:nominated_for]-(n2)\nMATCH (n4) WHERE n4.name = \"police procedural\"\nMATCH (n3)-[r2]->(n4)\nRETURN r2.label",
    "question": "What is the connection between Law & Order, nominated for a Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series, and police procedurals?",
    "cypher_match": "match (e_1:Resource{name:\"Law & Order\"})-[:nominated_for]->(e_3:Resource{name:\"Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series\"}) match (e_1:Resource{name:\"Law & Order\"})-[p]->(e_2:Resource{name:\"police procedural\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Screen Actors Guild Award for Outstanding Performance by an Ensemble in a Drama Series"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Law & Order"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "police procedural"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_34245",
    "answer": "genre"
  },
  {
    "graphq_ir": "what is the attribute <A> date of death </A> of <ES> <C> human </C> that <R> nominated for </R> forward to <E> Academy Award for Best Animated Short Film </E> ( <Q> for work </Q> is text <V> For Scent-imental Reasons </V> ) </ES>",
    "kopl": "Find(Academy Award for Best Animated Short Film).Relate(nominated for,backward).QFilterStr(for work,For Scent-imental Reasons).FilterConcept(human).QueryAttr(date of death)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Animated Short Film\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <for_work> ?qpv . ?qpv <pred:value> \"For Scent-imental Reasons\" . ?e <date_of_death> ?pv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Academy Award for Best Animated Short Film\"\nMATCH (n1:human)<-[r1:nominated_for]-(n2) WHERE r1.for_work = \"For Scent-imental Reasons\"\nRETURN n1.date_of_death",
    "question": "When was the death of the Academy Award nominee for Best Animated Short Film for their work on For Scent-imental Reasons?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:nominated_for]->(e_1:Resource{name:\"Academy Award for Best Animated Short Film\"}) match (e)-[:date_of_death]->(pv),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:for_work]->(qpv:Resource{value:\"For Scent-imental Reasons\"}) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Animated Short Film"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "for work",
          "For Scent-imental Reasons"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "date of death"
        ]
      }
    ],
    "sample_id": "train_39288",
    "answer": "1970-02-22"
  },
  {
    "graphq_ir": "which one has the smallest <A> number of episodes </A> among <ES> <E> Thirtysomething </E> or <E> Brothers & Sisters </E> </ES>",
    "kopl": "Find(Thirtysomething).Find(Brothers & Sisters).Or().Select(number of episodes,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Thirtysomething\" .  } UNION { ?e <pred:name> \"Brothers & Sisters\" .  } ?e <number_of_episodes> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Thirtysomething en.Brothers_&_Sisters ) ( string min ) ( string number_of_episodes ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Thirtysomething\"\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Brothers & Sisters\"\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nLIMIT 1",
    "question": "Which one has less number of episodes between Thirtysomething and Brothers & Sisters?",
    "cypher_match": "call { match (e:Resource{name:\"Thirtysomething\"}) return e union match (e:Resource{name:\"Brothers & Sisters\"}) return e } match (e)-[:number_of_episodes]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Thirtysomething"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Brothers & Sisters"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "number of episodes",
          "less"
        ]
      }
    ],
    "sample_id": "train_16939",
    "answer": "Thirtysomething"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <ES> <E> Lawrence </E> whose <A> official name </A> is text <V> Lawrence </V> </ES> or <ES> <E> Hastings </E> whose <A> area </A> is number <V> 28.794686 square kilometre </V> </ES> </ES>",
    "kopl": "Find(Lawrence).FilterStr(official name,Lawrence).Find(Hastings).FilterNum(area,28.794686 square kilometre,=).Or().Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Lawrence\" . ?e <official_name> ?pv_1 . ?pv_1 <pred:value> \"Lawrence\" . } UNION { ?e <pred:name> \"Hastings\" . ?e <area> ?pv_2 . ?pv_2 <pred:unit> \"square kilometre\" . ?pv_2 <pred:value> \"28.794686\"^^xsd:double . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Lawrence ( string official_name ) ( string = ) ( string Lawrence ) ) ( call SW.filter en.Hastings ( string area ) ( string = ) ( number 28.794686 square kilometre ) ) ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Lawrence\"\nMATCH (n1) WHERE n1.official_name = \"Lawrence\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Hastings\"\nMATCH (n1) WHERE n1.area =  28.794686 square kilometre \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which area is smaller, Lawrence (the one whose official name is Lawrence) or Hastings (the one whose area is 28.794686 square kilometre)?",
    "cypher_match": "call { match (e:Resource{name:\"Lawrence\"})-[:official_name]->(pv_1:Resource{value:\"Lawrence\"}) return e union match (e:Resource{name:\"Hastings\"})-[:area]->(pv_2:Resource{unit:\"square kilometre\",value:28.794686}) return e } match (e)-[:area]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Lawrence"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official name",
          "Lawrence"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Hastings"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "28.794686 square kilometre",
          "="
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          3
        ],
        "inputs": [
          "area",
          "less"
        ]
      }
    ],
    "sample_id": "train_25041",
    "answer": "Lawrence"
  },
  {
    "graphq_ir": "what is the qualifier <Q> language of work or name </Q> of <ES> <C> television channel </C> whose <A> inception </A> is year <V> 2008 </V> </ES> whose <A> official website </A> is <V> http://www.metvnetwork.com </V>",
    "kopl": "FindAll().FilterYear(inception,2008,=).FilterConcept(television channel).QueryAttrQualifier(official website,http://www.metvnetwork.com,language of work or name)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"television channel\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> 2008 . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.metvnetwork.com\" . [ <pred:fact_h> ?e ; <pred:fact_r> <official_website> ; <pred:fact_t> ?pv ] <language_of_work_or_name> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:television_channel) WHERE (n1.inception =  2008  AND n1.official_website =  http://www.metvnetwork.com )\nRETURN .language_of_work_or_name",
    "question": "For the television channel whose inception time is in 2008, what is the language associated with this creative work for its official website of http://www.metvnetwork.com?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"television channel\"}) match (e)-[:inception]->(pv_1:Resource{year:2008}) match (e)-[:official_website]->(pv:Resource{value:\"http://www.metvnetwork.com\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"official_website\"}),(tmp)-[:language_of_work_or_name]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "inception",
          "2008",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "television channel"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website",
          "http://www.metvnetwork.com",
          "language of work or name"
        ]
      }
    ],
    "sample_id": "train_27934",
    "answer": "English"
  },
  {
    "graphq_ir": "what is <ES> <C> film </C> that <R> award received </R> forward to <E> Academy Award for Best Actress </E> ( <Q> statement is subject of </Q> is text <V> 26th Academy Awards </V> ) </ES>",
    "kopl": "Find(Academy Award for Best Actress).Relate(award received,backward).QFilterStr(statement is subject of,26th Academy Awards).FilterConcept(film).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film\" . ?e <award_received> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Actress\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <award_received> ; <pred:fact_t> ?e_1 ] <statement_is_subject_of> ?qpv . ?qpv <pred:value> \"26th Academy Awards\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Academy Award for Best Actress\"\nMATCH (n1:film)<-[r1:award_received]-(n2) WHERE r1.statement_is_subject_of = \"26th Academy Awards\"\nRETURN n1.name",
    "question": "Which film was awarded the Academy Award for Best Actress in the 26th Academy Awards?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film\"}) match (e)-[:award_received]->(e_1:Resource{name:\"Academy Award for Best Actress\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"award_received\"}),(tmp)-[:statement_is_subject_of]->(qpv:Resource{value:\"26th Academy Awards\"}) return distinct e",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Actress"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "backward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "statement is subject of",
          "26th Academy Awards"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          3
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_64636",
    "answer": "Roman Holiday"
  },
  {
    "graphq_ir": "what is the qualifier <Q> applies to part </Q> of <ES> <E> Aachen </E> whose <A> postal code </A> is text <V> 52062 </V> </ES> whose <A> elevation above sea level </A> is <V> 173 metre </V>",
    "kopl": "Find(Aachen).FilterStr(postal code,52062).QueryAttrQualifier(elevation above sea level,173 metre,applies to part)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Aachen\" . ?e <postal_code> ?pv_1 . ?pv_1 <pred:value> \"52062\" . ?e <elevation_above_sea_level> ?pv . ?pv <pred:unit> \"metre\" . ?pv <pred:value> \"173\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <elevation_above_sea_level> ; <pred:fact_t> ?pv ] <applies_to_part> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Aachen\" AND n1.elevation_above_sea_level =  173 metre )\nMATCH (n1) WHERE n1.postal_code = \"52062\"\nRETURN .applies_to_part",
    "question": "Which part of Aachen (the one whose postal code is 52062) is positioned 173 m above sea level ?",
    "cypher_match": "match (e:Resource{name:\"Aachen\"})-[:postal_code]->(pv_1:Resource{value:\"52062\"}) match (e:Resource{name:\"Aachen\"})-[:elevation_above_sea_level]->(pv:Resource{unit:\"metre\",value:173.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"elevation_above_sea_level\"}),(tmp)-[:applies_to_part]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Aachen"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "postal code",
          "52062"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          1
        ],
        "inputs": [
          "elevation above sea level",
          "173 metre",
          "applies to part"
        ]
      }
    ],
    "sample_id": "train_27005",
    "answer": "city hall"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Aude </E> whose <A> ISNI </A> is text <V> 0000 0000 7408 0673 </V> </ES> to <E> Montreal </E>",
    "kopl": "Find(Aude).FilterStr(ISNI,0000 0000 7408 0673).Find(Montreal).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Aude\" . ?e_1 <ISNI> ?pv . ?pv <pred:value> \"0000 0000 7408 0673\" . ?e_2 <pred:name> \"Montreal\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Aude\"\nMATCH (n1) WHERE n1.ISNI = \"0000 0000 7408 0673\"\nMATCH (n2) WHERE n2.name = \"Montreal\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "Aude, designated by ISNI 0000 0000 7408 0673, has what connection to Montreal?",
    "cypher_match": "match (e_1:Resource{name:\"Aude\"})-[:ISNI]->(pv:Resource{value:\"0000 0000 7408 0673\"}) match (e_1:Resource{name:\"Aude\"})-[p]->(e_2:Resource{name:\"Montreal\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Aude"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0000 7408 0673"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Montreal"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_9662",
    "answer": "place of birth"
  },
  {
    "graphq_ir": "what is <ES> <C> activity </C> that <R> sports season of league or competition </R> backward to <E> 1997 NCAA Men's Division I Basketball Tournament </E> </ES>",
    "kopl": "Find(1997 NCAA Men's Division I Basketball Tournament).Relate(sports season of league or competition,forward).FilterConcept(activity).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"activity\" . ?e_1 <sports_season_of_league_or_competition> ?e . ?e_1 <pred:name> \"1997 NCAA Men's Division I Basketball Tournament\" .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.activity ) ( string ! type ) ) ( call SW.reverse ( string sports_season_of_league_or_competition ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"1997 NCAA Men's Division I Basketball Tournament\"\nMATCH (n1:activity)-[r1:sports_season_of_league_or_competition]->(n2)\nRETURN n1.name",
    "question": "The 1997 NCAA Men's Division I Basketball Tournament is the sports season of which activity?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"activity\"}) match (e_1:Resource{name:\"1997 NCAA Men's Division I Basketball Tournament\"})-[:sports_season_of_league_or_competition]->(e) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "1997 NCAA Men's Division I Basketball Tournament"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "sports season of league or competition",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "activity"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_80984",
    "answer": "NCAA Men's Division I Basketball Championship"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <C> county of New York </C> whose <A> inception </A> larger than year <V> 1791 </V> </ES>",
    "kopl": "FindAll().FilterYear(inception,1791,>).FilterConcept(county of New York).Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of New York\" . ?e <inception> ?pv_1 . ?pv_1 <pred:year> ?v_1 . FILTER ( ?v_1 > 1791 ) . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.county_of_New_York ) ( string ! type ) ) ( string inception ) ( string > ) ( year 1791 ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1:county_of_New_York) WHERE n1.inception >  1791 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Tell me the one with the biggest area within the New York county that has an inception time after 1791.",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"county of New York\"}) match (e)-[:inception]->(pv_1) match (e)-[:area]->(pv) where pv_1.year > 1791 return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          0
        ],
        "inputs": [
          "inception",
          "1791",
          ">"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "county of New York"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "largest"
        ]
      }
    ],
    "sample_id": "train_75902",
    "answer": "St. Lawrence County"
  },
  {
    "graphq_ir": "whether <ES> <C> association football club </C> that <R> headquarters location </R> forward to <ES> <E> Veracruz </E> (<ES> ones that <R> twinned administrative body </R> backward to <E> San Jose </E> </ES>) </ES> </ES> <A> inception </A> is not year <V> 1777 </V>",
    "kopl": "Find(San Jose).Relate(twinned administrative body,forward).Find(Veracruz).And().Relate(headquarters location,backward).FilterConcept(association football club).QueryAttr(inception).VerifyYear(1777,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"association football club\" . ?e <headquarters_location> ?e_1 . ?e_1 <pred:name> \"Veracruz\" . ?e_2 <twinned_administrative_body> ?e_1 . ?e_2 <pred:name> \"San Jose\" .  ?e <inception> ?pv . ?pv <pred:year> ?v . FILTER ( ?v != 1777 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"Veracruz\"\nMATCH (n3) WHERE n3.name = \"San Jose\"\nMATCH (n4)-[r2:twinned_administrative_body]->(n3)\nMATCH (n1:association_football_club)<-[r1:headquarters_location]-(n4) WHERE n1.inception <>  1777 \nRETURN isEmpty(n1)",
    "question": "Did the association football club whose headquarters location is Veracruz (the twinned administrative body of San Jose) begin outside of 1777?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"association football club\"}) match (e)-[:headquarters_location]->(e_1:Resource{name:\"Veracruz\"}) match (e)-[:inception]->(pv) match (e_2:Resource{name:\"San Jose\"})-[:twinned_administrative_body]->(e_1:Resource{name:\"Veracruz\"}) return pv.year <> 1777",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "San Jose"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "twinned administrative body",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Veracruz"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "headquarters location",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "association football club"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          5
        ],
        "inputs": [
          "inception"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          6
        ],
        "inputs": [
          "1777",
          "!="
        ]
      }
    ],
    "sample_id": "train_31569",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <ES> <E> Ludwig van Beethoven </E> (<ES> ones that <R> place of death </R> forward to <E> Bonn </E> </ES>) </ES>",
    "kopl": "Find(Bonn).Relate(place of death,backward).Find(Ludwig van Beethoven).And().QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Ludwig van Beethoven\" . ?e <place_of_death> ?e_1 . ?e_1 <pred:name> \"Bonn\" .  ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.and en.Ludwig_van_Beethoven ( lambda s ( call SW.filter ( var s ) ( string place_of_death ) ( string = ) en.Bonn ) ) ) ( string ISNI ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Ludwig van Beethoven\"\nMATCH (n2) WHERE n2.name = \"Bonn\"\nMATCH (n3)<-[r1:place_of_death]-(n2)\nRETURN n3.ISNI",
    "question": "What ISNI is associated with Ludwig van Beethoven who died in Bonn?",
    "cypher_match": "match (e:Resource{name:\"Ludwig van Beethoven\"})-[:place_of_death]->(e_1:Resource{name:\"Bonn\"}) match (e:Resource{name:\"Ludwig van Beethoven\"})-[:ISNI]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Bonn"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "place of death",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Ludwig van Beethoven"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_51586",
    "answer": "0000 0000 5768 271X"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> comune of Italy </C> that <R> twinned administrative body </R> forward to <E> Sarasota </E> </ES> or <ES> <C> comune of Italy </C> whose <A> UN/LOCODE </A> is text <V> ITMAN </V> </ES> </ES>",
    "kopl": "Find(Sarasota).Relate(twinned administrative body,backward).FilterConcept(comune of Italy).FindAll().FilterStr(UN/LOCODE,ITMAN).FilterConcept(comune of Italy).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"comune of Italy\" .  { ?e <twinned_administrative_body> ?e_1 . ?e_1 <pred:name> \"Sarasota\" .  } UNION { ?e <UN/LOCODE> ?pv . ?pv <pred:value> \"ITMAN\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.comune_of_Italy ) ( string ! type ) ) ( string twinned_administrative_body ) ) ( call SW.filter ( getProperty ( singleton en.comune_of_Italy ) ( string ! type ) ) ( string UN/LOCODE ) ( string = ) ( string ITMAN ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Sarasota\"\nMATCH (n1:comune_of_Italy)<-[r1:twinned_administrative_body]-(n2)\nRETURN count(n1)\nUNION\nMATCH (n1:comune_of_Italy) WHERE n1.UN/LOCODE = \"ITMAN\"\nRETURN count(n1)",
    "question": "How many of Italy's comunes are Sarasota's twinned administrative body or have the UN/LOCODE of ITMAN?",
    "cypher_match": "call { match (e)-[:twinned_administrative_body]->(e_1:Resource{name:\"Sarasota\"}) return e union match (e)-[:`UN/LOCODE`]->(pv:Resource{value:\"ITMAN\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"comune of Italy\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Sarasota"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "twinned administrative body",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "comune of Italy"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "UN/LOCODE",
          "ITMAN"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "comune of Italy"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_30640",
    "answer": "2"
  },
  {
    "graphq_ir": "what is the relation from <E> Jermaine Easter </E> to <E> Milton Keynes Dons F.C. </E>",
    "kopl": "Find(Jermaine Easter).Find(Milton Keynes Dons F.C.).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Jermaine Easter\" . ?e_2 <pred:name> \"Milton Keynes Dons F.C.\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Jermaine Easter\"\nMATCH (n2) WHERE n2.name = \"Milton Keynes Dons F.C.\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is Jermaine Easter's connection to Milton Keynes Dons F.C.?",
    "cypher_match": "match (e_1:Resource{name:\"Jermaine Easter\"})-[p]->(e_2:Resource{name:\"Milton Keynes Dons F.C.\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jermaine Easter"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Milton Keynes Dons F.C."
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_35327",
    "answer": "member of sports team"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> city </C> whose <A> Statistics Canada Geographic code </A> is text <V> 3510010 </V> </ES> whose <A> population </A> is <V> 123798 </V>",
    "kopl": "FindAll().FilterStr(Statistics Canada Geographic code,3510010).FilterConcept(city).QueryAttrQualifier(population,123798,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city\" . ?e <Statistics_Canada_Geographic_code> ?pv_1 . ?pv_1 <pred:value> \"3510010\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"123798\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:city) WHERE (n1.Statistics_Canada_Geographic_code = \"3510010\" AND n1.population =  123798 )\nRETURN .point_in_time",
    "question": "When did the city whose Statistics Canada Geographic code is 3510010 have a population of 123798?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city\"}) match (e)-[:Statistics_Canada_Geographic_code]->(pv_1:Resource{value:\"3510010\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:123798.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Statistics Canada Geographic code",
          "3510010"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "population",
          "123798",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_57900",
    "answer": "2016"
  },
  {
    "graphq_ir": "what is the relation from <E> Aidan Gillen </E> to <E> Dublin </E>",
    "kopl": "Find(Aidan Gillen).Find(Dublin).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Aidan Gillen\" . ?e_2 <pred:name> \"Dublin\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Aidan Gillen\"\nMATCH (n2) WHERE n2.name = \"Dublin\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Aidan Gillen to Dublin?",
    "cypher_match": "match (e_1:Resource{name:\"Aidan Gillen\"})-[p]->(e_2:Resource{name:\"Dublin\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Aidan Gillen"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dublin"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_76947",
    "answer": "place of birth"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Cher </E> whose <A> Instagram username </A> is text <V> cher </V> </ES> to <E> MCA Records </E>",
    "kopl": "Find(Cher).FilterStr(Instagram username,cher).Find(MCA Records).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Cher\" . ?e_1 <Instagram_username> ?pv . ?pv <pred:value> \"cher\" . ?e_2 <pred:name> \"MCA Records\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Cher\"\nMATCH (n1) WHERE n1.Instagram_username = \"cher\"\nMATCH (n2) WHERE n2.name = \"MCA Records\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between Cher (the one whose Instagram username is cher) to MCA Records?",
    "cypher_match": "match (e_1:Resource{name:\"Cher\"})-[:Instagram_username]->(pv:Resource{value:\"cher\"}) match (e_1:Resource{name:\"Cher\"})-[p]->(e_2:Resource{name:\"MCA Records\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Cher"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Instagram username",
          "cher"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "MCA Records"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_79147",
    "answer": "record label"
  },
  {
    "graphq_ir": "whether <ES> <C> film </C> whose <A> title </A> is text <V> The Fisher King </V> </ES> <A> publication date </A> smaller than year <V> 1920 </V> ( <Q> place of publication </Q> is <V> Germany </V> )",
    "kopl": "FindAll().FilterStr(title,The Fisher King).FilterConcept(film).QueryAttrUnderCondition(publication date,place of publication,Germany).VerifyYear(1920,<)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"film\" . ?e <title> ?pv_1 . ?pv_1 <pred:value> \"The Fisher King\" . ?e <publication_date> ?pv . ?pv <pred:year> ?v . FILTER ( ?v < 1920 ) . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv . ?qpv <pred:value> \"Germany\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:film) WHERE (n1.title = \"The Fisher King\" AND n1.publication_date <  1920 )\nRETURN isEmpty(n1)",
    "question": "Is the release date of the film titled The Fisher King before the year 1920 in Germany?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film\"}) match (e)-[:title]->(pv_1:Resource{value:\"The Fisher King\"}) match (e)-[:publication_date]->(pv),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv:Resource{value:\"Germany\"}) return pv.year < 1920",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "The Fisher King"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "film"
        ]
      },
      {
        "function": "QueryAttrUnderCondition",
        "dependencies": [
          2
        ],
        "inputs": [
          "publication date",
          "place of publication",
          "Germany"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "1920",
          "<"
        ]
      }
    ],
    "sample_id": "train_85978",
    "answer": "no"
  },
  {
    "graphq_ir": "whether <E> Bruce Dern </E> <A> work period (start) </A> is not year <V> 1963 </V>",
    "kopl": "Find(Bruce Dern).QueryAttr(work period (start)).VerifyYear(1963,!=)",
    "sparql": "ASK { ?e <pred:name> \"Bruce Dern\" . ?e <work_period_(start)> ?pv . ?pv <pred:year> ?v . FILTER ( ?v != 1963 ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Bruce Dern\" AND n1.work_period_(start) <>  1963 )\nRETURN isEmpty(n1)",
    "question": "Did Bruce Dern's work period not start in 1963?",
    "cypher_match": "match (e:Resource{name:\"Bruce Dern\"})-[:`work_period_(start)`]->(pv) return pv.year <> 1963",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Bruce Dern"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "work period (start)"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          1
        ],
        "inputs": [
          "1963",
          "!="
        ]
      }
    ],
    "sample_id": "train_92572",
    "answer": "yes"
  },
  {
    "graphq_ir": "whether <ES> <C> city of the United States </C> whose <A> WOEID </A> is text <V> 2406008 </V> </ES> <A> area </A> larger than number <V> 50 square kilometre </V>",
    "kopl": "FindAll().FilterStr(WOEID,2406008).FilterConcept(city of the United States).QueryAttr(area).VerifyNum(50 square kilometre,>)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <WOEID> ?pv_1 . ?pv_1 <pred:value> \"2406008\" . ?e <area> ?pv . ?pv <pred:unit> \"square kilometre\" . ?pv <pred:value> ?v . FILTER ( ?v > \"50\"^^xsd:double ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE (n1.WOEID = \"2406008\" AND n1.area >  50 square kilometre )\nRETURN isEmpty(n1)",
    "question": "Is the area more than 50 square kilometres for the U.S. city whose WOEID is 2406008?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:WOEID]->(pv_1:Resource{value:\"2406008\"}) match (e)-[:area]->(pv:Resource{unit:\"square kilometre\"}) return pv.value >  50.0 ",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "WOEID",
          "2406008"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "area"
        ]
      },
      {
        "function": "VerifyNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "50 square kilometre",
          ">"
        ]
      }
    ],
    "sample_id": "train_43176",
    "answer": "yes"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <ES> <E> Shelby County </E> whose <A> population </A> is number <V> 42274 </V> </ES> or <ES> <E> Linn County </E> whose <A> population </A> is number <V> 211226 </V> </ES> </ES>",
    "kopl": "Find(Shelby County).FilterNum(population,42274,=).Find(Linn County).FilterNum(population,211226,=).Or().Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Shelby County\" . ?e <population> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> \"42274\"^^xsd:double . } UNION { ?e <pred:name> \"Linn County\" . ?e <population> ?pv_2 . ?pv_2 <pred:unit> \"1\" . ?pv_2 <pred:value> \"211226\"^^xsd:double . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Shelby_County ( string population ) ( string = ) ( number 42274 ) ) ( call SW.filter en.Linn_County ( string population ) ( string = ) ( number 211226 ) ) ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Shelby County\"\nMATCH (n1) WHERE n1.population =  42274 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Linn County\"\nMATCH (n1) WHERE n1.population =  211226 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which area is smaller, Shelby County (the one whose population is 42274) or Linn County (the one whose population is 211226)?",
    "cypher_match": "call { match (e:Resource{name:\"Shelby County\"})-[:population]->(pv_1:Resource{unit:\"1\",value:42274.0}) return e union match (e:Resource{name:\"Linn County\"})-[:population]->(pv_2:Resource{unit:\"1\",value:211226.0}) return e } match (e)-[:area]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Shelby County"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "42274",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Linn County"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          2
        ],
        "inputs": [
          "population",
          "211226",
          "="
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          3
        ],
        "inputs": [
          "area",
          "less"
        ]
      }
    ],
    "sample_id": "train_11269",
    "answer": "Shelby County"
  },
  {
    "graphq_ir": "whether <ES> <C> college of the University of Oxford </C> whose <A> IPv4 routing prefix </A> is text <V> 129.67.60.0/22 </V> </ES> <A> inception </A> is date <V> 1989-08-01 </V>",
    "kopl": "FindAll().FilterStr(IPv4 routing prefix,129.67.60.0/22).FilterConcept(college of the University of Oxford).QueryAttr(inception).VerifyDate(1989-08-01,=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"college of the University of Oxford\" . ?e <IPv4_routing_prefix> ?pv_1 . ?pv_1 <pred:value> \"129.67.60.0/22\" . ?e <inception> ?pv . ?pv <pred:date> \"1989-08-01\"^^xsd:date .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:college_of_the_University_of_Oxford) WHERE (n1.IPv4_routing_prefix = \"129.67.60.0/22\" AND n1.inception =  1989-08-01 )\nRETURN isEmpty(n1)",
    "question": "If we know an University of Oxford, whose  IPv4 routing prefix is 129.67.60.0/22, was it founded on 1st August 1989 ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"college of the University of Oxford\"}) match (e)-[:IPv4_routing_prefix]->(pv_1:Resource{value:\"129.67.60.0/22\"}) match (e)-[:inception]->(pv:Resource) return pv.date = Date(\"1989-08-01\")",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "IPv4 routing prefix",
          "129.67.60.0/22"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "college of the University of Oxford"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "inception"
        ]
      },
      {
        "function": "VerifyDate",
        "dependencies": [
          3
        ],
        "inputs": [
          "1989-08-01",
          "="
        ]
      }
    ],
    "sample_id": "train_12977",
    "answer": "no"
  },
  {
    "graphq_ir": "which one has the largest <A> number of episodes </A> among <ES> <ES> <E> Joan of Arc </E> (<ES> ones that <R> cast member </R> forward to <E> Shirley MacLaine </E> </ES>) </ES> or <ES> <E> Savannah </E> whose <A> number of episodes </A> is number <V> 34 </V> </ES> </ES>",
    "kopl": "Find(Shirley MacLaine).Relate(cast member,backward).Find(Joan of Arc).And().Find(Savannah).FilterNum(number of episodes,34,=).Or().Select(number of episodes,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Joan of Arc\" . ?e <cast_member> ?e_1 . ?e_1 <pred:name> \"Shirley MacLaine\" . } UNION { ?e <pred:name> \"Savannah\" . ?e <number_of_episodes> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> \"34\"^^xsd:double . } ?e <number_of_episodes> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.Joan_of_Arc ( lambda s ( call SW.filter ( var s ) ( string cast_member ) ( string = ) en.Shirley_MacLaine ) ) ) ( call SW.filter en.Savannah ( string number_of_episodes ) ( string = ) ( number 34 ) ) ) ( string max ) ( string number_of_episodes ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Joan of Arc\"\nMATCH (n2) WHERE n2.name = \"Shirley MacLaine\"\nMATCH (n3)<-[r1:cast_member]-(n2)\nRETURN n3.name AS name\nORDER BY n3.number_of_episodes DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Savannah\"\nMATCH (n1) WHERE n1.number_of_episodes =  34 \nRETURN n1.name AS name\nORDER BY n3.number_of_episodes DESC\nLIMIT 1",
    "question": "Does the higher episode count belong to Joan of Arc, with Shirley MacLaine as a cast member, or Savannah, with 34 episodes?",
    "cypher_match": "call { match (e:Resource{name:\"Joan of Arc\"})-[:cast_member]->(e_1:Resource{name:\"Shirley MacLaine\"}) return e union match (e:Resource{name:\"Savannah\"})-[:number_of_episodes]->(pv_1:Resource{unit:\"1\",value:34.0}) return e } match (e)-[:number_of_episodes]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Shirley MacLaine"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "cast member",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Joan of Arc"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Savannah"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          4
        ],
        "inputs": [
          "number of episodes",
          "34",
          "="
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          5
        ],
        "inputs": [
          "number of episodes",
          "greater"
        ]
      }
    ],
    "sample_id": "train_39983",
    "answer": "Savannah"
  },
  {
    "graphq_ir": "what is the relation from <E> The Social Network </E> to <ES> <E> Egypt </E> whose <A> inflation rate </A> is number <V> 14.0 percentage </V> </ES>",
    "kopl": "Find(The Social Network).Find(Egypt).FilterNum(inflation rate,14.0 percentage,=).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"The Social Network\" . ?e_2 <pred:name> \"Egypt\" . ?e_2 <inflation_rate> ?pv . ?pv <pred:unit> \"percentage\" . ?pv <pred:value> \"14.0\"^^xsd:double . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"The Social Network\"\nMATCH (n2) WHERE n2.name = \"Egypt\"\nMATCH (n2) WHERE n2.inflation_rate =  14.0 percentage \nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between The Social Network and Egypt, which has an inflation rate of 14.0 percent?",
    "cypher_match": "match (e_2:Resource{name:\"Egypt\"})-[:inflation_rate]->(pv:Resource{unit:\"percentage\",value:14.0}) match (e_1:Resource{name:\"The Social Network\"})-[p]->(e_2:Resource{name:\"Egypt\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Social Network"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Egypt"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          1
        ],
        "inputs": [
          "inflation rate",
          "14.0 percentage",
          "="
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_46733",
    "answer": "film release region"
  },
  {
    "graphq_ir": "which one has the smallest <A> elevation above sea level </A> among <ES> <E> Laval </E> or <E> Vilnius </E> </ES>",
    "kopl": "Find(Laval).Find(Vilnius).Or().Select(elevation above sea level,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Laval\" .  } UNION { ?e <pred:name> \"Vilnius\" .  } ?e <elevation_above_sea_level> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Laval en.Vilnius ) ( string min ) ( string elevation_above_sea_level ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Laval\"\nRETURN n1.name AS name\nORDER BY n1.elevation_above_sea_level DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Vilnius\"\nRETURN n1.name AS name\nORDER BY n1.elevation_above_sea_level DESC\nLIMIT 1",
    "question": "Which has lower elevation above sea level, Laval or Vilnius?",
    "cypher_match": "call { match (e:Resource{name:\"Laval\"}) return e union match (e:Resource{name:\"Vilnius\"}) return e } match (e)-[:elevation_above_sea_level]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Laval"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Vilnius"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "elevation above sea level",
          "less"
        ]
      }
    ],
    "sample_id": "train_58759",
    "answer": "Laval"
  },
  {
    "graphq_ir": "what is the relation from <E> The Bourne Supremacy </E> to <E> Central Intelligence Agency </E>",
    "kopl": "Find(The Bourne Supremacy).Find(Central Intelligence Agency).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"The Bourne Supremacy\" . ?e_2 <pred:name> \"Central Intelligence Agency\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"The Bourne Supremacy\"\nMATCH (n2) WHERE n2.name = \"Central Intelligence Agency\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the connection between The Bourne Supremacy to Central Intelligence Agency?",
    "cypher_match": "match (e_1:Resource{name:\"The Bourne Supremacy\"})-[p]->(e_2:Resource{name:\"Central Intelligence Agency\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Bourne Supremacy"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Central Intelligence Agency"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_41666",
    "answer": "main subject"
  },
  {
    "graphq_ir": "what is the qualifier <Q> determination method </Q> of <ES> <C> national association football team </C> that <R> country </R> forward to <E> Cameroon </E> </ES> whose <A> ranking </A> is <V> 60 </V>",
    "kopl": "Find(Cameroon).Relate(country,backward).FilterConcept(national association football team).QueryAttrQualifier(ranking,60,determination method)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"national association football team\" . ?e <country> ?e_1 . ?e_1 <pred:name> \"Cameroon\" .  ?e <ranking> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"60\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <ranking> ; <pred:fact_t> ?pv ] <determination_method> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Cameroon\"\nMATCH (n1:national_association_football_team)<-[r1:country]-(n2) WHERE n1.ranking =  60 \nRETURN r1.determination_method",
    "question": "What is the determination method of 60, the ranking of the national association football team whose country is Cameroon?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"national association football team\"}) match (e)-[:country]->(e_1:Resource{name:\"Cameroon\"}) match (e)-[:ranking]->(pv:Resource{unit:\"1\",value:60.0}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"ranking\"}),(tmp)-[:determination_method]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Cameroon"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "country",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "national association football team"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "ranking",
          "60",
          "determination method"
        ]
      }
    ],
    "sample_id": "train_35764",
    "answer": "FIFA World Rankings"
  },
  {
    "graphq_ir": "what is the qualifier <Q> statement is subject of </Q> of <ES> <E> Romania </E> (<ES> ones that <R> diplomatic relation </R> forward to <E> Ukraine </E> </ES>) </ES> that <R> shares border with </R> to <E> Moldova </E>",
    "kopl": "Find(Ukraine).Relate(diplomatic relation,backward).Find(Romania).And().Find(Moldova).QueryRelationQualifier(shares border with,statement is subject of)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Romania\" . ?e_1 <diplomatic_relation> ?e_3 . ?e_3 <pred:name> \"Ukraine\" . ?e_2 <pred:name> \"Moldova\" . ?e_1 <shares_border_with> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <shares_border_with> ; <pred:fact_t> ?e_2 ] <statement_is_subject_of> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Romania\"\nMATCH (n2) WHERE n2.name = \"Ukraine\"\nMATCH (n3)<-[r1:diplomatic_relation]-(n2)\nMATCH (n4) WHERE n4.name = \"Moldova\"\nMATCH (n3)-[r2:shares_border_with]->(n4)\nRETURN r2.statement_is_subject_of",
    "question": "What is the subject of the statement that Romania (that has a diplomatic relationship with Ukraine) shares a border with Moldova?",
    "cypher_match": "match (e_1:Resource{name:\"Romania\"})-[:diplomatic_relation]->(e_3:Resource{name:\"Ukraine\"}) match (e_1:Resource{name:\"Romania\"})-[:shares_border_with]->(e_2:Resource{name:\"Moldova\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"shares_border_with\"}),(tmp)-[:statement_is_subject_of]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Ukraine"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "diplomatic relation",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Romania"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Moldova"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "shares border with",
          "statement is subject of"
        ]
      }
    ],
    "sample_id": "train_44723",
    "answer": "Moldova–Romania border"
  },
  {
    "graphq_ir": "which one has the smallest <A> duration </A> among <ES> <E> Lost Highway </E> or <E> Legends of the Fall </E> </ES>",
    "kopl": "Find(Lost Highway).Find(Legends of the Fall).Or().Select(duration,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Lost Highway\" .  } UNION { ?e <pred:name> \"Legends of the Fall\" .  } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Lost_Highway en.Legends_of_the_Fall ) ( string min ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Lost Highway\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Legends of the Fall\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Which movie cost less to make, Lost Highway or Legends of the Fall?",
    "cypher_match": "call { match (e:Resource{name:\"Lost Highway\"}) return e union match (e:Resource{name:\"Legends of the Fall\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Lost Highway"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Legends of the Fall"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "duration",
          "less"
        ]
      }
    ],
    "sample_id": "train_13135",
    "answer": "Legends of the Fall"
  },
  {
    "graphq_ir": "whether <ES> <C> organization </C> that <R> production company </R> backward to <E> Dragon Ball Z: Dead Zone </E> </ES> <A> Corporate Number (Japan) </A> is text <V> 6010001034866 </V>",
    "kopl": "Find(Dragon Ball Z: Dead Zone).Relate(production company,forward).FilterConcept(organization).QueryAttr(Corporate Number (Japan)).VerifyStr(6010001034866)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"organization\" . ?e_1 <production_company> ?e . ?e_1 <pred:name> \"Dragon Ball Z: Dead Zone\" .  ?e <Corporate_Number_(Japan)> ?pv . ?pv <pred:value> \"6010001034866\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Dragon Ball Z: Dead Zone\"\nMATCH (n1:organization)-[r1:production_company]->(n2) WHERE n1.Corporate_Number_(Japan) = \"6010001034866\"\nRETURN isEmpty(n1)",
    "question": "Does the organization with a Corporate Number in Japan of 6010001034866 serve as the Dragon Ball Z: Dead Zone production company?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"organization\"}) match (e)-[:`Corporate_Number_(Japan)`]->(pv:Resource) match (e_1:Resource{name:\"Dragon Ball Z: Dead Zone\"})-[:production_company]->(e) return pv.value = \"6010001034866\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Dragon Ball Z: Dead Zone"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "production company",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "organization"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "Corporate Number (Japan)"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "6010001034866"
        ]
      }
    ],
    "sample_id": "train_61488",
    "answer": "yes"
  },
  {
    "graphq_ir": "whether <ES> <E> Max Weber </E> whose <A> date of birth </A> is date <V> 1897-08-02 </V> </ES> <A> date of death </A> is year <V> 1842 </V>",
    "kopl": "Find(Max Weber).FilterDate(date of birth,1897-08-02,=).QueryAttr(date of death).VerifyYear(1842,=)",
    "sparql": "ASK { ?e <pred:name> \"Max Weber\" . ?e <date_of_birth> ?pv_1 . ?pv_1 <pred:date> \"1897-08-02\"^^xsd:date . ?e <date_of_death> ?pv . ?pv <pred:year> 1842 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE (n1.name = \"Max Weber\" AND n1.date_of_death =  1842 )\nMATCH (n1) WHERE n1.date_of_birth =  1897-08-02 \nRETURN isEmpty(n1)",
    "question": "Did Max Weber (the one whose date of birth is 1897-08-02) die in 1842?",
    "cypher_match": "match (e:Resource{name:\"Max Weber\"})-[:date_of_birth]->(pv_1:Resource{date:Date(\"1897-08-02\")}) match (e:Resource{name:\"Max Weber\"})-[:date_of_death]->(pv:Resource{year:1842}) return pv.year = 1842",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Max Weber"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "date of birth",
          "1897-08-02",
          "="
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          1
        ],
        "inputs": [
          "date of death"
        ]
      },
      {
        "function": "VerifyYear",
        "dependencies": [
          2
        ],
        "inputs": [
          "1842",
          "="
        ]
      }
    ],
    "sample_id": "train_77017",
    "answer": "no"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Victoria </E> whose <A> publication date </A> is date <V> 2015-06-11 </V> </ES> to <E> German </E>",
    "kopl": "Find(Victoria).FilterDate(publication date,2015-06-11,=).Find(German).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Victoria\" . ?e_1 <publication_date> ?pv . ?pv <pred:date> \"2015-06-11\"^^xsd:date . ?e_2 <pred:name> \"German\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Victoria\"\nMATCH (n1) WHERE n1.publication_date =  2015-06-11 \nMATCH (n2) WHERE n2.name = \"German\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is the Victoria published on 2015-06-11 related to German?",
    "cypher_match": "match (e_1:Resource{name:\"Victoria\"})-[:publication_date]->(pv:Resource{date:Date(\"2015-06-11\")}) match (e_1:Resource{name:\"Victoria\"})-[p]->(e_2:Resource{name:\"German\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Victoria"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "publication date",
          "2015-06-11",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "German"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_61285",
    "answer": "original language of film or TV show"
  },
  {
    "graphq_ir": "what is <ES> <C> human </C> whose <A> ISNI </A> is text <V> 0000 0001 1483 0433 </V> </ES>",
    "kopl": "FindAll().FilterStr(ISNI,0000 0001 1483 0433).FilterConcept(human).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 1483 0433\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.human ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0001 1483 0433 ) ) )",
    "cypher": "MATCH (n1:human) WHERE n1.ISNI = \"0000 0001 1483 0433\"\nRETURN n1.name",
    "question": "What person's ISNI is 0000 0001 1483 0433?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:ISNI]->(pv:Resource{value:\"0000 0001 1483 0433\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI",
          "0000 0001 1483 0433"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_73068",
    "answer": "Doug Savant"
  },
  {
    "graphq_ir": "what is the attribute <A> inception </A> of <ES> <C> British Academy Film Awards </C> that <R> winner </R> forward to <E> Anne V. Coates </E> ( <Q> point in time </Q> is year <V> 2007 </V> ) </ES>",
    "kopl": "Find(Anne V. Coates).Relate(winner,backward).QFilterYear(point in time,2007,=).FilterConcept(British Academy Film Awards).QueryAttr(inception)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"British Academy Film Awards\" . ?e <winner> ?e_1 . ?e_1 <pred:name> \"Anne V. Coates\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <winner> ; <pred:fact_t> ?e_1 ] <point_in_time> ?qpv . ?qpv <pred:year> 2007 . ?e <inception> ?pv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Anne V. Coates\"\nMATCH (n1:British_Academy_Film_Awards)<-[r1:winner]-(n2) WHERE r1.point_in_time =  2007 \nRETURN n1.inception",
    "question": "What is the founding date of the British Academy Film Awards whose winners include Anne V. Coates in 2007?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"British Academy Film Awards\"}) match (e)-[:winner]->(e_1:Resource{name:\"Anne V. Coates\"}) match (e)-[:inception]->(pv),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"winner\"}),(tmp)-[:point_in_time]->(qpv:Resource{year:2007}) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Anne V. Coates"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "winner",
          "backward"
        ]
      },
      {
        "function": "QFilterYear",
        "dependencies": [
          1
        ],
        "inputs": [
          "point in time",
          "2007",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "British Academy Film Awards"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "inception"
        ]
      }
    ],
    "sample_id": "train_25058",
    "answer": "1971"
  },
  {
    "graphq_ir": "which one has the largest <A> area </A> among <ES> <ES> <E> Quincy </E> whose <A> subreddit </A> is text <V> QuincyIL </V> </ES> or <ES> <E> Mansfield </E> (<ES> ones that <R> filming location </R> backward to <E> The Shawshank Redemption </E> </ES>) </ES> </ES>",
    "kopl": "Find(Quincy).FilterStr(subreddit,QuincyIL).Find(The Shawshank Redemption).Relate(filming location,forward).Find(Mansfield).And().Or().Select(area,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Quincy\" . ?e <subreddit> ?pv_1 . ?pv_1 <pred:value> \"QuincyIL\" . } UNION { ?e <pred:name> \"Mansfield\" . ?e_1 <filming_location> ?e . ?e_1 <pred:name> \"The Shawshank Redemption\" . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Quincy ( string subreddit ) ( string = ) ( string QuincyIL ) ) ( call SW.and en.Mansfield ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string filming_location ) ) ( string = ) en.The_Shawshank_Redemption ) ) ) ) ( string max ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Quincy\"\nMATCH (n1) WHERE n1.subreddit = \"QuincyIL\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Mansfield\"\nMATCH (n2) WHERE n2.name = \"The Shawshank Redemption\"\nMATCH (n3)-[r1:filming_location]->(n2)\nRETURN n3.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which has more area, Quincy whose subreddit is QuincyIL or Mansfield that is the filming location of The Shawshank Redemption?",
    "cypher_match": "call { match (e:Resource{name:\"Quincy\"})-[:subreddit]->(pv_1:Resource{value:\"QuincyIL\"}) return e union match (e_1:Resource{name:\"The Shawshank Redemption\"})-[:filming_location]->(e:Resource{name:\"Mansfield\"}) return e } match (e)-[:area]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Quincy"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "subreddit",
          "QuincyIL"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Shawshank Redemption"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "filming location",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Mansfield"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          5
        ],
        "inputs": [
          "area",
          "greater"
        ]
      }
    ],
    "sample_id": "train_14576",
    "answer": "Mansfield"
  },
  {
    "graphq_ir": "what is the attribute <A> inception </A> of <ES> <C> public office </C> that <R> position held </R> backward to <ES> <E> John Davis </E> whose <A> British Museum person-institution </A> is text <V> 203983 </V> </ES> ( <Q> start time </Q> is year <V> 1834 </V> ) </ES>",
    "kopl": "Find(John Davis).FilterStr(British Museum person-institution,203983).Relate(position held,forward).QFilterYear(start time,1834,=).FilterConcept(public office).QueryAttr(inception)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"public office\" . ?e_1 <position_held> ?e . ?e_1 <pred:name> \"John Davis\" . ?e_1 <British_Museum_person-institution> ?pv_1 . ?pv_1 <pred:value> \"203983\" . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <position_held> ; <pred:fact_t> ?e ] <start_time> ?qpv . ?qpv <pred:year> 1834 . ?e <inception> ?pv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"John Davis\"\nMATCH (n2) WHERE n2.British_Museum_person-institution = \"203983\"\nMATCH (n1:public_office)-[r1:position_held]->(n2) WHERE r1.start_time =  1834 \nRETURN n1.inception",
    "question": "When was a public office established if we know it was the position of John Davis (John Davis (the one whose British Museum person-institution is 203983) in 1834?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"public office\"}) match (e)-[:inception]->(pv) match (e_1:Resource{name:\"John Davis\"})-[:position_held]->(e) match (e_1:Resource{name:\"John Davis\"})-[:`British_Museum_person-institution`]->(pv_1:Resource{value:\"203983\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e), (tmp)-[:fact_r]-(qr:Relation{name:\"position_held\"}),(tmp)-[:start_time]->(qpv:Resource{year:1834}) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "John Davis"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "British Museum person-institution",
          "203983"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "position held",
          "forward"
        ]
      },
      {
        "function": "QFilterYear",
        "dependencies": [
          2
        ],
        "inputs": [
          "start time",
          "1834",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "public office"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          4
        ],
        "inputs": [
          "inception"
        ]
      }
    ],
    "sample_id": "train_81715",
    "answer": "1780-10-25"
  },
  {
    "graphq_ir": "what is the attribute <A> title </A> of <E> Tucker: The Man and His Dream </E>",
    "kopl": "Find(Tucker: The Man and His Dream).QueryAttr(title)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Tucker: The Man and His Dream\" . ?e <title> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Tucker:_The_Man_and_His_Dream ( string title ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Tucker: The Man and His Dream\"\nRETURN n1.title",
    "question": "What is the title of Tucker: The Man and His Dream?",
    "cypher_match": "match (e:Resource{name:\"Tucker: The Man and His Dream\"})-[:title]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tucker: The Man and His Dream"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title"
        ]
      }
    ],
    "sample_id": "train_68219",
    "answer": "Tucker: The Man and His Dream"
  },
  {
    "graphq_ir": "which one has the smallest <A> elevation above sea level </A> among <ES> <C> city in New Jersey </C> whose <A> population </A> smaller than number <V> 43000 </V> </ES>",
    "kopl": "FindAll().FilterNum(population,43000,<).FilterConcept(city in New Jersey).Select(elevation above sea level,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city in New Jersey\" . ?e <population> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> ?v_1 . FILTER ( ?v_1 < \"43000\"^^xsd:double ) . ?e <elevation_above_sea_level> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.city_in_New_Jersey ) ( string ! type ) ) ( string population ) ( string < ) ( number 43000 ) ) ( string min ) ( string elevation_above_sea_level ) ) )",
    "cypher": "MATCH (n1:city_in_New_Jersey) WHERE n1.population <  43000 \nRETURN n1.name AS name\nORDER BY n1.elevation_above_sea_level DESC\nLIMIT 1",
    "question": "I want to know which is the one with the least elevation, over sea level, within the city in New Jersey that has a population of under 43000",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city in New Jersey\"}) match (e)-[:population]->(pv_1:Resource{unit:\"1\"}) match (e)-[:elevation_above_sea_level]->(pv) where pv_1.value <  43000.0  return e order by pv.value limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "population",
          "43000",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city in New Jersey"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "elevation above sea level",
          "smallest"
        ]
      }
    ],
    "sample_id": "train_83659",
    "answer": "Atlantic City"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <C> non-metropolitan district </C> that <R> located in the administrative territorial entity </R> forward to <ES> <E> Surrey </E> whose <A> NUTS code </A> is text <V> UKJ23 </V> </ES> </ES>",
    "kopl": "Find(Surrey).FilterStr(NUTS code,UKJ23).Relate(located in the administrative territorial entity,backward).FilterConcept(non-metropolitan district).Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"non-metropolitan district\" . ?e <located_in_the_administrative_territorial_entity> ?e_1 . ?e_1 <pred:name> \"Surrey\" . ?e_1 <NUTS_code> ?pv_1 . ?pv_1 <pred:value> \"UKJ23\" . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.non-metropolitan_district ) ( string ! type ) ) ( string located_in_the_administrative_territorial_entity ) ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Surrey\"\nMATCH (n2) WHERE n2.NUTS_code = \"UKJ23\"\nMATCH (n1:non-metropolitan_district)<-[r1:located_in_the_administrative_territorial_entity]-(n2)\nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which non-metropolitan district in Surrey (whose NUTS code is UKJ23) has the smallest land area?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"non-metropolitan district\"}) match (e)-[:located_in_the_administrative_territorial_entity]->(e_1:Resource{name:\"Surrey\"}) match (e)-[:area]->(pv) match (e_1:Resource{name:\"Surrey\"})-[:NUTS_code]->(pv_1:Resource{value:\"UKJ23\"}) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Surrey"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "NUTS code",
          "UKJ23"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "located in the administrative territorial entity",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "non-metropolitan district"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          3
        ],
        "inputs": [
          "area",
          "smallest"
        ]
      }
    ],
    "sample_id": "train_65219",
    "answer": "Woking"
  },
  {
    "graphq_ir": "which one has the largest <A> cost </A> among <ES> <ES> <E> Die Another Day </E> whose <A> title </A> is text <V> Die Another Day </V> </ES> or <ES> <E> Halloween </E> (<ES> ones that <R> film release region </R> forward to <E> Italy </E> </ES>) </ES> </ES>",
    "kopl": "Find(Die Another Day).FilterStr(title,Die Another Day).Find(Italy).Relate(film release region,backward).Find(Halloween).And().Or().Select(cost,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Die Another Day\" . ?e <title> ?pv_1 . ?pv_1 <pred:value> \"Die Another Day\" . } UNION { ?e <pred:name> \"Halloween\" . ?e <film_release_region> ?e_1 . ?e_1 <pred:name> \"Italy\" . } ?e <cost> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Die_Another_Day ( string title ) ( string = ) ( string Die Another Day ) ) ( call SW.and en.Halloween ( lambda s ( call SW.filter ( var s ) ( string film_release_region ) ( string = ) en.Italy ) ) ) ) ( string max ) ( string cost ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Die Another Day\"\nMATCH (n1) WHERE n1.title = \"Die Another Day\"\nRETURN n1.name AS name\nORDER BY n1.cost DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Halloween\"\nMATCH (n2) WHERE n2.name = \"Italy\"\nMATCH (n3)<-[r1:film_release_region]-(n2)\nRETURN n3.name AS name\nORDER BY n1.cost DESC\nLIMIT 1",
    "question": "Which cost more, Die Another Day, which was titled Die Another Day, or Halloween that was released in Italy?",
    "cypher_match": "call { match (e:Resource{name:\"Die Another Day\"})-[:title]->(pv_1:Resource{value:\"Die Another Day\"}) return e union match (e:Resource{name:\"Halloween\"})-[:film_release_region]->(e_1:Resource{name:\"Italy\"}) return e } match (e)-[:cost]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Die Another Day"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "Die Another Day"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Italy"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "film release region",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Halloween"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          5
        ],
        "inputs": [
          "cost",
          "greater"
        ]
      }
    ],
    "sample_id": "train_19945",
    "answer": "Die Another Day"
  },
  {
    "graphq_ir": "which one has the largest <A> elevation above sea level </A> among <ES> <C> human settlement </C> whose <A> local dialing code </A> is text <V> 973 </V> </ES>",
    "kopl": "FindAll().FilterStr(local dialing code,973).FilterConcept(human settlement).Select(elevation above sea level,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"human settlement\" . ?e <local_dialing_code> ?pv_1 . ?pv_1 <pred:value> \"973\" . ?e <elevation_above_sea_level> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.human_settlement ) ( string ! type ) ) ( string local_dialing_code ) ( string = ) ( string 973 ) ) ( string max ) ( string elevation_above_sea_level ) ) )",
    "cypher": "MATCH (n1:human_settlement) WHERE n1.local_dialing_code = \"973\"\nRETURN n1.name AS name\nORDER BY n1.elevation_above_sea_level DESC\nLIMIT 1",
    "question": "Which human settlement has the largest elevation (above sea level) among those with the local dialing code of 973?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human settlement\"}) match (e)-[:local_dialing_code]->(pv_1:Resource{value:\"973\"}) match (e)-[:elevation_above_sea_level]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "local dialing code",
          "973"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human settlement"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "elevation above sea level",
          "largest"
        ]
      }
    ],
    "sample_id": "train_49783",
    "answer": "West Orange"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <ES> <E> Robert Guillaume </E> (<ES> ones that <R> award received </R> forward to <E> Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series </E> </ES>) </ES>",
    "kopl": "Find(Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series).Relate(award received,backward).Find(Robert Guillaume).And().QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Robert Guillaume\" . ?e <award_received> ?e_1 . ?e_1 <pred:name> \"Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series\" .  ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.and en.Robert_Guillaume ( lambda s ( call SW.filter ( var s ) ( string award_received ) ( string = ) en.Primetime_Emmy_Award_for_Outstanding_Supporting_Actor_in_a_Comedy_Series ) ) ) ( string ISNI ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Robert Guillaume\"\nMATCH (n2) WHERE n2.name = \"Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series\"\nMATCH (n3)<-[r1:award_received]-(n2)\nRETURN n3.ISNI",
    "question": "What is the ISNI for Robert Guillaume who received a Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series?",
    "cypher_match": "match (e:Resource{name:\"Robert Guillaume\"})-[:award_received]->(e_1:Resource{name:\"Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series\"}) match (e:Resource{name:\"Robert Guillaume\"})-[:ISNI]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Primetime Emmy Award for Outstanding Supporting Actor in a Comedy Series"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "award received",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Robert Guillaume"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_27664",
    "answer": "0000 0001 1468 1570"
  },
  {
    "graphq_ir": "what is <ES> <ES> <C> city of Pennsylvania </C> that <R> located in the administrative territorial entity </R> backward to <E> University of Pennsylvania </E> </ES> and <ES> <C> city of Pennsylvania </C> whose <A> population </A> is not number <V> 250000000 </V> ( <Q> point in time </Q> is year <V> 1820 </V> ) </ES> </ES>",
    "kopl": "Find(University of Pennsylvania).Relate(located in the administrative territorial entity,forward).FilterConcept(city of Pennsylvania).FindAll().FilterNum(population,250000000,!=).QFilterYear(point in time,1820,=).FilterConcept(city of Pennsylvania).And().What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of Pennsylvania\" . ?e_1 <located_in_the_administrative_territorial_entity> ?e . ?e_1 <pred:name> \"University of Pennsylvania\" .  ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v != \"250000000\"^^xsd:double ) . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv . ?qpv <pred:year> 1820 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"University of Pennsylvania\"\nMATCH (n3:city_of_Pennsylvania)-[r1:located_in_the_administrative_territorial_entity]->(n2)\nMATCH (n3:city_of_Pennsylvania) WHERE n3.population <>  250000000 \nRETURN n3.name",
    "question": "Which city in Pennsylvania, containing University of Pennsylvania, counted a number of people other than  250,000,000  in 1820?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of Pennsylvania\"}) match (e)-[:population]->(pv:Resource{unit:\"1\"}) match (e_1:Resource{name:\"University of Pennsylvania\"})-[:located_in_the_administrative_territorial_entity]->(e),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv:Resource{year:1820}) where pv.value <>  250000000.0  return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "University of Pennsylvania"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "located in the administrative territorial entity",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of Pennsylvania"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "population",
          "250000000",
          "!="
        ]
      },
      {
        "function": "QFilterYear",
        "dependencies": [
          4
        ],
        "inputs": [
          "point in time",
          "1820",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          5
        ],
        "inputs": [
          "city of Pennsylvania"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          6
        ],
        "inputs": []
      },
      {
        "function": "What",
        "dependencies": [
          7
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_26252",
    "answer": "Philadelphia"
  },
  {
    "graphq_ir": "how many <ES> <C> miniseries </C> that <R> nominated for </R> forward to <ES> <C> Primetime Emmy Award </C> that <R> nominated for </R> backward to <E> Steven Moffat </E> ( <Q> for work </Q> is text <V> Sherlock </V> ) </ES> </ES>",
    "kopl": "Find(Steven Moffat).Relate(nominated for,forward).QFilterStr(for work,Sherlock).FilterConcept(Primetime Emmy Award).Relate(nominated for,backward).FilterConcept(miniseries).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"miniseries\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"Primetime Emmy Award\" . ?e_2 <nominated_for> ?e_1 . ?e_2 <pred:name> \"Steven Moffat\" . [ <pred:fact_h> ?e_2 ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <for_work> ?qpv . ?qpv <pred:value> \"Sherlock\" .   }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Steven Moffat\"\nMATCH (n2:Primetime_Emmy_Award)-[r2:nominated_for]->(n3) WHERE r2.for_work = \"Sherlock\"\nMATCH (n1:miniseries)<-[r1:nominated_for]-(n2)\nRETURN count(n1)",
    "question": "The Primetime Emmy Award nominated to Steven Moffat for Sherlock was also nominated to how many miniseries?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"miniseries\"}) match (e)-[:nominated_for]->(e_1) match (e_1)-[:instance_of]->(c_1:Resource{name:\"Primetime Emmy Award\"}) match (e_2:Resource{name:\"Steven Moffat\"})-[:nominated_for]->(e_1),(e_2)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:for_work]->(qpv:Resource{value:\"Sherlock\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Steven Moffat"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "forward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "for work",
          "Sherlock"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "Primetime Emmy Award"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "miniseries"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_93159",
    "answer": "9"
  },
  {
    "graphq_ir": "how many <ES> <C> cable channel </C> whose <A> official website </A> is text <V> https://www.international.tbs.com/ </V> </ES>",
    "kopl": "FindAll().FilterStr(official website,https://www.international.tbs.com/).FilterConcept(cable channel).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"cable channel\" . ?e <official_website> ?pv . ?pv <pred:value> \"https://www.international.tbs.com/\" .  }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.cable_channel ) ( string ! type ) ) ( string official_website ) ( string = ) ( string https://www.international.tbs.com/ ) ) ) )",
    "cypher": "MATCH (n1:cable_channel) WHERE n1.official_website = \"https://www.international.tbs.com/\"\nRETURN count(n1)",
    "question": "How manu cable channels there are whose official website is https://www.international.tbs.com/?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"cable channel\"}) match (e)-[:official_website]->(pv:Resource{value:\"https://www.international.tbs.com/\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "https://www.international.tbs.com/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "cable channel"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_21075",
    "answer": "1"
  },
  {
    "graphq_ir": "what is the attribute <A> ISNI </A> of <E> Capcom </E>",
    "kopl": "Find(Capcom).QueryAttr(ISNI)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Capcom\" . ?e <ISNI> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty en.Capcom ( string ISNI ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Capcom\"\nRETURN n1.ISNI",
    "question": "What is the ISNI for Capcom?",
    "cypher_match": "match (e:Resource{name:\"Capcom\"})-[:ISNI]->(pv) return distinct pv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Capcom"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          0
        ],
        "inputs": [
          "ISNI"
        ]
      }
    ],
    "sample_id": "train_1726",
    "answer": "0000 0001 1703 8185"
  },
  {
    "graphq_ir": "what is <ES> <C> visual artwork </C> that <R> followed by </R> backward to <ES> <E> The Chronicles of Narnia: Prince Caspian </E> whose <A> duration </A> is number <V> 140 minute </V> </ES> </ES>",
    "kopl": "Find(The Chronicles of Narnia: Prince Caspian).FilterNum(duration,140 minute,=).Relate(followed by,forward).FilterConcept(visual artwork).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"visual artwork\" . ?e_1 <followed_by> ?e . ?e_1 <pred:name> \"The Chronicles of Narnia: Prince Caspian\" . ?e_1 <duration> ?pv . ?pv <pred:unit> \"minute\" . ?pv <pred:value> \"140\"^^xsd:double .   }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.visual_artwork ) ( string ! type ) ) ( call SW.reverse ( string followed_by ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"The Chronicles of Narnia: Prince Caspian\"\nMATCH (n2) WHERE n2.duration =  140 minute \nMATCH (n1:visual_artwork)-[r1:followed_by]->(n2)\nRETURN n1.name",
    "question": "The Chronicles of Narnia: Prince Caspian (run-time 140 minutes) is followed by what visual artwork?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"visual artwork\"}) match (e_1:Resource{name:\"The Chronicles of Narnia: Prince Caspian\"})-[:followed_by]->(e) match (e_1:Resource{name:\"The Chronicles of Narnia: Prince Caspian\"})-[:duration]->(pv:Resource{unit:\"minute\",value:140.0}) return distinct e.name",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Chronicles of Narnia: Prince Caspian"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "duration",
          "140 minute",
          "="
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "followed by",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          3
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_19297",
    "answer": "The Chronicles of Narnia: The Voyage of the Dawn Treader"
  },
  {
    "graphq_ir": "what is the qualifier <Q> language of work or name </Q> of <ES> <C> higher education institution </C> whose <A> located at street address (DEPRECATED) </A> is text <V> 1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098 </V> </ES> whose <A> official website </A> is <V> http://www.iup.edu </V>",
    "kopl": "FindAll().FilterStr(located at street address (DEPRECATED),1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098).FilterConcept(higher education institution).QueryAttrQualifier(official website,http://www.iup.edu,language of work or name)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"higher education institution\" . ?e <located_at_street_address_(DEPRECATED)> ?pv_1 . ?pv_1 <pred:value> \"1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098\" . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.iup.edu\" . [ <pred:fact_h> ?e ; <pred:fact_r> <official_website> ; <pred:fact_t> ?pv ] <language_of_work_or_name> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:higher_education_institution) WHERE (n1.located_at_street_address_(DEPRECATED) = \"1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098\" AND n1.official_website =  http://www.iup.edu )\nRETURN .language_of_work_or_name",
    "question": "Which language is associated with http://www.iup.edu, the official website of the higher education institution whose street address is 1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"higher education institution\"}) match (e)-[:`located_at_street_address_(DEPRECATED)`]->(pv_1:Resource{value:\"1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098\"}) match (e)-[:official_website]->(pv:Resource{value:\"http://www.iup.edu\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"official_website\"}),(tmp)-[:language_of_work_or_name]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "located at street address (DEPRECATED)",
          "1011 South Dr 201 Sutton Hall, Indiana, PA, 15705-1098"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "higher education institution"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          2
        ],
        "inputs": [
          "official website",
          "http://www.iup.edu",
          "language of work or name"
        ]
      }
    ],
    "sample_id": "train_31738",
    "answer": "English"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> American Idol </E> (<ES> ones that <R> creator </R> forward to <E> Simon Fuller </E> </ES>) </ES> to <E> Ryan Seacrest </E>",
    "kopl": "Find(Simon Fuller).Relate(creator,backward).Find(American Idol).And().Find(Ryan Seacrest).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"American Idol\" . ?e_1 <creator> ?e_3 . ?e_3 <pred:name> \"Simon Fuller\" . ?e_2 <pred:name> \"Ryan Seacrest\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"American Idol\"\nMATCH (n2) WHERE n2.name = \"Simon Fuller\"\nMATCH (n3)<-[r1:creator]-(n2)\nMATCH (n4) WHERE n4.name = \"Ryan Seacrest\"\nMATCH (n3)-[r2]->(n4)\nRETURN r2.label",
    "question": "What is the reltation between American Idol created by SImon Fuller to that of Ryan Seacrest?",
    "cypher_match": "match (e_1:Resource{name:\"American Idol\"})-[:creator]->(e_3:Resource{name:\"Simon Fuller\"}) match (e_1:Resource{name:\"American Idol\"})-[p]->(e_2:Resource{name:\"Ryan Seacrest\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Simon Fuller"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "creator",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "American Idol"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Ryan Seacrest"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_5251",
    "answer": "presenter"
  },
  {
    "graphq_ir": "what is the relation from <E> Jermaine Easter </E> to <E> Wolverhampton Wanderers F.C. </E>",
    "kopl": "Find(Jermaine Easter).Find(Wolverhampton Wanderers F.C.).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Jermaine Easter\" . ?e_2 <pred:name> \"Wolverhampton Wanderers F.C.\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Jermaine Easter\"\nMATCH (n2) WHERE n2.name = \"Wolverhampton Wanderers F.C.\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "What is the relationship between Jermaine Easter and Wolverhampton Wanderers F.C.?",
    "cypher_match": "match (e_1:Resource{name:\"Jermaine Easter\"})-[p]->(e_2:Resource{name:\"Wolverhampton Wanderers F.C.\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jermaine Easter"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Wolverhampton Wanderers F.C."
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_91808",
    "answer": "member of sports team"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <C> big city </C> whose <A> annual number of weddings </A> smaller than number <V> 1000 </V> </ES>",
    "kopl": "FindAll().FilterNum(annual number of weddings,1000,<).FilterConcept(big city).Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"big city\" . ?e <annual_number_of_weddings> ?pv_1 . ?pv_1 <pred:unit> \"1\" . ?pv_1 <pred:value> ?v_1 . FILTER ( ?v_1 < \"1000\"^^xsd:double ) . ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.big_city ) ( string ! type ) ) ( string annual_number_of_weddings ) ( string < ) ( number 1000 ) ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1:big_city) WHERE n1.annual_number_of_weddings <  1000 \nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Out of the big cities, with fewer than 1000 annual number of weddings, which has the smallest area?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"big city\"}) match (e)-[:annual_number_of_weddings]->(pv_1:Resource{unit:\"1\"}) match (e)-[:area]->(pv) where pv_1.value <  1000.0  return e order by pv.value limit 1",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "annual number of weddings",
          "1000",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "big city"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "area",
          "smallest"
        ]
      }
    ],
    "sample_id": "train_1356",
    "answer": "Leuven"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> death metal </C> that <R> country of origin </R> forward to <E> Finland </E> </ES> or <ES> <C> death metal </C> whose <A> inception </A> smaller than year <V> 1990 </V> </ES> </ES>",
    "kopl": "Find(Finland).Relate(country of origin,backward).FilterConcept(death metal).FindAll().FilterYear(inception,1990,<).FilterConcept(death metal).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"death metal\" .  { ?e <country_of_origin> ?e_1 . ?e_1 <pred:name> \"Finland\" .  } UNION { ?e <inception> ?pv . ?pv <pred:year> ?v . FILTER ( ?v < 1990 ) .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.death_metal ) ( string ! type ) ) ( string country_of_origin ) ) ( call SW.filter ( getProperty ( singleton en.death_metal ) ( string ! type ) ) ( string inception ) ( string < ) ( year 1990 ) ) ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"Finland\"\nMATCH (n1:death_metal)<-[r1:country_of_origin]-(n2)\nRETURN count(n1)\nUNION\nMATCH (n1:death_metal) WHERE n1.inception <  1990 \nRETURN count(n1)",
    "question": "How many death metals have origins in Finland or have an inception time before 1990?",
    "cypher_match": "call { match (e)-[:country_of_origin]->(e_1:Resource{name:\"Finland\"}) return e union match (e)-[:inception]->(pv)  where pv.year < 1990 return e } match (e)-[:instance_of]->(c:Resource{name:\"death metal\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Finland"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "country of origin",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "death metal"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "inception",
          "1990",
          "<"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "death metal"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_91904",
    "answer": "3"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> profession </C> whose <A> OSM tag or key </A> is text <V> Tag:shop=hairdresser </V> </ES> or <ES> <C> profession </C> whose <A> SBC-2010 occupation code </A> is text <V> 610405 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(OSM tag or key,Tag:shop=hairdresser).FilterConcept(profession).FindAll().FilterStr(SBC-2010 occupation code,610405).FilterConcept(profession).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"profession\" .  { ?e <OSM_tag_or_key> ?pv . ?pv <pred:value> \"Tag:shop=hairdresser\" .  } UNION { ?e <SBC-2010_occupation_code> ?pv . ?pv <pred:value> \"610405\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.profession ) ( string ! type ) ) ( string OSM_tag_or_key ) ( string = ) ( string Tag:shop=hairdresser ) ) ( call SW.filter ( getProperty ( singleton en.profession ) ( string ! type ) ) ( string SBC-2010_occupation_code ) ( string = ) ( string 610405 ) ) ) ) )",
    "cypher": "MATCH (n1:profession) WHERE n1.OSM_tag_or_key = \"Tag:shop=hairdresser\"\nRETURN count(n1)\nUNION\nMATCH (n1:profession) WHERE n1.SBC-2010_occupation_code = \"610405\"\nRETURN count(n1)",
    "question": "How many professions have an OSM tag or key of Tag:shop=hairdresser or an SBC-2010 occupation code of 610405?",
    "cypher_match": "call { match (e)-[:OSM_tag_or_key]->(pv:Resource{value:\"Tag:shop=hairdresser\"}) return e union match (e)-[:`SBC-2010_occupation_code`]->(pv:Resource{value:\"610405\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"profession\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "OSM tag or key",
          "Tag:shop=hairdresser"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "profession"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "SBC-2010 occupation code",
          "610405"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "profession"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_26633",
    "answer": "2"
  },
  {
    "graphq_ir": "how many <ES> <C> capital </C> that <R> film release region </R> backward to <ES> <C> visual artwork </C> whose <A> title </A> is text <V> جدایی نادر از سیمین </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(title,جدایی نادر از سیمین).FilterConcept(visual artwork).Relate(film release region,forward).FilterConcept(capital).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"capital\" . ?e_1 <film_release_region> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"visual artwork\" . ?e_1 <title> ?pv . ?pv <pred:value> \"جدایی نادر از سیمین\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.capital ) ( string ! type ) ) ( call SW.reverse ( string film_release_region ) ) ) ) )",
    "cypher": "MATCH (n2:visual_artwork) WHERE n2.title = \"جدایی نادر از سیمین\"\nMATCH (n1:capital)-[r1:film_release_region]->(n2)\nRETURN count(n1)",
    "question": "What is the number of capitals that are the release territory of the visual artwork titled جدایی نادر از سیمین?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"capital\"}) match (e_1)-[:film_release_region]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"visual artwork\"}) match (e_1)-[:title]->(pv:Resource{value:\"جدایی نادر از سیمین\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "جدایی نادر از سیمین"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "film release region",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "capital"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_70865",
    "answer": "1"
  },
  {
    "graphq_ir": "which one has the smallest <A> height </A> among <ES> <ES> <E> Stephen Graham </E> whose <A> mass </A> is number <V> 98 kilogram </V> </ES> or <E> Jermaine Easter </E> </ES>",
    "kopl": "Find(Stephen Graham).FilterNum(mass,98 kilogram,=).Find(Jermaine Easter).Or().Select(height,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Stephen Graham\" . ?e <mass> ?pv_1 . ?pv_1 <pred:unit> \"kilogram\" . ?pv_1 <pred:value> \"98\"^^xsd:double . } UNION { ?e <pred:name> \"Jermaine Easter\" . } ?e <height> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Stephen_Graham ( string mass ) ( string = ) ( number 98 kilogram ) ) en.Jermaine_Easter ) ( string min ) ( string height ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Stephen Graham\"\nMATCH (n1) WHERE n1.mass =  98 kilogram \nRETURN n1.name AS name\nORDER BY n1.height DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Jermaine Easter\"\nRETURN n1.name AS name\nORDER BY n1.height DESC\nLIMIT 1",
    "question": "Who is shorter, Stephen Graham (the one whose mass is 98 kilogram) or Jermaine Easter?",
    "cypher_match": "call { match (e:Resource{name:\"Stephen Graham\"})-[:mass]->(pv_1:Resource{unit:\"kilogram\",value:98.0}) return e union match (e:Resource{name:\"Jermaine Easter\"}) return e } match (e)-[:height]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Stephen Graham"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "mass",
          "98 kilogram",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jermaine Easter"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "height",
          "less"
        ]
      }
    ],
    "sample_id": "train_82193",
    "answer": "Jermaine Easter"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> bowed string instrument </C> whose <A> Hornbostel-Sachs classification </A> is text <V> 321.322-71 </V> </ES> or <ES> <C> bowed string instrument </C> that <R> instrument </R> backward to <E> John Hartford </E> </ES> </ES>",
    "kopl": "FindAll().FilterStr(Hornbostel-Sachs classification,321.322-71).FilterConcept(bowed string instrument).Find(John Hartford).Relate(instrument,forward).FilterConcept(bowed string instrument).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"bowed string instrument\" .  { ?e <Hornbostel-Sachs_classification> ?pv . ?pv <pred:value> \"321.322-71\" .  } UNION { ?e_1 <instrument> ?e . ?e_1 <pred:name> \"John Hartford\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.bowed_string_instrument ) ( string ! type ) ) ( string Hornbostel-Sachs_classification ) ( string = ) ( string 321.322-71 ) ) ( call SW.filter ( getProperty ( singleton en.bowed_string_instrument ) ( string ! type ) ) ( call SW.reverse ( string instrument ) ) ) ) ) )",
    "cypher": "MATCH (n1:bowed_string_instrument) WHERE n1.Hornbostel-Sachs_classification = \"321.322-71\"\nRETURN count(n1)\nUNION\nMATCH (n2) WHERE n2.name = \"John Hartford\"\nMATCH (n1:bowed_string_instrument)-[r1:instrument]->(n2)\nRETURN count(n1)",
    "question": "How many bowed string instruments do we know Hornbostel-Sachs classification is 321.322-71 or that are the instrument used by John Hartford?",
    "cypher_match": "call { match (e)-[:`Hornbostel-Sachs_classification`]->(pv:Resource{value:\"321.322-71\"}) return e union match (e_1:Resource{name:\"John Hartford\"})-[:instrument]->(e) return e } match (e)-[:instance_of]->(c:Resource{name:\"bowed string instrument\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Hornbostel-Sachs classification",
          "321.322-71"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "bowed string instrument"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "John Hartford"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "instrument",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "bowed string instrument"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_81502",
    "answer": "4"
  },
  {
    "graphq_ir": "what is the attribute <A> title </A> of <ES> <E> Cobra </E> (<ES> ones that <R> producer </R> forward to <E> Menahem Golan </E> </ES>) </ES>",
    "kopl": "Find(Menahem Golan).Relate(producer,backward).Find(Cobra).And().QueryAttr(title)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Cobra\" . ?e <producer> ?e_1 . ?e_1 <pred:name> \"Menahem Golan\" .  ?e <title> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.and en.Cobra ( lambda s ( call SW.filter ( var s ) ( string producer ) ( string = ) en.Menahem_Golan ) ) ) ( string title ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Cobra\"\nMATCH (n2) WHERE n2.name = \"Menahem Golan\"\nMATCH (n3)<-[r1:producer]-(n2)\nRETURN n3.title",
    "question": "What is the title of Cobra (the one whose producer is Menahem Golan)?",
    "cypher_match": "match (e:Resource{name:\"Cobra\"})-[:producer]->(e_1:Resource{name:\"Menahem Golan\"}) match (e:Resource{name:\"Cobra\"})-[:title]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Menahem Golan"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "producer",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Cobra"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "title"
        ]
      }
    ],
    "sample_id": "train_62213",
    "answer": "Cobra"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <ES> <C> county of North Carolina </C> that <R> named after </R> forward to <ES> <E> James Madison </E> (<ES> ones that <R> member of political party </R> forward to <E> Democratic-Republican Party </E> </ES>) </ES> </ES> whose <A> population </A> is <V> 21022 </V>",
    "kopl": "Find(Democratic-Republican Party).Relate(member of political party,backward).Find(James Madison).And().Relate(named after,backward).FilterConcept(county of North Carolina).QueryAttrQualifier(population,21022,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"county of North Carolina\" . ?e <named_after> ?e_1 . ?e_1 <pred:name> \"James Madison\" . ?e_1 <member_of_political_party> ?e_2 . ?e_2 <pred:name> \"Democratic-Republican Party\" .  ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"21022\"^^xsd:double . [ <pred:fact_h> ?e ; <pred:fact_r> <population> ; <pred:fact_t> ?pv ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"James Madison\"\nMATCH (n3) WHERE n3.name = \"Democratic-Republican Party\"\nMATCH (n4)<-[r2:member_of_political_party]-(n3)\nMATCH (n1:county_of_North_Carolina)<-[r1:named_after]-(n4) WHERE n1.population =  21022 \nRETURN r1.point_in_time",
    "question": "When did a county of North Carolina, named after James Madison (the one that is the member of political party Democratic-Republican Party), reach the population of 21,022 people ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"county of North Carolina\"}) match (e)-[:named_after]->(e_1:Resource{name:\"James Madison\"}) match (e)-[:population]->(pv:Resource{unit:\"1\",value:21022.0}) match (e_1:Resource{name:\"James Madison\"})-[:member_of_political_party]->(e_2:Resource{name:\"Democratic-Republican Party\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"population\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Democratic-Republican Party"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "member of political party",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "James Madison"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "named after",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "county of North Carolina"
        ]
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          5
        ],
        "inputs": [
          "population",
          "21022",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_17604",
    "answer": "2013-07-01"
  },
  {
    "graphq_ir": "which one has the smallest <A> area </A> among <ES> <E> Fort Wayne </E> or <ES> <E> Fontana </E> whose <A> postal code </A> is text <V> 92331, 92334–92337 </V> </ES> </ES>",
    "kopl": "Find(Fort Wayne).Find(Fontana).FilterStr(postal code,92331, 92334–92337).Or().Select(area,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Fort Wayne\" . } UNION { ?e <pred:name> \"Fontana\" . ?e <postal_code> ?pv_1 . ?pv_1 <pred:value> \"92331, 92334–92337\" . } ?e <area> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Fort_Wayne ( call SW.filter en.Fontana ( string postal_code ) ( string = ) ( string 92331, 92334–92337 ) ) ) ( string min ) ( string area ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Fort Wayne\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Fontana\"\nMATCH (n1) WHERE n1.postal_code = \"92331, 92334–92337\"\nRETURN n1.name AS name\nORDER BY n1.area DESC\nLIMIT 1",
    "question": "Which area is smaller, Fort Wayne or Fontana (the one whose postal code is 92331, 92334–92337)?",
    "cypher_match": "call { match (e:Resource{name:\"Fort Wayne\"}) return e union match (e:Resource{name:\"Fontana\"})-[:postal_code]->(pv_1:Resource{value:\"92331, 92334–92337\"}) return e } match (e)-[:area]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Fort Wayne"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Fontana"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "postal code",
          "92331, 92334–92337"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          2
        ],
        "inputs": [
          "area",
          "less"
        ]
      }
    ],
    "sample_id": "train_17763",
    "answer": "Fontana"
  },
  {
    "graphq_ir": "which one has the largest <A> number of children </A> among <ES> <ES> <E> Mark Williams </E> (<ES> ones that <R> winner </R> backward to <E> Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture </E> </ES>) </ES> or <ES> <E> Jon Favreau </E> (<ES> ones that <R> occupation </R> forward to <E> screenwriter </E> </ES>) </ES> </ES>",
    "kopl": "Find(Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture).Relate(winner,forward).Find(Mark Williams).And().Find(screenwriter).Relate(occupation,backward).Find(Jon Favreau).And().Or().Select(number of children,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Mark Williams\" . ?e_1 <winner> ?e . ?e_1 <pred:name> \"Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture\" .   } UNION { ?e <pred:name> \"Jon Favreau\" . ?e <occupation> ?e_2 . ?e_2 <pred:name> \"screenwriter\" .  } ?e <number_of_children> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.Mark_Williams ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string winner ) ) ( string = ) en.Screen_Actors_Guild_Award_for_Outstanding_Performance_by_a_Cast_in_a_Motion_Picture ) ) ) ( call SW.and en.Jon_Favreau ( lambda s ( call SW.filter ( var s ) ( string occupation ) ( string = ) en.screenwriter ) ) ) ) ( string max ) ( string number_of_children ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Mark Williams\"\nMATCH (n2) WHERE n2.name = \"Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture\"\nMATCH (n3)-[r1:winner]->(n2)\nRETURN n3.name AS name\nORDER BY n3.number_of_children DESC\nUNION\nMATCH (n3) WHERE n3.name = \"Jon Favreau\"\nMATCH (n2) WHERE n2.name = \"screenwriter\"\nMATCH (n3)<-[r1:occupation]-(n2)\nRETURN n3.name AS name\nORDER BY n3.number_of_children DESC\nLIMIT 1",
    "question": "Who has more children, Mark Williams (the one that wins Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture) or Jon Favreau (the one that has the occupation of screenwriter)?",
    "cypher_match": "call { match (e_1:Resource{name:\"Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture\"})-[:winner]->(e:Resource{name:\"Mark Williams\"}) return e union match (e:Resource{name:\"Jon Favreau\"})-[:occupation]->(e_2:Resource{name:\"screenwriter\"}) return e } match (e)-[:number_of_children]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Screen Actors Guild Award for Outstanding Performance by a Cast in a Motion Picture"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "winner",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Mark Williams"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "screenwriter"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          4
        ],
        "inputs": [
          "occupation",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Jon Favreau"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          5,
          6
        ],
        "inputs": []
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          7
        ],
        "inputs": [
          "number of children",
          "greater"
        ]
      }
    ],
    "sample_id": "train_79231",
    "answer": "Jon Favreau"
  },
  {
    "graphq_ir": "what is the relation from <E> Anchorage </E> to <ES> <E> Darwin </E> whose <A> inception </A> is year <V> 1869 </V> </ES>",
    "kopl": "Find(Anchorage).Find(Darwin).FilterYear(inception,1869,=).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Anchorage\" . ?e_2 <pred:name> \"Darwin\" . ?e_2 <inception> ?pv . ?pv <pred:year> 1869 . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Anchorage\"\nMATCH (n2) WHERE n2.name = \"Darwin\"\nMATCH (n2) WHERE n2.inception =  1869 \nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How is Anchorage related to Darwin, founded in 1869?",
    "cypher_match": "match (e_2:Resource{name:\"Darwin\"})-[:inception]->(pv:Resource{year:1869}) match (e_1:Resource{name:\"Anchorage\"})-[p]->(e_2:Resource{name:\"Darwin\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Anchorage"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Darwin"
        ]
      },
      {
        "function": "FilterYear",
        "dependencies": [
          1
        ],
        "inputs": [
          "inception",
          "1869",
          "="
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_76714",
    "answer": "twinned administrative body"
  },
  {
    "graphq_ir": "what is the relation from <ES> <E> Perth Airport </E> whose <A> patronage </A> is number <V> 3202023 </V> </ES> to <ES> <E> Australia </E> (<ES> ones that <R> named after </R> backward to <E> South Australia </E> </ES>) </ES>",
    "kopl": "Find(Perth Airport).FilterNum(patronage,3202023,=).Find(South Australia).Relate(named after,forward).Find(Australia).And().QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"Perth Airport\" . ?e_1 <patronage> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> \"3202023\"^^xsd:double . ?e_2 <pred:name> \"Australia\" . ?e_3 <named_after> ?e_2 . ?e_3 <pred:name> \"South Australia\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Perth Airport\"\nMATCH (n1) WHERE n1.patronage =  3202023 \nMATCH (n4) WHERE n4.name = \"Australia\"\nMATCH (n3) WHERE n3.name = \"South Australia\"\nMATCH (n4)-[r1:named_after]->(n3)\nMATCH (n1)-[r2]->(n4)\nRETURN r2.label",
    "question": "What is the connection between Perth Airport (the one whose patronage is 3202023) to Australia (the one that is the origin of the name South Australia)?",
    "cypher_match": "match (e_1:Resource{name:\"Perth Airport\"})-[:patronage]->(pv:Resource{unit:\"1\",value:3202023.0}) match (e_1:Resource{name:\"Perth Airport\"})-[p]->(e_2:Resource{name:\"Australia\"}) match (e_3:Resource{name:\"South Australia\"})-[:named_after]->(e_2:Resource{name:\"Australia\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Perth Airport"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "patronage",
          "3202023",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "South Australia"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "named after",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Australia"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          3,
          4
        ],
        "inputs": []
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          1,
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_68103",
    "answer": "continent"
  },
  {
    "graphq_ir": "what is the qualifier <Q> place of publication </Q> of <ES> <E> X-Men Origins: Wolverine </E> (<ES> ones that <R> film release region </R> forward to <E> Eindhoven </E> </ES>) </ES> whose <A> publication date </A> is <V> 2009-04-30 </V>",
    "kopl": "Find(Eindhoven).Relate(film release region,backward).Find(X-Men Origins: Wolverine).And().QueryAttrQualifier(publication date,2009-04-30,place of publication)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"X-Men Origins: Wolverine\" . ?e <film_release_region> ?e_1 . ?e_1 <pred:name> \"Eindhoven\" .  ?e <publication_date> ?pv . ?pv <pred:date> \"2009-04-30\"^^xsd:date . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE (n3.name = \"X-Men Origins: Wolverine\" AND n3.publication_date =  2009-04-30 )\nMATCH (n2) WHERE n2.name = \"Eindhoven\"\nMATCH (n3)<-[r1:film_release_region]-(n2)\nRETURN r1.place_of_publication",
    "question": "X-Men Origins: Wolverine, released in Eindhoven, was released in which place on 2009-04-30?",
    "cypher_match": "match (e:Resource{name:\"X-Men Origins: Wolverine\"})-[:film_release_region]->(e_1:Resource{name:\"Eindhoven\"}) match (e:Resource{name:\"X-Men Origins: Wolverine\"})-[:publication_date]->(pv:Resource{date:Date(\"2009-04-30\")}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Eindhoven"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "film release region",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "X-Men Origins: Wolverine"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          3
        ],
        "inputs": [
          "publication date",
          "2009-04-30",
          "place of publication"
        ]
      }
    ],
    "sample_id": "train_42396",
    "answer": "Hungary"
  },
  {
    "graphq_ir": "what is <ES> <C> association football club </C> that <R> member of sports team </R> backward to <ES> <C> human </C> whose <A> McCune-Reischauer romanization </A> is text <V> Chŏng Sŏngnyong </V> </ES> ( <Q> start time </Q> is year <V> 2011 </V> ) </ES>",
    "kopl": "FindAll().FilterStr(McCune-Reischauer romanization,Chŏng Sŏngnyong).FilterConcept(human).Relate(member of sports team,forward).QFilterYear(start time,2011,=).FilterConcept(association football club).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"association football club\" . ?e_1 <member_of_sports_team> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"human\" . ?e_1 <McCune-Reischauer_romanization> ?pv . ?pv <pred:value> \"Chŏng Sŏngnyong\" .  [ <pred:fact_h> ?e_1 ; <pred:fact_r> <member_of_sports_team> ; <pred:fact_t> ?e ] <start_time> ?qpv . ?qpv <pred:year> 2011 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2:human) WHERE n2.McCune-Reischauer_romanization = \"Chŏng Sŏngnyong\"\nMATCH (n1:association_football_club)-[r1:member_of_sports_team]->(n2) WHERE r1.start_time =  2011 \nRETURN n1.name",
    "question": "Which association football club has, as a member (beginning in 2011), the human whose McCune-Reischauer romanization is Chŏng Sŏngnyong?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"association football club\"}) match (e_1)-[:member_of_sports_team]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"human\"}) match (e_1)-[:`McCune-Reischauer_romanization`]->(pv:Resource{value:\"Chŏng Sŏngnyong\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e), (tmp)-[:fact_r]-(qr:Relation{name:\"member_of_sports_team\"}),(tmp)-[:start_time]->(qpv:Resource{year:2011}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "McCune-Reischauer romanization",
          "Chŏng Sŏngnyong"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "member of sports team",
          "forward"
        ]
      },
      {
        "function": "QFilterYear",
        "dependencies": [
          3
        ],
        "inputs": [
          "start time",
          "2011",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "association football club"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          5
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_80882",
    "answer": "Suwon Samsung Bluewings"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <C> television film </C> that <R> color </R> forward to <E> black-and-white </E> </ES>",
    "kopl": "Find(black-and-white).Relate(color,backward).FilterConcept(television film).Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"television film\" . ?e <color> ?e_1 . ?e_1 <pred:name> \"black-and-white\" .  ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.filter ( getProperty ( singleton en.television_film ) ( string ! type ) ) ( string color ) ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n2) WHERE n2.name = \"black-and-white\"\nMATCH (n1:television_film)<-[r1:color]-(n2)\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "Of all the television films done in black-and-white, which is the longest in duration?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"television film\"}) match (e)-[:color]->(e_1:Resource{name:\"black-and-white\"}) match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "black-and-white"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "color",
          "backward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "television film"
        ]
      },
      {
        "function": "SelectAmong",
        "dependencies": [
          2
        ],
        "inputs": [
          "duration",
          "largest"
        ]
      }
    ],
    "sample_id": "train_40567",
    "answer": "Germany in Autumn"
  },
  {
    "graphq_ir": "which one has the largest <A> number of episodes </A> among <ES> <ES> <E> Las Vegas </E> whose <A> official website </A> is text <V> http://www.nbc.com/Las_Vegas/ </V> </ES> or <E> Degrassi: The Next Generation </E> </ES>",
    "kopl": "Find(Las Vegas).FilterStr(official website,http://www.nbc.com/Las_Vegas/).Find(Degrassi: The Next Generation).Or().Select(number of episodes,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Las Vegas\" . ?e <official_website> ?pv_1 . ?pv_1 <pred:value> \"http://www.nbc.com/Las_Vegas/\" . } UNION { ?e <pred:name> \"Degrassi: The Next Generation\" . } ?e <number_of_episodes> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Las_Vegas ( string official_website ) ( string = ) ( string http://www.nbc.com/Las_Vegas/ ) ) en.Degrassi:_The_Next_Generation ) ( string max ) ( string number_of_episodes ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Las Vegas\"\nMATCH (n1) WHERE n1.official_website = \"http://www.nbc.com/Las_Vegas/\"\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Degrassi: The Next Generation\"\nRETURN n1.name AS name\nORDER BY n1.number_of_episodes DESC\nLIMIT 1",
    "question": "Is the episode count higher for Las Vegas, of the website www.nbc.com/Las_Vegas, or for Degrassi: The Next Generation?",
    "cypher_match": "call { match (e:Resource{name:\"Las Vegas\"})-[:official_website]->(pv_1:Resource{value:\"http://www.nbc.com/Las_Vegas/\"}) return e union match (e:Resource{name:\"Degrassi: The Next Generation\"}) return e } match (e)-[:number_of_episodes]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Las Vegas"
        ]
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.nbc.com/Las_Vegas/"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Degrassi: The Next Generation"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "number of episodes",
          "greater"
        ]
      }
    ],
    "sample_id": "train_38973",
    "answer": "Degrassi: The Next Generation"
  },
  {
    "graphq_ir": "what is the qualifier <Q> point in time </Q> of <E> BAFTA Award for Best Direction </E> that <R> winner </R> to <ES> <E> Robert Altman </E> (<ES> ones that <R> director </R> backward to <E> Gosford Park </E> </ES>) </ES>",
    "kopl": "Find(BAFTA Award for Best Direction).Find(Gosford Park).Relate(director,forward).Find(Robert Altman).And().QueryRelationQualifier(winner,point in time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"BAFTA Award for Best Direction\" . ?e_2 <pred:name> \"Robert Altman\" . ?e_3 <director> ?e_2 . ?e_3 <pred:name> \"Gosford Park\" . ?e_1 <winner> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <winner> ; <pred:fact_t> ?e_2 ] <point_in_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"BAFTA Award for Best Direction\"\nMATCH (n4) WHERE n4.name = \"Robert Altman\"\nMATCH (n3) WHERE n3.name = \"Gosford Park\"\nMATCH (n4)-[r1:director]->(n3)\nMATCH (n1)-[r2:winner]->(n4)\nRETURN r2.point_in_time",
    "question": "At what time point is the BAFTA Award for Best Direction won by Robert Altman (the one that is the director of Gosford Park)?",
    "cypher_match": "match (e_3:Resource{name:\"Gosford Park\"})-[:director]->(e_2:Resource{name:\"Robert Altman\"}) match (e_1:Resource{name:\"BAFTA Award for Best Direction\"})-[:winner]->(e_2:Resource{name:\"Robert Altman\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"winner\"}),(tmp)-[:point_in_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "BAFTA Award for Best Direction"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Gosford Park"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          1
        ],
        "inputs": [
          "director",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Robert Altman"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          2,
          3
        ],
        "inputs": []
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          0,
          4
        ],
        "inputs": [
          "winner",
          "point in time"
        ]
      }
    ],
    "sample_id": "train_58124",
    "answer": "1993"
  },
  {
    "graphq_ir": "which one has the largest <A> GDP (PPP) </A> among <ES> <ES> <E> Israel </E> whose <A> area </A> is number <V> 20770 square kilometre </V> </ES> or <E> East Timor </E> </ES>",
    "kopl": "Find(Israel).FilterNum(area,20770 square kilometre,=).Find(East Timor).Or().Select(GDP (PPP),largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Israel\" . ?e <area> ?pv_1 . ?pv_1 <pred:unit> \"square kilometre\" . ?pv_1 <pred:value> \"20770\"^^xsd:double . } UNION { ?e <pred:name> \"East Timor\" . } ?e <GDP_(PPP)> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Israel ( string area ) ( string = ) ( number 20770 square kilometre ) ) en.East_Timor ) ( string max ) ( string GDP_(PPP) ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Israel\"\nMATCH (n1) WHERE n1.area =  20770 square kilometre \nRETURN n1.name AS name\nORDER BY n1.GDP_(PPP) DESC\nUNION\nMATCH (n1) WHERE n1.name = \"East Timor\"\nRETURN n1.name AS name\nORDER BY n1.GDP_(PPP) DESC\nLIMIT 1",
    "question": "Between Israel, with an area of 20770 square kilometres, or East Timor, who has a greater GDP (PPP)?",
    "cypher_match": "call { match (e:Resource{name:\"Israel\"})-[:area]->(pv_1:Resource{unit:\"square kilometre\",value:20770.0}) return e union match (e:Resource{name:\"East Timor\"}) return e } match (e)-[:`GDP_(PPP)`]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Israel"
        ]
      },
      {
        "function": "FilterNum",
        "dependencies": [
          0
        ],
        "inputs": [
          "area",
          "20770 square kilometre",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "East Timor"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "GDP (PPP)",
          "greater"
        ]
      }
    ],
    "sample_id": "train_42754",
    "answer": "Israel"
  },
  {
    "graphq_ir": "what is <ES> <C> legislative term </C> whose <A> end time </A> is date <V> 1839-03-04 </V> </ES>",
    "kopl": "FindAll().FilterDate(end time,1839-03-04,=).FilterConcept(legislative term).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"legislative term\" . ?e <end_time> ?pv . ?pv <pred:date> \"1839-03-04\"^^xsd:date .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.legislative_term ) ( string ! type ) ) ( string end_time ) ( string = ) ( date 1839-03-04 ) ) )",
    "cypher": "MATCH (n1:legislative_term) WHERE n1.end_time =  1839-03-04 \nRETURN n1.name",
    "question": "Which legislative term ended on 1839-03-04 ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"legislative term\"}) match (e)-[:end_time]->(pv:Resource{date:Date(\"1839-03-04\")}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "end time",
          "1839-03-04",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "legislative term"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_92081",
    "answer": "25th United States Congress"
  },
  {
    "graphq_ir": "which one has the largest <A> population </A> among <ES> <E> County Antrim </E> or <E> United States Virgin Islands </E> </ES>",
    "kopl": "Find(County Antrim).Find(United States Virgin Islands).Or().Select(population,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"County Antrim\" .  } UNION { ?e <pred:name> \"United States Virgin Islands\" .  } ?e <population> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.County_Antrim en.United_States_Virgin_Islands ) ( string max ) ( string population ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"County Antrim\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nUNION\nMATCH (n1) WHERE n1.name = \"United States Virgin Islands\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nLIMIT 1",
    "question": "Does County Antrim or the US Virgin Islands have a larger number of inhabitants?",
    "cypher_match": "call { match (e:Resource{name:\"County Antrim\"}) return e union match (e:Resource{name:\"United States Virgin Islands\"}) return e } match (e)-[:population]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "County Antrim"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "United States Virgin Islands"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "population",
          "greater"
        ]
      }
    ],
    "sample_id": "train_31694",
    "answer": "County Antrim"
  },
  {
    "graphq_ir": "what is <ES> <C> university </C> whose <A> official website </A> is text <V> http://www.sfu.ca/ </V> </ES>",
    "kopl": "FindAll().FilterStr(official website,http://www.sfu.ca/).FilterConcept(university).What()",
    "sparql": "SELECT DISTINCT ?e WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"university\" . ?e <official_website> ?pv . ?pv <pred:value> \"http://www.sfu.ca/\" .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.filter ( getProperty ( singleton en.university ) ( string ! type ) ) ( string official_website ) ( string = ) ( string http://www.sfu.ca/ ) ) )",
    "cypher": "MATCH (n1:university) WHERE n1.official_website = \"http://www.sfu.ca/\"\nRETURN n1.name",
    "question": "http://www.sfu.ca/ is the official website of which university?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"university\"}) match (e)-[:official_website]->(pv:Resource{value:\"http://www.sfu.ca/\"}) return distinct e.name",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.sfu.ca/"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "university"
        ]
      },
      {
        "function": "What",
        "dependencies": [
          2
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_62755",
    "answer": "Simon Fraser University"
  },
  {
    "graphq_ir": "which one has the largest <A> duration </A> among <ES> <ES> <E> Rock of Ages </E> whose <A> publication date </A> is date <V> 2012-06-14 </V> </ES> or <E> A Prophet </E> </ES>",
    "kopl": "Find(Rock of Ages).FilterDate(publication date,2012-06-14,=).Find(A Prophet).Or().Select(duration,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Rock of Ages\" . ?e <publication_date> ?pv_1 . ?pv_1 <pred:date> \"2012-06-14\"^^xsd:date . } UNION { ?e <pred:name> \"A Prophet\" . } ?e <duration> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.filter en.Rock_of_Ages ( string publication_date ) ( string = ) ( date 2012-06-14 ) ) en.A_Prophet ) ( string max ) ( string duration ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Rock of Ages\"\nMATCH (n1) WHERE n1.publication_date =  2012-06-14 \nRETURN n1.name AS name\nORDER BY n1.duration DESC\nUNION\nMATCH (n1) WHERE n1.name = \"A Prophet\"\nRETURN n1.name AS name\nORDER BY n1.duration DESC\nLIMIT 1",
    "question": "What is the relationship between Rock of Ages (the one whose publication date is 2012-06-14) or A Prophet?",
    "cypher_match": "call { match (e:Resource{name:\"Rock of Ages\"})-[:publication_date]->(pv_1:Resource{date:Date(\"2012-06-14\")}) return e union match (e:Resource{name:\"A Prophet\"}) return e } match (e)-[:duration]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Rock of Ages"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "publication date",
          "2012-06-14",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "A Prophet"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "duration",
          "greater"
        ]
      }
    ],
    "sample_id": "train_32280",
    "answer": "A Prophet"
  },
  {
    "graphq_ir": "whether <ES> <C> city of the United States </C> whose <A> official website </A> is text <V> http://www.cityofspartanburg.org </V> </ES> <A> population </A> larger than number <V> 580000 </V>",
    "kopl": "FindAll().FilterStr(official website,http://www.cityofspartanburg.org).FilterConcept(city of the United States).QueryAttr(population).VerifyNum(580000,>)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"city of the United States\" . ?e <official_website> ?pv_1 . ?pv_1 <pred:value> \"http://www.cityofspartanburg.org\" . ?e <population> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v > \"580000\"^^xsd:double ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1:city_of_the_United_States) WHERE (n1.official_website = \"http://www.cityofspartanburg.org\" AND n1.population >  580000 )\nRETURN isEmpty(n1)",
    "question": "About the United States city with official website http://www.cityofspartanburg.org, is its population over 580000 ?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"city of the United States\"}) match (e)-[:official_website]->(pv_1:Resource{value:\"http://www.cityofspartanburg.org\"}) match (e)-[:population]->(pv:Resource{unit:\"1\"}) return pv.value >  580000.0 ",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "official website",
          "http://www.cityofspartanburg.org"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "city of the United States"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          2
        ],
        "inputs": [
          "population"
        ]
      },
      {
        "function": "VerifyNum",
        "dependencies": [
          3
        ],
        "inputs": [
          "580000",
          ">"
        ]
      }
    ],
    "sample_id": "train_16089",
    "answer": "no"
  },
  {
    "graphq_ir": "which one has the smallest <A> cost </A> among <ES> <ES> <E> The Lord of the Rings: The Fellowship of the Ring </E> (<ES> ones that <R> nominated for </R> forward to <E> Academy Award for Best Makeup and Hairstyling </E> </ES>) </ES> or <E> J. Edgar </E> </ES>",
    "kopl": "Find(Academy Award for Best Makeup and Hairstyling).Relate(nominated for,backward).Find(The Lord of the Rings: The Fellowship of the Ring).And().Find(J. Edgar).Or().Select(cost,smallest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"The Lord of the Rings: The Fellowship of the Ring\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Makeup and Hairstyling\" .   } UNION { ?e <pred:name> \"J. Edgar\" .  } ?e <cost> ?pv . ?pv <pred:value> ?v .  } ORDER BY ?v LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat ( call SW.and en.The_Lord_of_the_Rings:_The_Fellowship_of_the_Ring ( lambda s ( call SW.filter ( var s ) ( string nominated_for ) ( string = ) en.Academy_Award_for_Best_Makeup_and_Hairstyling ) ) ) en.J._Edgar ) ( string min ) ( string cost ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"The Lord of the Rings: The Fellowship of the Ring\"\nMATCH (n2) WHERE n2.name = \"Academy Award for Best Makeup and Hairstyling\"\nMATCH (n3)<-[r1:nominated_for]-(n2)\nRETURN n3.name AS name\nORDER BY n3.cost DESC\nUNION\nMATCH (n1) WHERE n1.name = \"J. Edgar\"\nRETURN n1.name AS name\nORDER BY n3.cost DESC\nLIMIT 1",
    "question": "Does The Lord of the Rings: The Fellowship of the Ring (that was nominated for an Academy Award for Best Makeup and Hairstyling) or J. Edgar have the lower cost?",
    "cypher_match": "call { match (e:Resource{name:\"The Lord of the Rings: The Fellowship of the Ring\"})-[:nominated_for]->(e_1:Resource{name:\"Academy Award for Best Makeup and Hairstyling\"}) return e union match (e:Resource{name:\"J. Edgar\"}) return e } match (e)-[:cost]->(pv) return e order by pv.value limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Makeup and Hairstyling"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Lord of the Rings: The Fellowship of the Ring"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "J. Edgar"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "cost",
          "less"
        ]
      }
    ],
    "sample_id": "train_88215",
    "answer": "J. Edgar"
  },
  {
    "graphq_ir": "how many <ES> <C> film production company </C> that <R> producer </R> backward to <ES> <C> visual artwork </C> whose <A> title </A> is text <V> To Kill a Mockingbird </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(title,To Kill a Mockingbird).FilterConcept(visual artwork).Relate(producer,forward).FilterConcept(film production company).Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"film production company\" . ?e_1 <producer> ?e . ?e_1 <pred:instance_of> ?c_1 . ?c_1 <pred:name> \"visual artwork\" . ?e_1 <title> ?pv . ?pv <pred:value> \"To Kill a Mockingbird\" .   }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.filter ( getProperty ( singleton en.film_production_company ) ( string ! type ) ) ( call SW.reverse ( string producer ) ) ) ) )",
    "cypher": "MATCH (n2:visual_artwork) WHERE n2.title = \"To Kill a Mockingbird\"\nMATCH (n1:film_production_company)-[r1:producer]->(n2)\nRETURN count(n1)",
    "question": "The visual artwork titled To Kill a Mockingbird was made by how many film production companies?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"film production company\"}) match (e_1)-[:producer]->(e) match (e_1)-[:instance_of]->(c_1:Resource{name:\"visual artwork\"}) match (e_1)-[:title]->(pv:Resource{value:\"To Kill a Mockingbird\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "title",
          "To Kill a Mockingbird"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "visual artwork"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          2
        ],
        "inputs": [
          "producer",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          3
        ],
        "inputs": [
          "film production company"
        ]
      },
      {
        "function": "Count",
        "dependencies": [
          4
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_58200",
    "answer": "1"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> nominated for </R> forward to <E> Academy Award for Best Supporting Actress </E> ( <Q> for work </Q> is text <V> Ragtime </V> ) </ES> <A> ISNI </A> is text <V> 0000 0001 0306 6927 </V>",
    "kopl": "Find(Academy Award for Best Supporting Actress).Relate(nominated for,backward).QFilterStr(for work,Ragtime).FilterConcept(human).QueryAttr(ISNI).VerifyStr(0000 0001 0306 6927)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Academy Award for Best Supporting Actress\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <for_work> ?qpv . ?qpv <pred:value> \"Ragtime\" . ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0001 0306 6927\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Academy Award for Best Supporting Actress\"\nMATCH (n1:human)<-[r1:nominated_for]-(n2) WHERE (r1.for_work = \"Ragtime\" AND n1.ISNI = \"0000 0001 0306 6927\")\nRETURN isEmpty(n1)",
    "question": "Is 0000 0001 0306 6927 the ISNI of the person who was nominated for Academy Award for Best Supporting Actress (the award-winning work of this statement is Ragtime), i?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:nominated_for]->(e_1:Resource{name:\"Academy Award for Best Supporting Actress\"}) match (e)-[:ISNI]->(pv:Resource),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:for_work]->(qpv:Resource{value:\"Ragtime\"}) return pv.value = \"0000 0001 0306 6927\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Academy Award for Best Supporting Actress"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "QFilterStr",
        "dependencies": [
          1
        ],
        "inputs": [
          "for work",
          "Ragtime"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          4
        ],
        "inputs": [
          "0000 0001 0306 6927"
        ]
      }
    ],
    "sample_id": "train_48852",
    "answer": "no"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> cast member </R> backward to <ES> <E> Some Like It Hot </E> (<ES> ones that <R> distributor </R> forward to <E> Paramount Pictures </E> </ES>) </ES> </ES> <A> CANTIC-ID </A> is text <V> a11051796 </V>",
    "kopl": "Find(Paramount Pictures).Relate(distributor,backward).Find(Some Like It Hot).And().Relate(cast member,forward).FilterConcept(human).QueryAttr(CANTIC-ID).VerifyStr(a11051796)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e_1 <cast_member> ?e . ?e_1 <pred:name> \"Some Like It Hot\" . ?e_1 <distributor> ?e_2 . ?e_2 <pred:name> \"Paramount Pictures\" .  ?e <CANTIC-ID> ?pv . ?pv <pred:value> \"a11051796\" .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n4) WHERE n4.name = \"Some Like It Hot\"\nMATCH (n3) WHERE n3.name = \"Paramount Pictures\"\nMATCH (n4)<-[r2:distributor]-(n3)\nMATCH (n1:human)-[r1:cast_member]->(n4) WHERE n1.CANTIC-ID = \"a11051796\"\nRETURN isEmpty(n1)",
    "question": "Does the person who is a cast member of Some Like It Hot (the one whose distributor is Paramount Pictures), have a CANTIC-ID equal to a11051796?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:`CANTIC-ID`]->(pv:Resource) match (e_1:Resource{name:\"Some Like It Hot\"})-[:cast_member]->(e) match (e_1:Resource{name:\"Some Like It Hot\"})-[:distributor]->(e_2:Resource{name:\"Paramount Pictures\"}) return pv.value = \"a11051796\"",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Paramount Pictures"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "distributor",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Some Like It Hot"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Relate",
        "dependencies": [
          3
        ],
        "inputs": [
          "cast member",
          "forward"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          5
        ],
        "inputs": [
          "CANTIC-ID"
        ]
      },
      {
        "function": "VerifyStr",
        "dependencies": [
          6
        ],
        "inputs": [
          "a11051796"
        ]
      }
    ],
    "sample_id": "train_82950",
    "answer": "yes"
  },
  {
    "graphq_ir": "how many <ES> <ES> <C> religion </C> whose <A> Universal Decimal Classification </A> is text <V> 141.45 </V> </ES> or <ES> <C> religion </C> whose <A> ISNI </A> is text <V> 0000 0004 0508 6616 </V> </ES> </ES>",
    "kopl": "FindAll().FilterStr(Universal Decimal Classification,141.45).FilterConcept(religion).FindAll().FilterStr(ISNI,0000 0004 0508 6616).FilterConcept(religion).Or().Count()",
    "sparql": "SELECT (COUNT(DISTINCT ?e) AS ?count) WHERE { ?e <pred:instance_of> ?c . ?c <pred:name> \"religion\" .  { ?e <Universal_Decimal_Classification> ?pv . ?pv <pred:value> \"141.45\" .  } UNION { ?e <ISNI> ?pv . ?pv <pred:value> \"0000 0004 0508 6616\" .  } }",
    "lambda-dcs": "( call SW.listValue ( call .size ( call SW.concat ( call SW.filter ( getProperty ( singleton en.religion ) ( string ! type ) ) ( string Universal_Decimal_Classification ) ( string = ) ( string 141.45 ) ) ( call SW.filter ( getProperty ( singleton en.religion ) ( string ! type ) ) ( string ISNI ) ( string = ) ( string 0000 0004 0508 6616 ) ) ) ) )",
    "cypher": "MATCH (n1:religion) WHERE n1.Universal_Decimal_Classification = \"141.45\"\nRETURN count(n1)\nUNION\nMATCH (n1:religion) WHERE n1.ISNI = \"0000 0004 0508 6616\"\nRETURN count(n1)",
    "question": "What is the number of religions that have Universal Decimal Classification is 141.45 or whose ISNI is 0000 0004 0508 6616",
    "cypher_match": "call { match (e)-[:Universal_Decimal_Classification]->(pv:Resource{value:\"141.45\"}) return e union match (e)-[:ISNI]->(pv:Resource{value:\"0000 0004 0508 6616\"}) return e } match (e)-[:instance_of]->(c:Resource{name:\"religion\"}) return count(distinct e) as n",
    "program": [
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          0
        ],
        "inputs": [
          "Universal Decimal Classification",
          "141.45"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          1
        ],
        "inputs": [
          "religion"
        ]
      },
      {
        "function": "FindAll",
        "dependencies": [],
        "inputs": []
      },
      {
        "function": "FilterStr",
        "dependencies": [
          3
        ],
        "inputs": [
          "ISNI",
          "0000 0004 0508 6616"
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          4
        ],
        "inputs": [
          "religion"
        ]
      },
      {
        "function": "Or",
        "dependencies": [
          2,
          5
        ],
        "inputs": []
      },
      {
        "function": "Count",
        "dependencies": [
          6
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_35266",
    "answer": "2"
  },
  {
    "graphq_ir": "whether <ES> <C> human </C> that <R> nominated for </R> forward to <E> Nobel Prize in Chemistry </E> ( <Q> point in time </Q> is date <V> 1955-01-01 </V> ) </ES> <A> Erdős number </A> is not number <V> 3.1 </V>",
    "kopl": "Find(Nobel Prize in Chemistry).Relate(nominated for,backward).QFilterDate(point in time,1955-01-01,=).FilterConcept(human).QueryAttr(Erdős number).VerifyNum(3.1,!=)",
    "sparql": "ASK { ?e <pred:instance_of> ?c . ?c <pred:name> \"human\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Nobel Prize in Chemistry\" .  [ <pred:fact_h> ?e ; <pred:fact_r> <nominated_for> ; <pred:fact_t> ?e_1 ] <point_in_time> ?qpv . ?qpv <pred:date> \"1955-01-01\"^^xsd:date . ?e <Erdős_number> ?pv . ?pv <pred:unit> \"1\" . ?pv <pred:value> ?v . FILTER ( ?v != \"3.1\"^^xsd:double ) .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n2) WHERE n2.name = \"Nobel Prize in Chemistry\"\nMATCH (n1:human)<-[r1:nominated_for]-(n2) WHERE (r1.point_in_time =  1955-01-01  AND n1.Erdős_number <>  3.1 )\nRETURN isEmpty(n1)",
    "question": "Is Erdős number of a person, who was nominated for  Nobel Prize in Chemistry on 1955-01-01, equal to 3.1?",
    "cypher_match": "match (e)-[:instance_of]->(c:Resource{name:\"human\"}) match (e)-[:nominated_for]->(e_1:Resource{name:\"Nobel Prize in Chemistry\"}) match (e)-[:Erdős_number]->(pv:Resource{unit:\"1\"}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(e_1), (tmp)-[:fact_r]-(qr:Relation{name:\"nominated_for\"}),(tmp)-[:point_in_time]->(qpv:Resource{date:Date(\"1955-01-01\")}) return pv.value <>  3.1 ",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Nobel Prize in Chemistry"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "QFilterDate",
        "dependencies": [
          1
        ],
        "inputs": [
          "point in time",
          "1955-01-01",
          "="
        ]
      },
      {
        "function": "FilterConcept",
        "dependencies": [
          2
        ],
        "inputs": [
          "human"
        ]
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "Erdős number"
        ]
      },
      {
        "function": "VerifyNum",
        "dependencies": [
          4
        ],
        "inputs": [
          "3.1",
          "!="
        ]
      }
    ],
    "sample_id": "train_45018",
    "answer": "yes"
  },
  {
    "graphq_ir": "what is the qualifier <Q> end time </Q> of <ES> <E> Hulk </E> (<ES> ones that <R> sport </R> forward to <E> association football </E> </ES>) </ES> that <R> member of sports team </R> to <E> F.C. Zenit St. Petersburg </E>",
    "kopl": "Find(association football).Relate(sport,backward).Find(Hulk).And().Find(F.C. Zenit St. Petersburg).QueryRelationQualifier(member of sports team,end time)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Hulk\" . ?e_1 <sport> ?e_3 . ?e_3 <pred:name> \"association football\" . ?e_2 <pred:name> \"F.C. Zenit St. Petersburg\" . ?e_1 <member_of_sports_team> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <member_of_sports_team> ; <pred:fact_t> ?e_2 ] <end_time> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE n3.name = \"Hulk\"\nMATCH (n2) WHERE n2.name = \"association football\"\nMATCH (n3)<-[r1:sport]-(n2)\nMATCH (n4) WHERE n4.name = \"F.C. Zenit St. Petersburg\"\nMATCH (n3)-[r2:member_of_sports_team]->(n4)\nRETURN r2.end_time",
    "question": "When did Hulk (the one that is related to sport association football) stop being a member of F.C. Zenit St. Petersburg?",
    "cypher_match": "match (e_1:Resource{name:\"Hulk\"})-[:sport]->(e_3:Resource{name:\"association football\"}) match (e_1:Resource{name:\"Hulk\"})-[:member_of_sports_team]->(e_2:Resource{name:\"F.C. Zenit St. Petersburg\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"member_of_sports_team\"}),(tmp)-[:end_time]->(qpv) return distinct qpv",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "association football"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "sport",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Hulk"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "F.C. Zenit St. Petersburg"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          3,
          4
        ],
        "inputs": [
          "member of sports team",
          "end time"
        ]
      }
    ],
    "sample_id": "train_69453",
    "answer": "2016"
  },
  {
    "graphq_ir": "what is the qualifier <Q> character role </Q> of <ES> <E> Harry Potter and the Chamber of Secrets </E> whose <A> publication date </A> is date <V> 2002-11-14 </V> </ES> that <R> cast member </R> to <E> Toby Jones </E>",
    "kopl": "Find(Harry Potter and the Chamber of Secrets).FilterDate(publication date,2002-11-14,=).Find(Toby Jones).QueryRelationQualifier(cast member,character role)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e_1 <pred:name> \"Harry Potter and the Chamber of Secrets\" . ?e_1 <publication_date> ?pv . ?pv <pred:date> \"2002-11-14\"^^xsd:date . ?e_2 <pred:name> \"Toby Jones\" . ?e_1 <cast_member> ?e_2 . [ <pred:fact_h> ?e_1 ; <pred:fact_r> <cast_member> ; <pred:fact_t> ?e_2 ] <character_role> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"Harry Potter and the Chamber of Secrets\"\nMATCH (n1) WHERE n1.publication_date =  2002-11-14 \nMATCH (n2) WHERE n2.name = \"Toby Jones\"\nMATCH (n1)-[r1:cast_member]->(n2)\nRETURN r1.character_role",
    "question": "What is cast-mate Toby Jones' role on Harry Potter and the Chamber of Secrets, released on 2002-11-14?",
    "cypher_match": "match (e_1:Resource{name:\"Harry Potter and the Chamber of Secrets\"})-[:publication_date]->(pv:Resource{date:Date(\"2002-11-14\")}) match (e_1:Resource{name:\"Harry Potter and the Chamber of Secrets\"})-[:cast_member]->(e_2:Resource{name:\"Toby Jones\"}),(e_1)<-[:fact_h]-(tmp)-[:fact_t]->(e_2), (tmp)-[:fact_r]-(qr:Relation{name:\"cast_member\"}),(tmp)-[:character_role]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Harry Potter and the Chamber of Secrets"
        ]
      },
      {
        "function": "FilterDate",
        "dependencies": [
          0
        ],
        "inputs": [
          "publication date",
          "2002-11-14",
          "="
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Toby Jones"
        ]
      },
      {
        "function": "QueryRelationQualifier",
        "dependencies": [
          1,
          2
        ],
        "inputs": [
          "cast member",
          "character role"
        ]
      }
    ],
    "sample_id": "train_81357",
    "answer": "Dobby"
  },
  {
    "graphq_ir": "which one has the largest <A> population </A> among <ES> <E> Wheaton </E> or <E> Henderson </E> </ES>",
    "kopl": "Find(Wheaton).Find(Henderson).Or().Select(population,largest,1,0).What()",
    "sparql": "SELECT ?e WHERE { { ?e <pred:name> \"Wheaton\" .  } UNION { ?e <pred:name> \"Henderson\" .  } ?e <population> ?pv . ?pv <pred:value> ?v .  } ORDER BY DESC(?v) LIMIT 1",
    "lambda-dcs": "( call SW.listValue ( call SW.superlative ( call SW.concat en.Wheaton en.Henderson ) ( string max ) ( string population ) ) )",
    "cypher": "MATCH (n1) WHERE n1.name = \"Wheaton\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nUNION\nMATCH (n1) WHERE n1.name = \"Henderson\"\nRETURN n1.name AS name\nORDER BY n1.population DESC\nLIMIT 1",
    "question": "Does Wheaton or Henderon have the greater population?",
    "cypher_match": "call { match (e:Resource{name:\"Wheaton\"}) return e union match (e:Resource{name:\"Henderson\"}) return e } match (e)-[:population]->(pv) return e order by pv.value desc limit 1",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Wheaton"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Henderson"
        ]
      },
      {
        "function": "SelectBetween",
        "dependencies": [
          0,
          1
        ],
        "inputs": [
          "population",
          "greater"
        ]
      }
    ],
    "sample_id": "train_2914",
    "answer": "Henderson"
  },
  {
    "graphq_ir": "what is the relation from <E> The Rolling Stones </E> to <E> protopunk </E>",
    "kopl": "Find(The Rolling Stones).Find(protopunk).QueryRelation()",
    "sparql": "SELECT DISTINCT ?p WHERE { ?e_1 <pred:name> \"The Rolling Stones\" . ?e_2 <pred:name> \"protopunk\" . ?e_1 ?p ?e_2 .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n1) WHERE n1.name = \"The Rolling Stones\"\nMATCH (n2) WHERE n2.name = \"protopunk\"\nMATCH (n1)-[r1]->(n2)\nRETURN r1.label",
    "question": "How are The Rolling Stones related to protopunk?",
    "cypher_match": "match (e_1:Resource{name:\"The Rolling Stones\"})-[p]->(e_2:Resource{name:\"protopunk\"}) return distinct type(p)",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "The Rolling Stones"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "protopunk"
        ]
      },
      {
        "function": "QueryRelation",
        "dependencies": [
          0,
          1
        ],
        "inputs": []
      }
    ],
    "sample_id": "train_65636",
    "answer": "genre"
  },
  {
    "graphq_ir": "what is the attribute <A> official website </A> of <ES> <E> Concord </E> (<ES> ones that <R> place of birth </R> backward to <E> Tom Hanks </E> </ES>) </ES>",
    "kopl": "Find(Tom Hanks).Relate(place of birth,forward).Find(Concord).And().QueryAttr(official website)",
    "sparql": "SELECT DISTINCT ?pv WHERE { ?e <pred:name> \"Concord\" . ?e_1 <place_of_birth> ?e . ?e_1 <pred:name> \"Tom Hanks\" .  ?e <official_website> ?pv .  }",
    "lambda-dcs": "( call SW.listValue ( call SW.getProperty ( call SW.and en.Concord ( lambda s ( call SW.filter ( var s ) ( call SW.reverse ( string place_of_birth ) ) ( string = ) en.Tom_Hanks ) ) ) ( string official_website ) ) )",
    "cypher": "MATCH (n3) WHERE n3.name = \"Concord\"\nMATCH (n2) WHERE n2.name = \"Tom Hanks\"\nMATCH (n3)-[r1:place_of_birth]->(n2)\nRETURN n3.official_website",
    "question": "What is the official website of Concord where Tom Hanks was born?",
    "cypher_match": "match (e_1:Resource{name:\"Tom Hanks\"})-[:place_of_birth]->(e:Resource{name:\"Concord\"}) match (e:Resource{name:\"Concord\"})-[:official_website]->(pv) return distinct pv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Tom Hanks"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "place of birth",
          "forward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Concord"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttr",
        "dependencies": [
          3
        ],
        "inputs": [
          "official website"
        ]
      }
    ],
    "sample_id": "train_89623",
    "answer": "http://www.ci.concord.ca.us"
  },
  {
    "graphq_ir": "what is the qualifier <Q> place of publication </Q> of <ES> <E> Taxi Driver </E> (<ES> ones that <R> nominated for </R> forward to <E> Golden Globe Award for Best Screenplay </E> </ES>) </ES> whose <A> publication date </A> is <V> 1977-03-12 </V>",
    "kopl": "Find(Golden Globe Award for Best Screenplay).Relate(nominated for,backward).Find(Taxi Driver).And().QueryAttrQualifier(publication date,1977-03-12,place of publication)",
    "sparql": "SELECT DISTINCT ?qpv WHERE { ?e <pred:name> \"Taxi Driver\" . ?e <nominated_for> ?e_1 . ?e_1 <pred:name> \"Golden Globe Award for Best Screenplay\" .  ?e <publication_date> ?pv . ?pv <pred:date> \"1977-03-12\"^^xsd:date . [ <pred:fact_h> ?e ; <pred:fact_r> <publication_date> ; <pred:fact_t> ?pv ] <place_of_publication> ?qpv .  }",
    "lambda-dcs": "This utterance is not supported by lambda-dcs due to the expressness limit of lambda-dcs",
    "cypher": "MATCH (n3) WHERE (n3.name = \"Taxi Driver\" AND n3.publication_date =  1977-03-12 )\nMATCH (n2) WHERE n2.name = \"Golden Globe Award for Best Screenplay\"\nMATCH (n3)<-[r1:nominated_for]-(n2)\nRETURN r1.place_of_publication",
    "question": "What is the release region for Taxi Driver (that was nominated for a Golden Globe Award for Best Screenplay) whose release date is 1977-03-12?",
    "cypher_match": "match (e:Resource{name:\"Taxi Driver\"})-[:nominated_for]->(e_1:Resource{name:\"Golden Globe Award for Best Screenplay\"}) match (e:Resource{name:\"Taxi Driver\"})-[:publication_date]->(pv:Resource{date:Date(\"1977-03-12\")}),(e)<-[:fact_h]-(tmp)-[:fact_t]->(pv), (tmp)-[:fact_r]-(qr:Relation{name:\"publication_date\"}),(tmp)-[:place_of_publication]->(qpv) return distinct qpv.value",
    "program": [
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Golden Globe Award for Best Screenplay"
        ]
      },
      {
        "function": "Relate",
        "dependencies": [
          0
        ],
        "inputs": [
          "nominated for",
          "backward"
        ]
      },
      {
        "function": "Find",
        "dependencies": [],
        "inputs": [
          "Taxi Driver"
        ]
      },
      {
        "function": "And",
        "dependencies": [
          1,
          2
        ],
        "inputs": []
      },
      {
        "function": "QueryAttrQualifier",
        "dependencies": [
          3
        ],
        "inputs": [
          "publication date",
          "1977-03-12",
          "place of publication"
        ]
      }
    ],
    "sample_id": "train_91683",
    "answer": "Sweden"
  }
]